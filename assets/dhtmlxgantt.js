(function(St, It) {
        typeof exports == "object" && typeof module < "u" ? It(exports) : typeof define == "function" && define.amd ? define(["exports"], It) : It((St = typeof globalThis < "u" ? globalThis : St || self).dhtmlxgantt = {})
    }
)(this, function(St) {
    "use strict";
    /** @license

     dhtmlxGantt v.9.0.15 Professional
     This software can be used only as part of dhtmlx.com site.
     You are not allowed to use it on any other site

     (c) XB Software Ltd.

     */
    function It(t) {
        t.config.auto_scheduling_use_progress = !1,
            t.config.auto_scheduling_project_constraint = !1
    }
    function tn(t) {
        t._get_linked_task = function(o, l) {
            var d = null
                , c = l ? o.target : o.source;
            return t.isTaskExists(c) && (d = t.getTask(c)),
                d
        }
            ,
            t._get_link_target = function(o) {
                return t._get_linked_task(o, !0)
            }
            ,
            t._get_link_source = function(o) {
                return t._get_linked_task(o, !1)
            }
        ;
        var n = !1
            , e = {}
            , i = {}
            , a = {}
            , r = {};
        function s(o) {
            return t.isSummaryTask(o) && o.auto_scheduling === !1
        }
        t._isLinksCacheEnabled = function() {
            return n
        }
            ,
            t._startLinksCache = function() {
                e = {},
                    i = {},
                    a = {},
                    r = {},
                    n = !0
            }
            ,
            t._endLinksCache = function() {
                e = {},
                    i = {},
                    a = {},
                    r = {},
                    n = !1
            }
            ,
            t._formatLink = function(o, l, d) {
                if (n && e[o.id])
                    return e[o.id];
                var c = []
                    , u = this._get_link_target(o)
                    , h = this._get_link_source(o);
                if (!h || !u || t.isSummaryTask(u) && t.isChildOf(h.id, u.id) || t.isSummaryTask(h) && t.isChildOf(u.id, h.id))
                    return c;
                var _ = t.config.schedule_from_end && t.config.project_end
                    , f = t.config.auto_scheduling_move_projects;
                !t.config.auto_scheduling_compatibility && t.config.auto_scheduling_strict && (f = !1),
                    l = l || this.isSummaryTask(h) && !s(h) ? this.getSubtaskDates(h.id) : {
                        start_date: h.start_date,
                        end_date: h.end_date
                    };
                var y = this._getImplicitLinks(o, h, function(S) {
                    return f && _ ? S.$source.length || t.getState("tasksDnd").drag_id == S.id ? 0 : t.calculateDuration({
                        start_date: S.end_date,
                        end_date: l.end_date,
                        task: h
                    }) : 0
                }, !0);
                d || (d = {
                    start_date: u.start_date,
                    end_date: u.end_date
                },
                this.isSummaryTask(u) && !s(u) && ((d = this.getSubtaskDates(u.id)).start_date = d.end_date,
                    this.eachTask(function(S) {
                        S.type !== this.config.types.project && !S.$target.length && S.start_date < d.start_date && (d.start_date = S.start_date)
                    }, u.id)));
                for (var v = this._getImplicitLinks(o, u, function(S) {
                    return !f || _ || S.$target.length || t.getState("tasksDnd").drag_id == S.id ? 0 : t.calculateDuration({
                        start_date: d.start_date,
                        end_date: S.start_date,
                        task: u
                    })
                }), b = 0, g = y.length; b < g; b++)
                    for (var m = y[b], p = 0, k = v.length; p < k; p++) {
                        var w = v[p]
                            , x = 1 * m.lag + 1 * w.lag
                            , $ = {
                            id: o.id,
                            type: o.type,
                            source: m.task,
                            target: w.task,
                            subtaskLink: m.subtaskLink,
                            lag: (1 * o.lag || 0) + x
                        };
                        t._linkedTasks[$.target] = t._linkedTasks[$.target] || {},
                            t._linkedTasks[$.target][$.source] = !0,
                            c.push(t._convertToFinishToStartLink(w.task, $, h, u, m.taskParent, w.taskParent))
                    }
                return n && (e[o.id] = c),
                    c
            }
            ,
            t._isAutoSchedulable = function(o) {
                if (!(o.auto_scheduling !== !1 && o.unscheduled !== !0))
                    return !1;
                if (this.isSummaryTask(o)) {
                    let l = !0;
                    if (this.eachTask(function(d) {
                        l && t._isAutoSchedulable(d) && (l = !1)
                    }, o.id),
                        l)
                        return !1
                }
                return !0
            }
            ,
            t._getImplicitLinks = function(o, l, d, c) {
                var u = [];
                if (this.isSummaryTask(l) && !s(l)) {
                    var h, _ = {};
                    for (var f in this.eachTask(function(k) {
                        this.isSummaryTask(k) && !s(k) || (_[k.id] = k)
                    }, l.id),
                        _) {
                        var y = _[f];
                        if (t._isAutoSchedulable(y)) {
                            var v = c ? y.$source : y.$target;
                            h = !1;
                            for (var b = 0; b < v.length && o.type != t.config.links.start_to_start && o.type != t.config.links.start_to_finish; b++) {
                                var g = t.getLink(v[b])
                                    , m = c ? g.target : g.source
                                    , p = _[m];
                                if (p && t._isAutoSchedulable(y) && t._isAutoSchedulable(p)) {
                                    let k = 0;
                                    if (g.lag && (k = Math.abs(g.lag)),
                                    g.type != t.config.links.finish_to_start) {
                                        k += t._convertToFinishToStartLink(null, {}, y, p).additionalLag;
                                        continue
                                    }
                                    const w = g.target == p.id && k && k <= p.duration
                                        , x = g.target == y.id && k && k <= y.duration;
                                    if (w || x) {
                                        h = !0;
                                        break
                                    }
                                }
                            }
                            if (!h) {
                                let k = !0;
                                for (const x in t._linkedTasks[y.id])
                                    if (t.isChildOf(x, o.target)) {
                                        k = !1;
                                        break
                                    }
                                let w = 0;
                                k && (w = d(y)),
                                    u.push({
                                        task: y.id,
                                        taskParent: y.parent,
                                        lag: w,
                                        subtaskLink: !0
                                    })
                            }
                        }
                    }
                } else
                    u.push({
                        task: l.id,
                        taskParent: l.parent,
                        lag: 0
                    });
                return u
            }
            ,
            t._getDirectDependencies = function(o, l) {
                t._linkedTasks = t._linkedTasks || {};
                for (var d = [], c = [], u = l ? o.$source : o.$target, h = 0; h < u.length; h++) {
                    var _ = this.getLink(u[h]);
                    if (this.isTaskExists(_.source) && this.isTaskExists(_.target)) {
                        var f = this.getTask(_.target);
                        if (!this._isAutoSchedulable(f) || !this._isAutoSchedulable(o))
                            continue;
                        if (t.config.auto_scheduling_use_progress) {
                            if (f.progress == 1)
                                continue;
                            d.push(_)
                        } else
                            d.push(_)
                    }
                }
                for (h = 0; h < d.length; h++)
                    c = c.concat(this._formatLink(d[h]));
                return c
            }
            ,
            t._getInheritedDependencies = function(o, l) {
                var d, c = !1, u = [];
                return this.isTaskExists(o.id) && this.eachParent(function(h) {
                    var _;
                    c || (n && (d = l ? i : a)[h.id] ? u = u.concat(d[h.id]) : this.isSummaryTask(h) && (this._isAutoSchedulable(h) ? (_ = this._getDirectDependencies(h, l),
                    n && (d[h.id] = _),
                        u = u.concat(_)) : c = !0))
                }, o.id, this),
                    u
            }
            ,
            t._getDirectSuccessors = function(o) {
                return this._getDirectDependencies(o, !0)
            }
            ,
            t._getInheritedSuccessors = function(o) {
                return this._getInheritedDependencies(o, !0)
            }
            ,
            t._getDirectPredecessors = function(o) {
                return this._getDirectDependencies(o, !1)
            }
            ,
            t._getInheritedPredecessors = function(o) {
                return this._getInheritedDependencies(o, !1)
            }
            ,
            t._getSuccessors = function(o, l) {
                var d = this._getDirectSuccessors(o);
                return l ? d : d.concat(this._getInheritedSuccessors(o))
            }
            ,
            t._getPredecessors = function(o, l) {
                var d, c = String(o.id) + "-" + String(l);
                if (n && r[c])
                    return r[c];
                var u = this._getDirectPredecessors(o);
                return d = l ? u : u.concat(this._getInheritedPredecessors(o)),
                n && (r[c] = d),
                    d
            }
            ,
            t._convertToFinishToStartLink = function(o, l, d, c, u, h) {
                var _ = {
                    target: o,
                    link: t.config.links.finish_to_start,
                    id: l.id,
                    lag: l.lag || 0,
                    sourceLag: 0,
                    targetLag: 0,
                    trueLag: l.lag || 0,
                    source: l.source,
                    preferredStart: null,
                    sourceParent: u,
                    targetParent: h,
                    hashSum: null,
                    subtaskLink: l.subtaskLink
                }
                    , f = 0;
                switch (String(l.type)) {
                    case String(t.config.links.start_to_start):
                        f = -d.duration,
                            _.sourceLag = f;
                        break;
                    case String(t.config.links.finish_to_finish):
                        f = -c.duration,
                            _.targetLag = f;
                        break;
                    case String(t.config.links.start_to_finish):
                        f = -d.duration - c.duration,
                            _.sourceLag = -d.duration,
                            _.targetLag = -c.duration;
                        break;
                    default:
                        f = 0
                }
                return _.lag += f,
                    _.hashSum = _.lag + "_" + _.link + "_" + _.source + "_" + _.target,
                    _
            }
    }
    var en = {
        second: 1,
        minute: 60,
        hour: 3600,
        day: 86400,
        week: 604800,
        month: 2592e3,
        quarter: 7776e3,
        year: 31536e3
    };
    function Jt(t) {
        return en[t] || en.hour
    }
    function st(t, n) {
        if (t.forEach)
            t.forEach(n);
        else
            for (var e = t.slice(), i = 0; i < e.length; i++)
                n(e[i], i)
    }
    function fe(t, n) {
        if (t.find)
            return t.find(n);
        for (var e = 0; e < t.length; e++)
            if (n(t[e], e))
                return t[e]
    }
    function Kt(t, n) {
        if (t.includes)
            return t.includes(n);
        for (var e = 0; e < t.length; e++)
            if (t[e] === n)
                return !0;
        return !1
    }
    function Lt(t) {
        return Array.isArray ? Array.isArray(t) : t && t.length !== void 0 && t.pop && t.push
    }
    function nt(t) {
        return !(!t || typeof t != "object") && !!(t.getFullYear && t.getMonth && t.getDate)
    }
    function Tt(t) {
        return nt(t) && !isNaN(t.getTime())
    }
    function Xt(t, n) {
        var e, i = function() {
            i.$cancelTimeout(),
                i.$pending = !0;
            var a = Array.prototype.slice.call(arguments);
            e = setTimeout(function() {
                t.apply(this, a),
                    i.$pending = !1
            }, n)
        };
        return i.$pending = !1,
            i.$cancelTimeout = function() {
                clearTimeout(e),
                    i.$pending = !1
            }
            ,
            i.$execute = function() {
                var a = Array.prototype.slice.call(arguments);
                t.apply(this, a),
                    i.$cancelTimeout()
            }
            ,
            i
    }
    function ot(t, n) {
        return nn(t) && !nn(n) && (t = "0"),
            t
    }
    function nn(t) {
        return t === 0
    }
    function Bt(t, n) {
        for (var e, i, a, r = 0, s = t.length - 1; r <= s; )
            if (i = +t[e = Math.floor((r + s) / 2)],
                a = +t[e - 1],
            i < n)
                r = e + 1;
            else {
                if (!(i > n)) {
                    for (; +t[e] == +t[e + 1]; )
                        e++;
                    return e
                }
                if (!isNaN(a) && a < n)
                    return e - 1;
                s = e - 1
            }
        return t.length - 1
    }
    function an() {
        return {
            getVertices: function(t) {
                for (var n, e = {}, i = 0, a = t.length; i < a; i++)
                    e[(n = t[i]).target] = n.target,
                        e[n.source] = n.source;
                var r, s = [];
                for (var i in e)
                    r = e[i],
                        s.push(r);
                return s
            },
            topologicalSort: function(t) {
                for (var n = this.getVertices(t), e = {}, i = 0, a = n.length; i < a; i++)
                    e[n[i]] = {
                        id: n[i],
                        $source: [],
                        $target: [],
                        $incoming: 0
                    };
                for (i = 0,
                         a = t.length; i < a; i++) {
                    var r = e[t[i].target];
                    r.$target.push(i),
                        r.$incoming = r.$target.length,
                        e[t[i].source].$source.push(i)
                }
                for (var s = n.filter(function(u) {
                    return !e[u].$incoming
                }), o = []; s.length; ) {
                    var l = s.pop();
                    o.push(l);
                    var d = e[l];
                    for (i = 0; i < d.$source.length; i++) {
                        var c = e[t[d.$source[i]].target];
                        c.$incoming--,
                        c.$incoming || s.push(c.id)
                    }
                }
                return o
            },
            groupAdjacentEdges: function(t) {
                for (var n, e = {}, i = 0, a = t.length; i < a; i++)
                    e[(n = t[i]).source] || (e[n.source] = []),
                        e[n.source].push(n);
                return e
            },
            tarjanStronglyConnectedComponents: function(t, n) {
                for (var e = {}, i = [], a = this.groupAdjacentEdges(n), r = !1, s = [], o = 0; o < t.length; o++) {
                    var l = y(t[o]);
                    if (!l.visited)
                        for (var d = [l], c = 0; d.length; ) {
                            var u = d.pop();
                            u.visited || (u.index = c,
                                u.lowLink = c,
                                c++,
                                i.push(u),
                                u.onStack = !0,
                                u.visited = !0),
                                r = !1,
                                n = a[u.id] || [];
                            for (var h = 0; h < n.length; h++) {
                                var _ = y(n[h].target);
                                if (_.edge = n[h],
                                _.index === void 0) {
                                    d.push(u),
                                        d.push(_),
                                        r = !0;
                                    break
                                }
                                _.onStack && (u.lowLink = Math.min(u.lowLink, _.index))
                            }
                            if (!r) {
                                if (u.index == u.lowLink) {
                                    for (var f = {
                                        tasks: [],
                                        links: [],
                                        linkKeys: []
                                    }; (_ = i.pop()).onStack = !1,
                                             f.tasks.push(_.id),
                                         _.edge && (f.links.push(_.edge.id),
                                             f.linkKeys.push(_.edge.hashSum)),
                                         _ != u; )
                                        ;
                                    s.push(f)
                                }
                                d.length && (_ = u,
                                    (u = d[d.length - 1]).lowLink = Math.min(u.lowLink, _.lowLink))
                            }
                        }
                }
                return s;
                function y(v) {
                    return e[v] || (e[v] = {
                        id: v,
                        onStack: !1,
                        index: void 0,
                        lowLink: void 0,
                        edge: void 0
                    }),
                        e[v]
                }
            },
            findLoops: function(t) {
                var n = [];
                st(t, function(i) {
                    i.target == i.source && n.push({
                        tasks: [i.source],
                        links: [i.id]
                    })
                });
                var e = this.getVertices(t);
                return st(this.tarjanStronglyConnectedComponents(e, t), function(i) {
                    i.tasks.length > 1 && n.push(i)
                }),
                    n
            }
        }
    }
    function rn(t) {
        return {
            getVirtualRoot: function() {
                return t.mixin(t.getSubtaskDates(), {
                    id: t.config.root_id,
                    type: t.config.types.project,
                    $source: [],
                    $target: [],
                    $virtual: !0
                })
            },
            getLinkedTasks: function(n, e) {
                var i = [n]
                    , a = !1;
                t._isLinksCacheEnabled() || (t._startLinksCache(),
                    a = !0);
                for (var r = [], s = {}, o = {}, l = 0; l < i.length; l++)
                    this._getLinkedTasks(i[l], s, e, o);
                for (var l in o)
                    r.push(o[l]);
                return a && t._endLinksCache(),
                    r
            },
            _collectRelations: function(n, e, i, a) {
                var r, s = t._getSuccessors(n, e), o = [];
                i && (o = t._getPredecessors(n, e));
                for (var l = [], d = 0; d < s.length; d++)
                    a[r = s[d].hashSum] || (a[r] = !0,
                        l.push(s[d]));
                for (d = 0; d < o.length; d++)
                    a[r = o[d].hashSum] || (a[r] = !0,
                        l.push(o[d]));
                return l
            },
            _getLinkedTasks: function(n, e, i, a) {
                for (var r, s = n === void 0 ? t.config.root_id : n, o = (e = {},
                    {}), l = [{
                    from: s,
                    includePredecessors: i,
                    isChild: !1
                }]; l.length; ) {
                    var d = l.pop()
                        , c = d.isChild;
                    if (!e[s = d.from]) {
                        r = t.isTaskExists(s) ? t.getTask(s) : this.getVirtualRoot(),
                            e[s] = !0;
                        for (var u = this._collectRelations(r, c, i, o), h = 0; h < u.length; h++) {
                            var _ = u[h];
                            let v = !0;
                            t.config.auto_scheduling_use_progress && t.getTask(_.target).progress == 1 && (v = !1);
                            const b = t.getTask(_.target)
                                , g = t.getTask(_.source);
                            (b.unscheduled || g.unscheduled) && (v = !1),
                            v && (a[_.hashSum] = _);
                            var f = _.sourceParent == _.targetParent;
                            e[_.target] || l.push({
                                from: _.target,
                                includePredecessors: !0,
                                isChild: f
                            })
                        }
                        if (t.hasChild(r.id)) {
                            var y = t.getChildren(r.id);
                            for (h = 0; h < y.length; h++)
                                e[y[h]] || l.push({
                                    from: y[h],
                                    includePredecessors: !0,
                                    isChild: !0
                                })
                        }
                    }
                }
                return a
            }
        }
    }
    var Zt, V = (t => (t.ASAP = "asap",
        t.ALAP = "alap",
        t.SNET = "snet",
        t.SNLT = "snlt",
        t.FNET = "fnet",
        t.FNLT = "fnlt",
        t.MSO = "mso",
        t.MFO = "mfo",
        t))(V || {});
    class Nt {
        static Create(n) {
            const e = new Nt;
            if (n)
                for (const i in e)
                    n[i] !== void 0 && (e[i] = n[i]);
            return e
        }
        constructor() {
            this.link = null,
                this.task = null,
                this.start_date = null,
                this.end_date = null,
                this.latestStart = null,
                this.earliestStart = null,
                this.earliestEnd = null,
                this.latestEnd = null,
                this.latestSchedulingStart = null,
                this.earliestSchedulingStart = null,
                this.latestSchedulingEnd = null,
                this.earliestSchedulingEnd = null,
                this.kind = "asap",
                this.conflict = !1
        }
    }
    class pe {
        constructor(n) {
            this.isAsapTask = e => {
                const i = this.getConstraintType(e);
                return this._gantt.config.schedule_from_end ? i === V.ASAP : i !== V.ALAP
            }
                ,
                this.isAlapTask = e => !this.isAsapTask(e),
                this.getConstraintType = e => {
                    if (!this._gantt._isAutoSchedulable(e))
                        return;
                    const i = this._getTaskConstraint(e);
                    return i.constraint_type ? i.constraint_type : this._gantt.config.schedule_from_end ? V.ALAP : V.ASAP
                }
                ,
                this._getTaskConstraint = e => {
                    let i = this._getOwnConstraint(e);
                    if (this._gantt.config.auto_scheduling_project_constraint && !this._gantt.getState().group_mode) {
                        let a = V.ASAP;
                        this._gantt.config.schedule_from_end && (a = V.ALAP),
                        (i && i.constraint_type) !== a && i || (i = this._getParentConstraint(e))
                    }
                    return i
                }
                ,
                this._getOwnConstraint = e => ({
                    constraint_type: e.constraint_type,
                    constraint_date: e.constraint_date
                }),
                this._getParentConstraint = e => {
                    let i = V.ASAP;
                    this._gantt.config.schedule_from_end && (i = V.ALAP);
                    let a = {
                        constraint_type: i,
                        constraint_date: null
                    };
                    return this._gantt.eachParent(r => {
                            a.constraint_type === i && r.constraint_type && r.constraint_type !== i && (a = {
                                constraint_type: r.constraint_type,
                                constraint_date: r.constraint_date
                            })
                        }
                        , e.id),
                        a
                }
                ,
                this.hasConstraint = e => !!this.getConstraintType(e),
                this.processConstraint = (e, i) => {
                    const a = this._getTaskConstraint(e);
                    if (a && !(a.constraint_type === V.ALAP || a.constraint_type === V.ASAP)) {
                        if (Tt(a.constraint_date)) {
                            const r = a.constraint_date
                                , s = Nt.Create(i);
                            switch (s.task = e.id,
                                a.constraint_type) {
                                case V.SNET:
                                    s.earliestStart = new Date(r),
                                        s.earliestEnd = this._gantt.calculateEndDate({
                                            start_date: s.earliestStart,
                                            duration: e.duration,
                                            task: e
                                        }),
                                        s.link = null;
                                    break;
                                case V.SNLT:
                                    s.latestStart = new Date(r),
                                        s.latestEnd = this._gantt.calculateEndDate({
                                            start_date: s.latestStart,
                                            duration: e.duration,
                                            task: e
                                        }),
                                        s.link = null;
                                    break;
                                case V.FNET:
                                    s.earliestStart = this._gantt.calculateEndDate({
                                        start_date: r,
                                        duration: -e.duration,
                                        task: e
                                    }),
                                        s.earliestEnd = new Date(r),
                                        s.link = null;
                                    break;
                                case V.FNLT:
                                    s.latestStart = this._gantt.calculateEndDate({
                                        start_date: r,
                                        duration: -e.duration,
                                        task: e
                                    }),
                                        s.latestEnd = new Date(r),
                                        s.link = null;
                                    break;
                                case V.MSO:
                                    s.earliestStart = new Date(r),
                                        s.earliestEnd = this._gantt.calculateEndDate({
                                            start_date: s.earliestStart,
                                            duration: e.duration,
                                            task: e
                                        }),
                                        s.latestStart = s.earliestStart,
                                        s.latestEnd = s.earliestEnd,
                                        s.link = null;
                                    break;
                                case V.MFO:
                                    s.earliestStart = this._gantt.calculateEndDate({
                                        start_date: r,
                                        duration: -e.duration,
                                        task: e
                                    }),
                                        s.earliestEnd = this._gantt.calculateEndDate({
                                            start_date: s.earliestStart,
                                            duration: e.duration,
                                            task: e
                                        }),
                                        s.latestStart = s.earliestStart,
                                        s.latestEnd = s.earliestEnd,
                                        s.link = null
                            }
                            return s
                        }
                    }
                    return i
                }
                ,
                this.getConstraints = (e, i) => {
                    const a = []
                        , r = {}
                        , s = l => {
                            r[l.id] || this.hasConstraint(l) && !this._gantt.isSummaryTask(l) && (r[l.id] = l)
                        }
                    ;
                    if (this._gantt.isTaskExists(e)) {
                        const l = this._gantt.getTask(e);
                        s(l)
                    }
                    let o;
                    if (this._gantt.eachTask(l => s(l), e),
                        i)
                        for (let l = 0; l < i.length; l++) {
                            const d = i[l];
                            r[d.target] || (o = this._gantt.getTask(d.target),
                                s(o)),
                            r[d.source] || (o = this._gantt.getTask(d.source),
                                s(o))
                        }
                    for (const l in r)
                        r[l].type !== this._gantt.config.types.placeholder && a.push(r[l]);
                    return a
                }
                ,
                this._gantt = n
        }
        static Create(n) {
            return new pe(n)
        }
    }
    class sn {
        constructor(n) {
            this._gantt = n
        }
        isEqual(n, e, i) {
            return !this._gantt._hasDuration(n, e, i)
        }
        isFirstSmaller(n, e, i) {
            return n.valueOf() < e.valueOf() && !this.isEqual(n, e, i)
        }
        isSmallerOrDefault(n, e, i) {
            return !(n && !this.isFirstSmaller(n, e, i))
        }
        isGreaterOrDefault(n, e, i) {
            return !(n && !this.isFirstSmaller(e, n, i))
        }
    }
    class me {
        static Create(n) {
            const e = new me;
            return e._gantt = n,
                e._comparator = new sn(n),
                e
        }
        resolveRelationDate(n, e, i) {
            let a = null
                , r = null
                , s = null
                , o = null;
            const l = this._gantt.getTask(n)
                , d = e.successors;
            let c = null;
            const u = i[n];
            for (let _ = 0; _ < d.length; _++) {
                const f = d[_];
                o = f.preferredStart;
                const y = this.getLatestEndDate(f, i, l)
                    , v = this._gantt.calculateEndDate({
                    start_date: y,
                    duration: -l.duration,
                    task: l
                });
                this._comparator.isGreaterOrDefault(c, y, l) && (c = y),
                this._comparator.isGreaterOrDefault(o, v, l) && this._comparator.isGreaterOrDefault(a, y, l) && (a = y,
                    s = v,
                    r = f.id)
            }
            !d.length && this._gantt.config.project_end && (this._comparator.isGreaterOrDefault(this._gantt.config.project_end, l.end_date, l) && (a = this._gantt.config.project_end),
            this._gantt.callEvent("onBeforeTaskAutoSchedule", [l, l.end_date]) === !1 && (a = l.end_date)),
            a && (l.duration ? (a = this._gantt.getClosestWorkTime({
                date: a,
                dir: "future",
                task: l
            }),
                s = this._gantt.calculateEndDate({
                    start_date: a,
                    duration: -l.duration,
                    task: l
                })) : s = a = this._gantt.getClosestWorkTime({
                date: a,
                dir: "past",
                task: l
            }));
            const h = Nt.Create(u);
            return h.link = r,
                h.task = n,
                h.end_date = a,
                h.start_date = s,
                h.kind = "alap",
            c && (h.latestSchedulingStart = this._gantt.calculateEndDate({
                start_date: c,
                duration: -l.duration,
                task: l
            }),
                h.latestSchedulingEnd = c),
                h
        }
        getSuccessorStartDate(n, e) {
            const i = e[n]
                , a = this._gantt.getTask(n);
            let r;
            return r = i && (i.start_date || i.end_date) ? i.start_date ? i.start_date : this._gantt.calculateEndDate({
                start_date: i.end_date,
                duration: -a.duration,
                task: a
            }) : a.start_date,
                r
        }
        getLatestEndDate(n, e, i) {
            const a = this.getSuccessorStartDate(n.target, e)
                , r = i;
            let s = this._gantt.getClosestWorkTime({
                date: a,
                dir: "past",
                task: r
            });
            return s && n.lag && 1 * n.lag == 1 * n.lag && (s = this._gantt.calculateEndDate({
                start_date: s,
                duration: 1 * -n.lag,
                task: r
            })),
                s
        }
    }
    class ve {
        static Create(n) {
            const e = new ve;
            return e._gantt = n,
                e._comparator = new sn(n),
                e
        }
        resolveRelationDate(n, e, i) {
            let a = null
                , r = null
                , s = null;
            const o = this._gantt.getTask(n)
                , l = e.predecessors
                , d = {};
            let c = null;
            for (let f = 0; f < l.length; f++) {
                const y = l[f];
                s = y.preferredStart;
                const v = this.getEarliestStartDate(y, i, o);
                if (this._comparator.isSmallerOrDefault(c, v, o) && (c = v),
                this._comparator.isSmallerOrDefault(s, v, o) && this._comparator.isSmallerOrDefault(a, v, o) && (a = v,
                    r = y.id),
                    !o.duration) {
                    const b = this._gantt.getLink(y.id);
                    (d[b.type] === void 0 || d[b.type] < +v) && (d[b.type] = +v)
                }
            }
            !l.length && this._gantt.config.project_start && ((this._comparator.isSmallerOrDefault(o.start_date, this._gantt.config.project_start, o) || this._gantt.config.auto_scheduling_strict && this._comparator.isGreaterOrDefault(o.start_date, this._gantt.config.project_start, o)) && (a = this._gantt.config.project_start),
            this._gantt.callEvent("onBeforeTaskAutoSchedule", [o, o.start_date]) === !1 && (a = o.start_date));
            let u = null;
            if (a)
                if (o.duration)
                    a = this._gantt.getClosestWorkTime({
                        date: a,
                        dir: "future",
                        task: o
                    }),
                        u = this._gantt.calculateEndDate({
                            start_date: a,
                            duration: o.duration,
                            task: o
                        });
                else {
                    let f = "future";
                    const y = this._gantt.config.links;
                    if (d[y.finish_to_finish] !== void 0) {
                        const v = l.length === 1;
                        let b = !0;
                        for (const g in d)
                            if (g != y.finish_to_finish && d[y.finish_to_finish] < d[g]) {
                                b = !1;
                                break
                            }
                        (v || b) && (f = "past")
                    }
                    a = u = this._gantt.getClosestWorkTime({
                        date: a,
                        dir: f,
                        task: o
                    })
                }
            const h = i[n]
                , _ = Nt.Create(h);
            return _.link = r,
                _.task = n,
                _.start_date = a,
                _.end_date = u,
                _.kind = "asap",
            c && (_.earliestSchedulingStart = c,
                _.earliestSchedulingEnd = this._gantt.calculateEndDate({
                    start_date: c,
                    duration: o.duration,
                    task: o
                })),
                _
        }
        getPredecessorEndDate(n, e) {
            const i = e[n]
                , a = this._gantt.getTask(n);
            let r;
            return r = i && (i.start_date || i.end_date) ? i.end_date ? i.end_date : this._gantt.calculateEndDate({
                start_date: i.start_date,
                duration: a.duration,
                task: a
            }) : a.end_date,
                r
        }
        getEarliestStartDate(n, e, i) {
            const a = this.getPredecessorEndDate(n.source, e)
                , r = i
                , s = this._gantt.getTask(n.source);
            let o;
            if (a && n.lag && 1 * n.lag == 1 * n.lag) {
                let l = r;
                this._gantt.config.auto_scheduling_move_projects && n.subtaskLink && this._gantt.isTaskExists(n.targetParent) && (l = this._gantt.getTask(n.targetParent)),
                    o = this._gantt.getClosestWorkTime({
                        date: a,
                        dir: "future",
                        task: s
                    }),
                n.sourceLag && (o = this._gantt.calculateEndDate({
                    start_date: o,
                    duration: 1 * n.sourceLag,
                    task: s
                })),
                n.targetLag && (o = this._gantt.calculateEndDate({
                    start_date: o,
                    duration: 1 * n.targetLag,
                    task: l
                })),
                    o = this._gantt.calculateEndDate({
                        start_date: o,
                        duration: 1 * n.trueLag,
                        task: l
                    })
            } else {
                const l = this._gantt.getLink(n.id).type === this._gantt.config.links.finish_to_finish;
                o = !r.duration && l ? this._gantt.getClosestWorkTime({
                    date: a,
                    dir: "past",
                    task: r
                }) : this._gantt.getClosestWorkTime({
                    date: a,
                    dir: "future",
                    task: r
                })
            }
            return o
        }
    }
    class ai {
        constructor(n, e, i) {
            this._secondIteration = !1,
                this._gantt = n,
                this._constraintsHelper = i,
                this._graphHelper = e,
                this._asapStrategy = ve.Create(n),
                this._alapStrategy = me.Create(n),
                this._secondIterationRequired = !1
        }
        generatePlan(n, e) {
            const i = this._graphHelper
                , a = this._gantt
                , r = this._constraintsHelper
                , s = this._alapStrategy
                , o = this._asapStrategy
                , {orderedIds: l, reversedIds: d, relationsMap: c, plansHash: u} = this.buildWorkCollections(n, e, i);
            let h;
            return this.processConstraints(l, u, a, r),
                h = a.config.schedule_from_end ? this.iterateTasks(d, l, r.isAlapTask, s, o, c, u) : this.iterateTasks(l, d, r.isAsapTask, o, s, c, u),
                h
        }
        applyProjectPlan(n) {
            const e = this._gantt;
            let i, a, r, s;
            const o = [];
            for (let l = 0; l < n.length; l++) {
                if (r = null,
                    s = null,
                    i = n[l],
                    !e.isTaskExists(i.task))
                    continue;
                a = e.getTask(i.task),
                i.link && (r = e.getLink(i.link),
                    s = i.kind === "asap" ? this._gantt.getTask(r.source) : this._gantt.getTask(r.target));
                let d = null;
                i.start_date && a.start_date.valueOf() !== i.start_date.valueOf() && (d = i.start_date),
                d && (a.start_date = d,
                    a.end_date = e.calculateEndDate(a),
                    o.push(a.id),
                    e.callEvent("onAfterTaskAutoSchedule", [a, d, r, s]))
            }
            return o
        }
        iterateTasks(n, e, i, a, r, s, o) {
            const l = this._gantt
                , d = [];
            for (let c = 0; c < n.length; c++) {
                const u = n[c]
                    , h = l.getTask(u);
                if (!l._isAutoSchedulable(h))
                    continue;
                const _ = a.resolveRelationDate(u, s[u], o);
                this.limitPlanDates(h, _),
                    i(h) ? this.processResolvedDate(h, _, d, o) : o[h.id] = _
            }
            for (let c = 0; c < e.length; c++) {
                const u = e[c]
                    , h = l.getTask(u);
                if (l._isAutoSchedulable(h) && !i(h)) {
                    const _ = r.resolveRelationDate(u, s[u], o);
                    this.limitPlanDates(h, _),
                        this.processResolvedDate(h, _, d, o)
                }
            }
            if (this._secondIterationRequired) {
                if (this._secondIteration)
                    this._secondIteration = !1;
                else if (this._secondIteration = !0,
                    this.summaryLagChanged(l, s, o))
                    return this.iterateTasks(n, e, i, a, r, s, o)
            }
            return d
        }
        summaryLagChanged(n, e, i) {
            const a = {}
                , r = {};
            for (const o in e)
                e[o].predecessors.forEach(l => {
                        if (l.subtaskLink) {
                            const d = n.getLink(l.id);
                            this.getProjectUpdates(n, i, l, d, "source", a, r),
                                this.getProjectUpdates(n, i, l, d, "target", a, r)
                        }
                    }
                );
            let s = !1;
            for (const o in a) {
                const l = a[o];
                if (!l.min || !l.max)
                    continue;
                const d = n.getTask(o)
                    , c = n.calculateDuration({
                    start_date: d.start_date,
                    end_date: d.end_date,
                    task: d
                })
                    , u = n.calculateDuration({
                    start_date: l.min,
                    end_date: l.max,
                    task: d
                });
                u !== c && (d.start_date = l.min,
                    d.end_date = l.max,
                    d.duration = u)
            }
            for (const o in r) {
                const l = r[o];
                let d, c;
                const u = a[l.source]
                    , h = a[l.target];
                u && (d = {
                    start_date: u.start_date,
                    end_date: u.end_date
                }),
                h && (d = {
                    start_date: h.start_date,
                    end_date: h.end_date
                }),
                    n._formatLink(l, d, c).forEach(function(_) {
                        for (const f in e)
                            e[f].predecessors.forEach(function(y) {
                                const v = y.id === _.id
                                    , b = y.target === _.target
                                    , g = y.source === _.source;
                                v && b && g && (y.lag = _.lag,
                                    y.sourceLag = _.sourceLag,
                                    y.targetLag = _.targetLag,
                                    y.hashSum = _.hashSum)
                            })
                    }),
                    s = !0
            }
            return s
        }
        getProjectUpdates(n, e, i, a, r, s, o) {
            if (n.getTask(a[r]).type === n.config.types.project) {
                s[a[r]] = s[a[r]] || {
                    id: a[r],
                    link: a
                };
                const l = s[a[r]];
                let d = e[i[r]];
                d && (r != "source" || d.start_date && d.end_date || (d = n.getTask(d.task)),
                    l.min = l.min || d.start_date,
                l.min > d.start_date && (l.min = d.start_date),
                    l.max = l.max || d.end_date,
                l.max < d.end_date && (l.max = d.end_date),
                    o[a.id] = a)
            }
        }
        processResolvedDate(n, e, i, a) {
            if (e.start_date && this._gantt.isLinkExists(e.link)) {
                let r = null
                    , s = null;
                if (e.link && (r = this._gantt.getLink(e.link),
                    s = e.kind === "asap" ? this._gantt.getTask(r.source) : this._gantt.getTask(r.target)),
                n.start_date.valueOf() !== e.start_date.valueOf() && this._gantt.callEvent("onBeforeTaskAutoSchedule", [n, e.start_date, r, s]) === !1)
                    return
            }
            a[n.id] = e,
            e.start_date && i.push(e)
        }
        limitPlanDates(n, e) {
            const i = e.start_date || n.start_date;
            return e.earliestStart && i < e.earliestStart && (e.start_date = e.earliestStart,
                e.end_date = e.earliestEnd),
            e.latestStart && i > e.latestStart && (e.start_date = e.latestStart,
                e.end_date = e.latestEnd),
            e.latestSchedulingStart && i > e.latestSchedulingStart && (e.start_date = e.latestSchedulingStart,
                e.end_date = e.latestSchedulingEnd),
            e.earliestSchedulingStart && i < e.earliestSchedulingStart && (e.start_date = e.earliestSchedulingStart,
                e.end_date = e.earliestSchedulingEnd),
            e.start_date && (e.start_date > e.latestSchedulingStart || e.start_date < e.earliestSchedulingStart || e.start_date > e.latestStart || e.start_date < e.earliestStart || e.end_date > e.latestSchedulingEnd || e.end_date < e.earliestSchedulingEnd || e.end_date > e.latestEnd || e.end_date < e.earliestEnd) && (e.conflict = !0),
                e
        }
        buildWorkCollections(n, e, i) {
            const a = this._gantt
                , r = i.topologicalSort(n)
                , s = r.slice().reverse()
                , o = {}
                , l = {};
            for (let d = 0, c = r.length; d < c; d++) {
                const u = r[d]
                    , h = a.getTask(u);
                a._isAutoSchedulable(h) && (l[u] = {
                    successors: [],
                    predecessors: []
                },
                    o[u] = null)
            }
            for (let d = 0, c = e.length; d < c; d++) {
                const u = e[d];
                o[u.id] === void 0 && (s.unshift(u.id),
                    r.unshift(u.id),
                    o[u.id] = null,
                    l[u.id] = {
                        successors: [],
                        predecessors: []
                    })
            }
            for (let d = 0, c = n.length; d < c; d++) {
                const u = n[d];
                l[u.source] && l[u.source].successors.push(u),
                l[u.target] && l[u.target].predecessors.push(u)
            }
            return {
                orderedIds: r,
                reversedIds: s,
                relationsMap: l,
                plansHash: o
            }
        }
        processConstraints(n, e, i, a) {
            for (let r = 0; r < n.length; r++) {
                const s = n[r]
                    , o = i.getTask(s)
                    , l = a.getConstraintType(o);
                if (l && l !== V.ASAP && l !== V.ALAP) {
                    const d = a.processConstraint(o, Nt.Create());
                    e[o.id] = d
                }
            }
        }
    }
    function ke(t, n, e) {
        const i = [t]
            , a = []
            , r = {}
            , s = {};
        let o;
        for (; i.length > 0; )
            if (o = i.shift(),
                !e[o]) {
                e[o] = !0,
                    a.push(o);
                for (let c = 0; c < n.length; c++) {
                    const u = n[c];
                    u.source == o || u.sourceParent == o ? (e[u.target] || (i.push(u.target),
                        s[u.id] = !0,
                        n.splice(c, 1),
                        c--),
                        r[u.hashSum] = u) : u.target != o && u.targetParent != o || (e[u.source] || (i.push(u.source),
                        s[u.id] = !0,
                        n.splice(c, 1),
                        c--),
                        r[u.hashSum] = u)
                }
            }
        const l = [];
        let d = [];
        for (const c in s)
            l.push(c);
        for (const c in r)
            d.push(r[c]);
        return d.length || (d = n),
            {
                tasks: a,
                links: l,
                processedLinks: d
            }
    }
    class ri {
        constructor(n, e) {
            this.getConnectedGroupRelations = i => ke(i, this._linksBuilder.getLinkedTasks(), {}).processedLinks,
                this.getConnectedGroup = i => {
                    const a = this._linksBuilder.getLinkedTasks();
                    if (i !== void 0) {
                        if (this._gantt.getTask(i).type === this._gantt.config.types.project)
                            return {
                                tasks: [],
                                links: []
                            };
                        const r = ke(i, a, {});
                        return {
                            tasks: r.tasks,
                            links: r.links
                        }
                    }
                    return function(r) {
                        const s = {}
                            , o = [];
                        let l, d, c;
                        for (let u = 0; u < r.length; u++)
                            if (l = r[u].source,
                                d = r[u].target,
                                c = null,
                                s[l] ? s[d] || (c = d) : c = l,
                                c) {
                                const h = r.length;
                                o.push(ke(c, r, s)),
                                h !== r.length && (u = -1)
                            }
                        return o
                    }(a).map(r => ({
                        tasks: r.tasks,
                        links: r.links
                    }))
                }
                ,
                this._linksBuilder = e,
                this._gantt = n
        }
    }
    class si {
        constructor(n, e, i) {
            this.isCircularLink = a => !!this.getLoopContainingLink(a),
                this.getLoopContainingLink = a => {
                    const r = this._graphHelper
                        , s = this._linksBuilder
                        , o = this._gantt;
                    let l = s.getLinkedTasks();
                    o.isLinkExists(a.id) || (l = l.concat(o._formatLink(a)));
                    const d = r.findLoops(l);
                    for (let c = 0; c < d.length; c++) {
                        const u = d[c].links;
                        for (let h = 0; h < u.length; h++)
                            if (u[h] == a.id)
                                return d[c]
                    }
                    return null
                }
                ,
                this.findCycles = () => {
                    const a = this._graphHelper
                        , r = this._linksBuilder.getLinkedTasks();
                    return a.findLoops(r)
                }
                ,
                this._linksBuilder = i,
                this._graphHelper = e,
                this._gantt = n
        }
    }
    function oi(t, n, e, i) {
        const a = function() {
            let r, s, o = !1;
            function l(x, $) {
                t.config.auto_scheduling && !t._autoscheduling_in_progress && (t.getState().batch_update ? o = !0 : t.autoSchedule($.source))
            }
            function d(x, $) {
                const S = t.config.auto_scheduling_use_progress;
                return t.config.auto_scheduling_use_progress = !1,
                    t.isCircularLink($) ? (t.callEvent("onCircularLinkError", [$, e.getLoopContainingLink($)]),
                        t.config.auto_scheduling_use_progress = S,
                        !1) : (t.config.auto_scheduling_use_progress = S,
                        !0)
            }
            function c(x, $) {
                const S = t.getTask($.source)
                    , T = t.getTask($.target);
                return !(!t.config.auto_scheduling_descendant_links && (t.isChildOf(S.id, T.id) && t.isSummaryTask(T) || t.isChildOf(T.id, S.id) && t.isSummaryTask(S)))
            }
            function u(x, $, S, T) {
                return !!x != !!$ || !(!x && !$) && (x.valueOf() > $.valueOf() ? t._hasDuration({
                    start_date: $,
                    end_date: x,
                    task: T
                }) : t._hasDuration({
                    start_date: x,
                    end_date: $,
                    task: S
                }))
            }
            function h(x, $) {
                return !!u(x.start_date, $.start_date, x, $) || t.getConstraintType(x) !== t.getConstraintType($) || !!u(x.constraint_date, $.constraint_date, x, $) || !(!u(x.start_date, $.start_date, x, $) && (!u(x.end_date, $.end_date, x, $) && x.duration === $.duration || x.type === t.config.types.milestone)) || void 0
            }
            function _(x) {
                return t.config.auto_scheduling_compatibility ? n.getLinkedTasks(x, !0) : i.getConnectedGroupRelations(x)
            }
            function f(x, $) {
                let S = !1;
                for (let T = 0; T < r.length; T++) {
                    const E = t.getLink($[T].id);
                    !E || E.type !== t.config.links.start_to_start && E.type !== t.config.links.start_to_finish || ($.splice(T, 1),
                        T--,
                        S = !0)
                }
                if (S) {
                    const T = {};
                    for (let C = 0; C < $.length; C++)
                        T[$[C].id] = !0;
                    const E = _(x);
                    for (let C = 0; C < E.length; C++)
                        T[E[C].id] || $.push(E[C])
                }
            }
            function y(x, $) {
                if (t.config.schedule_from_end) {
                    if ($.end_date && x.end_date && x.end_date.valueOf() === $.end_date.valueOf())
                        return !0
                } else if ($.start_date && x.start_date && x.start_date.valueOf() === $.start_date.valueOf())
                    return !0
            }
            function v(x) {
                if (x.auto_scheduling === !1)
                    return;
                const $ = t.config.constraint_types
                    , S = [$.SNLT, $.FNLT, $.MSO, $.MFO]
                    , T = [$.SNET, $.FNET, $.MSO, $.MFO];
                t.config.schedule_from_end ? S.indexOf(x.constraint_type) > -1 ? x.constraint_type == $.SNLT || x.constraint_type == $.MSO ? x.constraint_date = new Date(x.start_date) : x.constraint_date = new Date(x.end_date) : (x.constraint_type = $.FNLT,
                    x.constraint_date = new Date(x.end_date)) : T.indexOf(x.constraint_type) > -1 ? x.constraint_type == $.SNET || x.constraint_type == $.MSO ? x.constraint_date = new Date(x.start_date) : x.constraint_date = new Date(x.end_date) : (x.constraint_type = $.SNET,
                    x.constraint_date = new Date(x.start_date))
            }
            function b(x) {
                t.config.auto_scheduling_compatibility && (x.constraint_type !== t.config.constraint_types.SNET && x.constraint_type !== t.config.constraint_types.FNLT || (x.constraint_type = null,
                    x.constraint_date = null))
            }
            t.attachEvent("onAfterBatchUpdate", function() {
                o && t.autoSchedule(),
                    o = !1
            }),
                t.attachEvent("onAfterLinkUpdate", l),
                t.attachEvent("onAfterLinkAdd", l),
                t.attachEvent("onAfterLinkDelete", function(x, $) {
                    if (t.config.auto_scheduling && !t._autoscheduling_in_progress && t.isTaskExists($.target)) {
                        const S = t.getTask($.target)
                            , T = t._getPredecessors(S);
                        T.length && (t.getState().batch_update ? o = !0 : t.autoSchedule(T[0].source, !1))
                    }
                }),
                t.attachEvent("onParse", function() {
                    t.config.auto_scheduling && t.config.auto_scheduling_initial && t.autoSchedule()
                }),
                t.attachEvent("onBeforeLinkAdd", d),
                t.attachEvent("onBeforeLinkAdd", c),
                t.attachEvent("onBeforeLinkUpdate", d),
                t.attachEvent("onBeforeLinkUpdate", c),
                t.attachEvent("onBeforeTaskDrag", function(x, $, S) {
                    return t.config.auto_scheduling && (t.getState().drag_mode !== "progress" && (r = _(x)),
                        s = x),
                        !0
                });
            const g = function(x, $) {
                const S = t.getTask(x);
                y(S, $) || v(S)
            };
            let m, p = null;
            if (t.ext && t.ext.inlineEditors) {
                const x = t.ext.inlineEditors
                    , $ = {
                    start_date: !0,
                    end_date: !0,
                    duration: !0,
                    constraint_type: !0,
                    constraint_date: !0
                };
                x.attachEvent("onBeforeSave", function(S) {
                    if ($[S.columnName]) {
                        p = S.id,
                        S.columnName === "constraint_type" && (m = !0);
                        const T = S.columnName === "duration"
                            , E = t.config.schedule_from_end && S.columnName === "start_date"
                            , C = !t.config.schedule_from_end && S.columnName === "end_date"
                            , D = t.config.inline_editors_date_processing !== "keepDuration" && (E || C)
                            , A = S.columnName === "constraint_date";
                        (T || D || A) && (t.getTask(S.id).$keep_constraints = !0)
                    }
                    return !0
                })
            }
            const k = {};
            let w;
            t.attachEvent("onBeforeTaskChanged", function(x, $, S) {
                return g(x, S),
                    k[x] = S,
                    !0
            }),
                t.attachEvent("onAfterTaskDrag", function(x, $, S) {
                    x === s && (clearTimeout(w),
                        w = setTimeout(function() {
                            (function(T, E) {
                                    if (t.config.auto_scheduling && !t._autoscheduling_in_progress) {
                                        const C = t.getTask(T)
                                            , D = t.config.auto_scheduling_use_progress && E.progress === 1 != (C.progress === 1);
                                        if (h(E, C)) {
                                            if (g(T, E),
                                            t.config.auto_scheduling_move_projects && s == T) {
                                                let A = !0;
                                                t.calculateDuration(E) !== t.calculateDuration(C) && (f(T, r),
                                                    A = !1),
                                                    D ? t.autoSchedule() : (A && f(T, r),
                                                        t._autoSchedule(T, r))
                                            } else
                                                t.autoSchedule(C.id);
                                            b(C)
                                        }
                                    }
                                    r = null,
                                        s = null
                                }
                            )(x, k[x])
                        }))
                }),
            t.ext.inlineEditors && t.ext.inlineEditors.attachEvent("onBeforeSave", function(x) {
                if (t.config.auto_scheduling && !t._autoscheduling_in_progress) {
                    const $ = t.ext.inlineEditors.getEditorConfig(x.columnName);
                    $.map_to !== "start_date" && $.map_to !== "end_date" && $.map_to !== "duration" || (p = x.id)
                }
                return !0
            }),
                t.attachEvent("onLightboxSave", function(x, $) {
                    if (t.config.auto_scheduling && !t._autoscheduling_in_progress) {
                        m = !1;
                        const S = t.getTask(x);
                        h($, S) && (p = x,
                        y($, S) && ($.$keep_constraints = !0),
                        t.getConstraintType($) === t.getConstraintType(S) && +$.constraint_date == +S.constraint_date || (m = !0))
                    }
                    return !0
                }),
                t.attachEvent("onAfterTaskUpdate", function(x, $) {
                    return t.config.auto_scheduling && !t._autoscheduling_in_progress && p !== null && p == x && (p = null,
                        $.$keep_constraints ? delete $.$keep_constraints : m || v($),
                        t.autoSchedule($.id),
                    m || b($)),
                        !0
                })
        };
        t.attachEvent("onGanttReady", function() {
            a()
        }, {
            once: !0
        })
    }
    function Y(t) {
        var n = 0
            , e = 0
            , i = 0
            , a = 0;
        if (t.getBoundingClientRect) {
            var r = t.getBoundingClientRect()
                , s = document.body
                , o = document.documentElement || document.body.parentNode || document.body
                , l = window.pageYOffset || o.scrollTop || s.scrollTop
                , d = window.pageXOffset || o.scrollLeft || s.scrollLeft
                , c = o.clientTop || s.clientTop || 0
                , u = o.clientLeft || s.clientLeft || 0;
            n = r.top + l - c,
                e = r.left + d - u,
                i = document.body.offsetWidth - r.right,
                a = document.body.offsetHeight - r.bottom
        } else {
            for (; t; )
                n += parseInt(t.offsetTop, 10),
                    e += parseInt(t.offsetLeft, 10),
                    t = t.offsetParent;
            i = document.body.offsetWidth - t.offsetWidth - e,
                a = document.body.offsetHeight - t.offsetHeight - n
        }
        return {
            y: Math.round(n),
            x: Math.round(e),
            width: t.offsetWidth,
            height: t.offsetHeight,
            right: Math.round(i),
            bottom: Math.round(a)
        }
    }
    function li(t) {
        var n = !1
            , e = !1;
        if (window.getComputedStyle) {
            var i = window.getComputedStyle(t, null);
            n = i.display,
                e = i.visibility
        } else
            t.currentStyle && (n = t.currentStyle.display,
                e = t.currentStyle.visibility);
        return n != "none" && e != "hidden"
    }
    function di(t) {
        return !isNaN(t.getAttribute("tabindex")) && 1 * t.getAttribute("tabindex") >= 0
    }
    function ci(t) {
        return !{
            a: !0,
            area: !0
        }[t.nodeName.loLowerCase()] || !!t.getAttribute("href")
    }
    function ui(t) {
        return !{
            input: !0,
            select: !0,
            textarea: !0,
            button: !0,
            object: !0
        }[t.nodeName.toLowerCase()] || !t.hasAttribute("disabled")
    }
    function zt(t) {
        for (var n = t.querySelectorAll(["a[href]", "area[href]", "input", "select", "textarea", "button", "iframe", "object", "embed", "[tabindex]", "[contenteditable]"].join(", ")), e = Array.prototype.slice.call(n, 0), i = 0; i < e.length; i++)
            e[i].$position = i;
        for (e.sort(function(r, s) {
            return r.tabIndex === 0 && s.tabIndex !== 0 ? 1 : r.tabIndex !== 0 && s.tabIndex === 0 ? -1 : r.tabIndex === s.tabIndex ? r.$position - s.$position : r.tabIndex < s.tabIndex ? -1 : 1
        }),
                 i = 0; i < e.length; i++) {
            var a = e[i];
            (di(a) || ui(a) || ci(a)) && li(a) || (e.splice(i, 1),
                i--)
        }
        return e
    }
    function on() {
        var t = document.createElement("div");
        t.style.cssText = "visibility:hidden;position:absolute;left:-1000px;width:100px;padding:0px;margin:0px;height:110px;min-height:100px;overflow-y:scroll;",
            document.body.appendChild(t);
        var n = t.offsetWidth - t.clientWidth;
        return document.body.removeChild(t),
            Math.max(n, 15)
    }
    function it(t) {
        if (!t)
            return "";
        var n = t.className || "";
        return n.baseVal && (n = n.baseVal),
        n.indexOf || (n = ""),
            be(n)
    }
    function $t(t, n) {
        n && t.className.indexOf(n) === -1 && (t.className += " " + n)
    }
    function Pt(t, n) {
        n = n.split(" ");
        for (var e = 0; e < n.length; e++) {
            var i = new RegExp("\\s?\\b" + n[e] + "\\b(?![-_.])","");
            t.className = t.className.replace(i, "")
        }
    }
    function ye(t) {
        return typeof t == "string" ? document.getElementById(t) || document.querySelector(t) || document.body : t || document.body
    }
    function ln(t, n) {
        Zt || (Zt = document.createElement("div")),
            Zt.innerHTML = n;
        var e = Zt.firstChild;
        return t.appendChild(e),
            e
    }
    function dn(t) {
        t && t.parentNode && t.parentNode.removeChild(t)
    }
    function cn(t, n) {
        for (var e = t.childNodes, i = e.length, a = [], r = 0; r < i; r++) {
            var s = e[r];
            s.className && s.className.indexOf(n) !== -1 && a.push(s)
        }
        return a
    }
    function Et(t) {
        var n;
        return t.tagName ? n = t : (n = (t = t || window.event).target || t.srcElement).shadowRoot && t.composedPath && (n = t.composedPath()[0]),
            n
    }
    function Q(t, n) {
        if (n) {
            for (var e = Et(t); e; ) {
                if (e.getAttribute && e.getAttribute(n))
                    return e;
                e = e.parentNode || e.host
            }
            return null
        }
    }
    function be(t) {
        return (String.prototype.trim || function() {
                return this.replace(/^\s+|\s+$/g, "")
            }
        ).apply(t)
    }
    function mt(t, n, e) {
        var i = Et(t)
            , a = "";
        for (e === void 0 && (e = !0); i; ) {
            if (a = it(i)) {
                var r = a.indexOf(n);
                if (r >= 0) {
                    if (!e)
                        return i;
                    var s = r === 0 || !be(a.charAt(r - 1))
                        , o = r + n.length >= a.length || !be(a.charAt(r + n.length));
                    if (s && o)
                        return i
                }
            }
            i = i.parentNode
        }
        return null
    }
    function lt(t, n) {
        var s;
        const e = document.documentElement
            , i = Y(n)
            , {clientX: a, clientY: r} = ((s = t.touches) == null ? void 0 : s[0]) ?? t;
        return {
            x: a + e.scrollLeft - e.clientLeft - i.x + n.scrollLeft,
            y: r + e.scrollTop - e.clientTop - i.y + n.scrollTop
        }
    }
    function un(t, n) {
        const e = Y(t)
            , i = Y(n);
        return {
            x: e.x - i.x,
            y: e.y - i.y
        }
    }
    function tt(t, n) {
        if (!t || !n)
            return !1;
        for (; t && t != n; )
            t = t.parentNode;
        return t === n
    }
    function dt(t, n) {
        if (t.closest)
            return t.closest(n);
        if (t.matches || t.msMatchesSelector || t.webkitMatchesSelector) {
            var e = t;
            if (!document.documentElement.contains(e))
                return null;
            do {
                if ((e.matches || e.msMatchesSelector || e.webkitMatchesSelector).call(e, n))
                    return e;
                e = e.parentElement || e.parentNode
            } while (e !== null && e.nodeType === 1);
            return null
        }
        return console.error("Your browser is not supported"),
            null
    }
    function hn(t) {
        for (; t; ) {
            if (t.offsetWidth > 0 && t.offsetHeight > 0)
                return t;
            t = t.parentElement
        }
        return null
    }
    function _n() {
        return document.head.createShadowRoot || document.head.attachShadow
    }
    function $e() {
        var t = document.activeElement;
        return t.shadowRoot && (t = t.shadowRoot.activeElement),
        t === document.body && document.getSelection && (t = document.getSelection().focusNode || document.body),
            t
    }
    function Ct(t) {
        if (!t || !_n())
            return document.body;
        for (; t.parentNode && (t = t.parentNode); )
            if (t instanceof ShadowRoot)
                return t.host;
        return document.body
    }
    const gn = Object.freeze(Object.defineProperty({
        __proto__: null,
        addClassName: $t,
        closest: dt,
        getActiveElement: $e,
        getChildNodes: cn,
        getClassName: it,
        getClosestSizedElement: hn,
        getFocusableNodes: zt,
        getNodePosition: Y,
        getRelativeEventPosition: lt,
        getRelativeNodePosition: un,
        getRootNode: Ct,
        getScrollSize: on,
        getTargetNode: Et,
        hasClass: function(t, n) {
            return "classList"in t ? t.classList.contains(n) : new RegExp("\\b" + n + "\\b").test(t.className)
        },
        hasShadowParent: function(t) {
            return !!Ct(t)
        },
        insertNode: ln,
        isChildOf: tt,
        isShadowDomSupported: _n,
        locateAttribute: Q,
        locateClassName: mt,
        removeClassName: Pt,
        removeNode: dn,
        toNode: ye
    }, Symbol.toStringTag, {
        value: "Module"
    }))
        , J = typeof window < "u" ? window : global;
    let hi = class {
            constructor(t) {
                this._mouseDown = !1,
                    this._touchStarts = !1,
                    this._touchActive = !1,
                    this._longTapTimer = !1,
                    this._gantt = t,
                    this._domEvents = t._createDomEventScope()
            }
            attach(t, n, e) {
                const i = this._gantt
                    , a = t.getViewPort();
                this._originPosition = J.getComputedStyle(a).display,
                    this._restoreOriginPosition = () => {
                        a.style.position = this._originPosition
                    }
                    ,
                this._originPosition === "static" && (a.style.position = "relative");
                const r = i.$services.getService("state");
                r.registerProvider("clickDrag", () => ({
                    autoscroll: !1
                }));
                let s = null;
                const o = () => {
                        s && (this._mouseDown = !0,
                            t.setStart(i.copy(s)),
                            t.setPosition(i.copy(s)),
                            t.setEnd(i.copy(s)),
                            s = null)
                    }
                ;
                this._domEvents.attach(a, "mousedown", f => {
                        u(f)
                    }
                );
                const l = Ct(i.$root) || document.body;
                function d(f) {
                    return f.changedTouches && f.changedTouches[0] || f
                }
                this._domEvents.attach(l, "mouseup", f => {
                        h(f)
                    }
                ),
                    this._domEvents.attach(a, "mousemove", f => {
                            _(f)
                        }
                    ),
                    this._domEvents.attach(a, "touchstart", f => {
                            this._touchStarts = !0,
                                this._longTapTimer = setTimeout( () => {
                                        this._touchStarts && (u(d(f)),
                                            this._touchStarts = !1,
                                            this._touchActive = !0)
                                    }
                                    , this._gantt.config.touch_drag)
                        }
                    ),
                    this._domEvents.attach(l, "touchend", f => {
                            this._touchStarts = !1,
                                this._touchActive = !1,
                                clearTimeout(this._longTapTimer),
                                h(d(f))
                        }
                    ),
                    this._domEvents.attach(a, "touchmove", f => {
                            if (this._touchActive) {
                                let y = c();
                                if (y && i.utils.dom.closest(f.target, y))
                                    return;
                                _(d(f)),
                                    f.preventDefault()
                            } else
                                this._touchStarts = !1,
                                    clearTimeout(this._longTapTimer)
                        }
                    );
                const c = () => {
                    let f = ".gantt_task_line, .gantt_task_link";
                    return e !== void 0 && (f = e instanceof Array ? e.join(", ") : e),
                        f
                }
                    , u = f => {
                    s = null;
                    let y = c();
                    y && i.utils.dom.closest(f.target, y) || (r.registerProvider("clickDrag", () => ({
                        autoscroll: this._mouseDown
                    })),
                    n && f[n] !== !0 || (s = this._getCoordinates(f, t)))
                }
                    , h = f => {
                    if (s = null,
                    (!n || f[n] === !0) && this._mouseDown === !0) {
                        this._mouseDown = !1;
                        const y = this._getCoordinates(f, t);
                        t.dragEnd(y)
                    }
                }
                    , _ = f => {
                    if (n && f[n] !== !0)
                        return;
                    const y = this._gantt.ext.clickDrag
                        , v = (this._gantt.config.drag_timeline || {}).useKey;
                    if (y && v && !n && f[v])
                        return;
                    let b = null;
                    if (!this._mouseDown && s)
                        return b = this._getCoordinates(f, t),
                            void (Math.abs(s.relative.left - b.relative.left) > 5 && o());
                    this._mouseDown === !0 && (b = this._getCoordinates(f, t),
                        t.setEnd(b),
                        t.render())
                }
            }
            detach() {
                const t = this._gantt;
                this._domEvents.detachAll(),
                this._restoreOriginPosition && this._restoreOriginPosition(),
                    t.$services.getService("state").unregisterProvider("clickDrag")
            }
            destructor() {
                this.detach()
            }
            _getCoordinates(t, n) {
                const e = n.getViewPort()
                    , i = e.getBoundingClientRect()
                    , {clientX: a, clientY: r} = t;
                return {
                    absolute: {
                        left: a,
                        top: r
                    },
                    relative: {
                        left: a - i.left + e.scrollLeft,
                        top: r - i.top + e.scrollTop
                    }
                }
            }
        }
    ;
    var fn = function() {
        this._silent_mode = !1,
            this.listeners = {}
    };
    fn.prototype = {
        _silentStart: function() {
            this._silent_mode = !0
        },
        _silentEnd: function() {
            this._silent_mode = !1
        }
    };
    function ct(t) {
        var n = new fn;
        t.attachEvent = function(e, i, a) {
            e = "ev_" + e.toLowerCase(),
            n.listeners[e] || (n.listeners[e] = function(s) {
                var o = {}
                    , l = 0
                    , d = function() {
                    var c = !0;
                    for (var u in o) {
                        var h = o[u].apply(s, arguments);
                        c = c && h
                    }
                    return c
                };
                return d.addEvent = function(c, u) {
                    if (typeof c == "function") {
                        var h;
                        if (u && u.id ? h = u.id : (h = l,
                            l++),
                        u && u.once) {
                            var _ = c;
                            c = function() {
                                _(),
                                    d.removeEvent(h)
                            }
                        }
                        return o[h] = c,
                            h
                    }
                    return !1
                }
                    ,
                    d.removeEvent = function(c) {
                        delete o[c]
                    }
                    ,
                    d.clear = function() {
                        o = {}
                    }
                    ,
                    d
            }(this)),
            a && a.thisObject && (i = i.bind(a.thisObject));
            var r = e + ":" + n.listeners[e].addEvent(i, a);
            return a && a.id && (r = a.id),
                r
        }
            ,
            t.attachAll = function(e) {
                this.attachEvent("listen_all", e)
            }
            ,
            t.callEvent = function(e, i) {
                if (n._silent_mode)
                    return !0;
                var a = "ev_" + e.toLowerCase()
                    , r = n.listeners;
                return r.ev_listen_all && r.ev_listen_all.apply(this, [e].concat(i)),
                !r[a] || r[a].apply(this, i)
            }
            ,
            t.checkEvent = function(e) {
                return !!n.listeners["ev_" + e.toLowerCase()]
            }
            ,
            t.detachEvent = function(e) {
                if (e) {
                    var i = n.listeners;
                    for (var a in i)
                        i[a].removeEvent(e);
                    var r = e.split(":");
                    if (i = n.listeners,
                    r.length === 2) {
                        var s = r[0]
                            , o = r[1];
                        i[s] && i[s].removeEvent(o)
                    }
                }
            }
            ,
            t.detachAllEvents = function() {
                for (var e in n.listeners)
                    n.listeners[e].clear()
            }
    }
    class _i {
        constructor(n, e, i) {
            var a;
            this._el = document.createElement("div"),
                this.defaultRender = (r, s) => {
                    this._el || (this._el = document.createElement("div"));
                    const o = this._el
                        , l = Math.min(r.relative.top, s.relative.top)
                        , d = Math.max(r.relative.top, s.relative.top)
                        , c = Math.min(r.relative.left, s.relative.left)
                        , u = Math.max(r.relative.left, s.relative.left);
                    if (this._singleRow) {
                        const h = this._getTaskPositionByTop(this._startPoint.relative.top);
                        o.style.height = h.height + "px",
                            o.style.top = h.top + "px"
                    } else
                        o.style.height = Math.abs(d - l) + "px",
                            o.style.top = l + "px";
                    return o.style.width = Math.abs(u - c) + "px",
                        o.style.left = c + "px",
                        o
                }
                ,
                this._gantt = e,
                this._view = i,
                this._viewPort = n.viewPort,
                this._el.classList.add(n.className),
            typeof n.callback == "function" && (this._callback = n.callback),
                this.render = () => {
                    let r;
                    r = n.render ? n.render(this._startPoint, this._endPoint) : this.defaultRender(this._startPoint, this._endPoint),
                    r !== this._el && (this._el && this._el.parentNode && this._el.parentNode.removeChild(this._el),
                        this._el = r),
                    n.className !== "" && this._el.classList.add(n.className),
                        this.draw()
                }
                ,
            (a = this._viewPort).attachEvent && a.detachEvent || ct(this._viewPort),
                this._singleRow = n.singleRow,
                this._useRequestAnimationFrame = n.useRequestAnimationFrame
        }
        draw() {
            if (this._useRequestAnimationFrame)
                return requestAnimationFrame( () => {
                        this._viewPort.appendChild(this.getElement())
                    }
                );
            this._viewPort.appendChild(this.getElement())
        }
        clear() {
            if (this._useRequestAnimationFrame)
                return requestAnimationFrame( () => {
                        this._el.parentNode && this._viewPort.removeChild(this._el)
                    }
                );
            this._el.parentNode && this._viewPort.removeChild(this._el)
        }
        getElement() {
            return this._el
        }
        getViewPort() {
            return this._viewPort
        }
        setStart(n) {
            const e = this._gantt;
            this._startPoint = n,
                this._startDate = e.dateFromPos(this._startPoint.relative.left),
                this._viewPort.callEvent("onBeforeDrag", [this._startPoint])
        }
        setEnd(n) {
            const e = this._gantt;
            if (this._endPoint = n,
                this._singleRow) {
                const i = this._getTaskPositionByTop(this._startPoint.relative.top);
                this._endPoint.relative.top = i.top
            }
            this._endDate = e.dateFromPos(this._endPoint.relative.left),
            this._startPoint.relative.left > this._endPoint.relative.left && (this._positionPoint = {
                relative: {
                    left: this._endPoint.relative.left,
                    top: this._positionPoint.relative.top
                },
                absolute: {
                    left: this._endPoint.absolute.left,
                    top: this._positionPoint.absolute.top
                }
            }),
            this._startPoint.relative.top > this._endPoint.relative.top && (this._positionPoint = {
                relative: {
                    left: this._positionPoint.relative.left,
                    top: this._endPoint.relative.top
                },
                absolute: {
                    left: this._positionPoint.absolute.left,
                    top: this._endPoint.absolute.top
                }
            }),
                this._viewPort.callEvent("onDrag", [this._startPoint, this._endPoint])
        }
        setPosition(n) {
            this._positionPoint = n
        }
        dragEnd(n) {
            const e = this._gantt;
            n.relative.left < 0 && (n.relative.left = 0),
                this._viewPort.callEvent("onBeforeDragEnd", [this._startPoint, n]),
                this.setEnd(n),
                this._endDate = this._endDate || e.getState().max_date,
            this._startDate.valueOf() > this._endDate.valueOf() && ([this._startDate,this._endDate] = [this._endDate, this._startDate]),
                this.clear();
            const i = e.getTaskByTime(this._startDate, this._endDate)
                , a = this._getTasksByTop(this._startPoint.relative.top, this._endPoint.relative.top);
            this._viewPort.callEvent("onDragEnd", [this._startPoint, this._endPoint]),
            this._callback && this._callback(this._startPoint, this._endPoint, this._startDate, this._endDate, i, a)
        }
        getInBounds() {
            return this._singleRow
        }
        _getTasksByTop(n, e) {
            const i = this._gantt;
            let a = n
                , r = e;
            n > e && (a = e,
                r = n);
            const s = this._getTaskPositionByTop(a).index
                , o = this._getTaskPositionByTop(r).index
                , l = [];
            for (let d = s; d <= o; d++)
                i.getTaskByIndex(d) && l.push(i.getTaskByIndex(d));
            return l
        }
        _getTaskPositionByTop(n) {
            const e = this._gantt
                , i = this._view
                , a = i.getItemIndexByTopPosition(n)
                , r = e.getTaskByIndex(a);
            if (r) {
                const s = i.getItemHeight(r.id);
                return {
                    top: i.getItemTop(r.id) || 0,
                    height: s || 0,
                    index: a
                }
            }
            {
                const s = i.getTotalHeight();
                return {
                    top: n > s ? s : 0,
                    height: e.config.row_height,
                    index: n > s ? e.getTaskCount() : 0
                }
            }
        }
    }
    let xe = !1;
    class Qt {
        constructor(n) {
            this._mouseDown = !1,
                this._calculateDirectionVector = () => {
                    if (this._trace.length >= 10) {
                        const e = this._trace.slice(this._trace.length - 10)
                            , i = [];
                        for (let r = 1; r < e.length; r++)
                            i.push({
                                x: e[r].x - e[r - 1].x,
                                y: e[r].y - e[r - 1].y
                            });
                        const a = {
                            x: 0,
                            y: 0
                        };
                        return i.forEach(r => {
                                a.x += r.x,
                                    a.y += r.y
                            }
                        ),
                            {
                                magnitude: Math.sqrt(a.x * a.x + a.y * a.y),
                                angleDegrees: 180 * Math.atan2(Math.abs(a.y), Math.abs(a.x)) / Math.PI
                            }
                    }
                    return null
                }
                ,
                this._applyDndReadyStyles = () => {
                    this._timeline.$task.classList.add("gantt_timeline_move_available")
                }
                ,
                this._clearDndReadyStyles = () => {
                    this._timeline.$task.classList.remove("gantt_timeline_move_available")
                }
                ,
                this._getScrollPosition = e => {
                    const i = this._gantt;
                    return {
                        x: i.$ui.getView(e.$config.scrollX).getScrollState().position,
                        y: i.$ui.getView(e.$config.scrollY).getScrollState().position
                    }
                }
                ,
                this._countNewScrollPosition = e => {
                    const i = this._calculateDirectionVector();
                    let a = this._startPoint.x - e.x
                        , r = this._startPoint.y - e.y;
                    return i && (i.angleDegrees < 15 ? r = 0 : i.angleDegrees > 75 && (a = 0)),
                        {
                            x: this._scrollState.x + a,
                            y: this._scrollState.y + r
                        }
                }
                ,
                this._setScrollPosition = (e, i) => {
                    const a = this._gantt;
                    requestAnimationFrame( () => {
                            a.scrollLayoutCell(e.$id, i.x, i.y)
                        }
                    )
                }
                ,
                this._stopDrag = e => {
                    const i = this._gantt;
                    if (this._trace = [],
                        i.$root.classList.remove("gantt_noselect"),
                    this._originalReadonly !== void 0 && this._mouseDown && (i.config.readonly = this._originalReadonly,
                    i.config.drag_timeline && i.config.drag_timeline.render && i.render()),
                    this._originAutoscroll !== void 0 && (i.config.autoscroll = this._originAutoscroll),
                        i.config.drag_timeline) {
                        const {useKey: a} = i.config.drag_timeline;
                        if (a && e[a] !== !0)
                            return
                    }
                    this._mouseDown = !1,
                        xe = !1
                }
                ,
                this._startDrag = e => {
                    const i = this._gantt;
                    this._originAutoscroll = i.config.autoscroll,
                        i.config.autoscroll = !1,
                        xe = !0,
                        i.$root.classList.add("gantt_noselect"),
                        this._originalReadonly = i.config.readonly,
                        i.config.readonly = !0,
                    i.config.drag_timeline && i.config.drag_timeline.render && i.render(),
                        this._trace = [],
                        this._mouseDown = !0;
                    const {x: a, y: r} = this._getScrollPosition(this._timeline);
                    this._scrollState = {
                        x: a,
                        y: r
                    },
                        this._startPoint = {
                            x: e.clientX,
                            y: e.clientY
                        },
                        this._trace.push(this._startPoint)
                }
                ,
                this._gantt = n,
                this._domEvents = n._createDomEventScope(),
                this._trace = []
        }
        static create(n) {
            return new Qt(n)
        }
        static _isDragInProgress() {
            return xe
        }
        destructor() {
            this._domEvents.detachAll()
        }
        attach(n) {
            this._timeline = n;
            const e = this._gantt;
            this._domEvents.attach(n.$task, "mousedown", i => {
                    if (!e.config.drag_timeline)
                        return;
                    const {useKey: a, ignore: r, enabled: s} = e.config.drag_timeline;
                    if (s === !1)
                        return;
                    let o = ".gantt_task_line, .gantt_task_link";
                    r !== void 0 && (o = r instanceof Array ? r.join(", ") : r),
                    o && e.utils.dom.closest(i.target, o) || a && i[a] !== !0 || this._startDrag(i)
                }
            ),
                this._domEvents.attach(document, "keydown", i => {
                        if (!e.config.drag_timeline)
                            return;
                        const {useKey: a} = e.config.drag_timeline;
                        a && i[a] === !0 && this._applyDndReadyStyles()
                    }
                ),
                this._domEvents.attach(document, "keyup", i => {
                        if (!e.config.drag_timeline)
                            return;
                        const {useKey: a} = e.config.drag_timeline;
                        a && i[a] === !1 && (this._clearDndReadyStyles(),
                            this._stopDrag(i))
                    }
                ),
                this._domEvents.attach(document, "mouseup", i => {
                        this._stopDrag(i)
                    }
                ),
                this._domEvents.attach(e.$root, "mouseup", i => {
                        this._stopDrag(i)
                    }
                ),
                this._domEvents.attach(document, "mouseleave", i => {
                        this._stopDrag(i)
                    }
                ),
                this._domEvents.attach(e.$root, "mouseleave", i => {
                        this._stopDrag(i)
                    }
                ),
                this._domEvents.attach(e.$root, "mousemove", i => {
                        if (!e.config.drag_timeline)
                            return;
                        const {useKey: a} = e.config.drag_timeline;
                        if (a && i[a] !== !0)
                            return;
                        const r = this._gantt.ext.clickDrag
                            , s = (this._gantt.config.click_drag || {}).useKey;
                        if ((!r || !s || a || !i[s]) && this._mouseDown === !0) {
                            this._trace.push({
                                x: i.clientX,
                                y: i.clientY
                            });
                            const o = this._countNewScrollPosition({
                                x: i.clientX,
                                y: i.clientY
                            });
                            this._setScrollPosition(n, o),
                                this._scrollState = o,
                                this._startPoint = {
                                    x: i.clientX,
                                    y: i.clientY
                                }
                        }
                    }
                )
        }
    }
    function gi(t) {
        (function() {
                var n = [];
                function e() {
                    return !!n.length
                }
                function i(d) {
                    setTimeout(function() {
                        e() || t.$destroyed || t.focus()
                    }, 1)
                }
                function a(d) {
                    t.eventRemove(d, "keydown", s),
                        t.event(d, "keydown", s),
                        n.push(d)
                }
                function r() {
                    var d = n.pop();
                    d && t.eventRemove(d, "keydown", s),
                        i()
                }
                function s(d) {
                    var c = d.currentTarget;
                    c == n[n.length - 1] && t.$keyboardNavigation.trapFocus(c, d)
                }
                function o() {
                    a(t.getLightbox())
                }
                t.attachEvent("onLightbox", o),
                    t.attachEvent("onAfterLightbox", r),
                    t.attachEvent("onLightboxChange", function() {
                        r(),
                            o()
                    }),
                    t.attachEvent("onAfterQuickInfo", function() {
                        i()
                    }),
                    t.attachEvent("onMessagePopup", function(d) {
                        l = t.utils.dom.getActiveElement(),
                            a(d)
                    }),
                    t.attachEvent("onAfterMessagePopup", function() {
                        r(),
                            setTimeout(function() {
                                l && l.focus && (l.focus(),
                                    l = null)
                            }, 1)
                    });
                var l = null;
                t.$keyboardNavigation.isModal = e
            }
        )()
    }
    class fi {
        constructor(n) {
            this.show = (e, i) => {
                i === void 0 ? this._showForTask(e) : this._showAtCoordinates(e, i)
            }
                ,
                this.hide = e => {
                    const i = this._gantt
                        , a = this._quickInfoBox;
                    this._quickInfoBoxId = 0;
                    const r = this._quickInfoTask;
                    if (this._quickInfoTask = null,
                    a && a.parentNode) {
                        if (i.config.quick_info_detached)
                            return i.callEvent("onAfterQuickInfo", [r]),
                                a.parentNode.removeChild(a);
                        a.className += " gantt_qi_hidden",
                            a.style.right === "auto" ? a.style.left = "-350px" : a.style.right = "-350px",
                        e && (a.style.left = a.style.right = "",
                            a.parentNode.removeChild(a)),
                            i.callEvent("onAfterQuickInfo", [r])
                    }
                }
                ,
                this.getNode = () => this._quickInfoBox ? this._quickInfoBox : null,
                this.setContainer = e => {
                    e && (this._container = typeof e == "string" ? document.getElementById(e) : e)
                }
                ,
                this.setContent = e => {
                    const i = this._gantt
                        , a = {
                        taskId: null,
                        header: {
                            title: "",
                            date: ""
                        },
                        content: "",
                        buttons: i.config.quickinfo_buttons
                    };
                    e || (e = a),
                    e.taskId || (e.taskId = a.taskId),
                    e.header || (e.header = a.header),
                    e.header.title || (e.header.title = a.header.title),
                    e.header.date || (e.header.date = a.header.date),
                    e.content || (e.content = a.content),
                    e.buttons || (e.buttons = a.buttons);
                    let r = this.getNode();
                    r || (r = this._createQuickInfoElement()),
                    e.taskId && (this._quickInfoBoxId = e.taskId);
                    const s = r.querySelector(".gantt_cal_qi_title")
                        , o = s.querySelector(".gantt_cal_qi_tcontent")
                        , l = s.querySelector(".gantt_cal_qi_tdate")
                        , d = r.querySelector(".gantt_cal_qi_content")
                        , c = r.querySelector(".gantt_cal_qi_controls");
                    i._waiAria.quickInfoHeader(r, [e.header.title, e.header.date].join(" ")),
                        o.innerHTML = e.header.title,
                        l.innerHTML = e.header.date,
                        e.header.title || e.header.date ? s.style.display = "" : s.style.display = "none",
                        d.innerHTML = e.content;
                    const u = e.buttons;
                    u.length ? c.style.display = "" : c.style.display = "none";
                    let h = "";
                    for (let _ = 0; _ < u.length; _++) {
                        const f = i._waiAria.quickInfoButtonAttrString(i.locale.labels[u[_]]);
                        h += `<div class="gantt_qi_big_icon ${u[_]} dhx_gantt_${u[_]}" title="${i.locale.labels[u[_]]}" ${f}>
            <div class='dhx_menu_icon dhx_gantt_icon ${u[_]} gantt_menu_icon dhx_gantt_${u[_]}'></div>
            <div>${i.locale.labels[u[_]]}</div>
         </div>`
                    }
                    c.innerHTML = h,
                        i.eventRemove(r, "click", this._qiButtonClickHandler),
                        i.eventRemove(r, "keypress", this._qiKeyPressHandler),
                        i.event(r, "click", this._qiButtonClickHandler),
                        i.event(r, "keypress", this._qiKeyPressHandler)
                }
                ,
                this._qiButtonClickHandler = e => {
                    this._qi_button_click(e.target)
                }
                ,
                this._qiKeyPressHandler = e => {
                    const i = e.which;
                    i !== 13 && i !== 32 || setTimeout( () => {
                            this._qi_button_click(e.target)
                        }
                        , 1)
                }
                ,
                this._gantt = n
        }
        _showAtCoordinates(n, e) {
            this.hide(!0),
                this._quickInfoBoxId = 0,
                this._quickInfoTask = null,
            this._quickInfoBox || (this._createQuickInfoElement(),
                this.setContent()),
                this._appendAtCoordinates(n, e),
                this._gantt.callEvent("onQuickInfo", [null])
        }
        _showForTask(n) {
            const e = this._gantt;
            if (n === this._quickInfoBoxId && e.utils.dom.isChildOf(this._quickInfoBox, document.body) || !e.config.show_quick_info)
                return;
            this.hide(!0);
            const i = this._getContainer()
                , a = this._get_event_counter_part(n, 6, i.xViewport, i.yViewport);
            a && (this._quickInfoBox = this._init_quick_info(n),
                this._quickInfoTask = n,
                this._quickInfoBox.className = this._prepare_quick_info_classname(n),
                this._fill_quick_data(n),
                this._show_quick_info(a, 6),
                e.callEvent("onQuickInfo", [n]))
        }
        _get_event_counter_part(n, e, i, a) {
            const r = this._gantt;
            let s = r.getTaskNode(n);
            if (!s && (s = r.getTaskRowNode(n),
                !s))
                return null;
            let o = 0;
            const l = e + s.offsetTop + s.offsetHeight;
            let d = s;
            if (r.utils.dom.isChildOf(d, i))
                for (; d && d !== i; )
                    o += d.offsetLeft,
                        d = d.offsetParent;
            const c = r.getScrollState();
            return d ? {
                left: o,
                top: l,
                dx: o + s.offsetWidth / 2 - c.x > i.offsetWidth / 2 ? 1 : 0,
                dy: l + s.offsetHeight / 2 - c.y > a.offsetHeight / 2 ? 1 : 0,
                width: s.offsetWidth,
                height: s.offsetHeight
            } : null
        }
        _createQuickInfoElement() {
            const n = this._gantt
                , e = document.createElement("div");
            e.className += "gantt_cal_quick_info",
                n._waiAria.quickInfoAttr(e);
            var i = `
		<div class="gantt_cal_qi_tcontrols">
			<a class="gantt_cal_qi_close_btn dhx_gantt_icon dhx_gantt_icon_close"></a>
		</div>
		<div class="gantt_cal_qi_title" ${n._waiAria.quickInfoHeaderAttrString()}>
				
				<div class="gantt_cal_qi_tcontent"></div>
				<div class="gantt_cal_qi_tdate"></div>
			</div>
			<div class="gantt_cal_qi_content"></div>`;
            if (i += '<div class="gantt_cal_qi_controls">',
                i += "</div>",
                e.innerHTML = i,
                n.config.quick_info_detached) {
                const a = this._getContainer();
                n.event(a.parent, "scroll", () => {
                        this.hide()
                    }
                )
            }
            return this._quickInfoBox = e,
                e
        }
        _init_quick_info(n) {
            const e = this._gantt
                , i = e.getTask(n);
            return typeof this._quickInfoReadonly == "boolean" && e.isReadonly(i) !== this._quickInfoReadonly && (this.hide(!0),
                this._quickInfoBox = null),
                this._quickInfoReadonly = e.isReadonly(i),
            this._quickInfoBox || (this._quickInfoBox = this._createQuickInfoElement()),
                this._quickInfoBox
        }
        _prepare_quick_info_classname(n) {
            const e = this._gantt
                , i = e.getTask(n);
            let a = `gantt_cal_quick_info gantt_${e.getTaskType(i)}`;
            const r = e.templates.quick_info_class(i.start_date, i.end_date, i);
            return r && (a += " " + r),
                a
        }
        _fill_quick_data(n) {
            const e = this._gantt
                , i = e.getTask(n);
            this._quickInfoBoxId = n;
            let a = [];
            if (this._quickInfoReadonly) {
                const r = e.config.quickinfo_buttons
                    , s = {
                    icon_delete: !0,
                    icon_edit: !0
                };
                for (let o = 0; o < r.length; o++)
                    this._quickInfoReadonly && s[r[o]] || a.push(r[o])
            } else
                a = e.config.quickinfo_buttons;
            this.setContent({
                header: {
                    title: e.templates.quick_info_title(i.start_date, i.end_date, i),
                    date: e.templates.quick_info_date(i.start_date, i.end_date, i)
                },
                content: e.templates.quick_info_content(i.start_date, i.end_date, i),
                buttons: a
            })
        }
        _appendAtCoordinates(n, e) {
            const i = this._quickInfoBox
                , a = this._getContainer();
            i.parentNode && i.parentNode.nodeName.toLowerCase() !== "#document-fragment" || a.parent.appendChild(i),
                i.style.left = n + "px",
                i.style.top = e + "px"
        }
        _show_quick_info(n, e) {
            const i = this._gantt
                , a = this._quickInfoBox;
            if (i.config.quick_info_detached) {
                const r = this._getContainer();
                a.parentNode && a.parentNode.nodeName.toLowerCase() !== "#document-fragment" || r.parent.appendChild(a);
                const s = a.offsetWidth
                    , o = a.offsetHeight
                    , l = i.getScrollState()
                    , d = r.xViewport
                    , c = r.yViewport
                    , u = d.offsetWidth + l.x - s
                    , h = n.top - l.y + o;
                let _ = n.top;
                h > c.offsetHeight / 2 && (_ = n.top - (o + n.height + 2 * e),
                _ < l.y && h <= c.offsetHeight && (_ = n.top)),
                _ < l.y && (_ = l.y);
                const f = Math.min(Math.max(l.x, n.left - n.dx * (s - n.width)), u)
                    , y = _;
                this._appendAtCoordinates(f, y)
            } else
                a.style.top = "20px",
                    n.dx === 1 ? (a.style.right = "auto",
                        a.style.left = "-300px",
                        setTimeout( () => {
                                a.style.left = "10px"
                            }
                            , 1)) : (a.style.left = "auto",
                        a.style.right = "-300px",
                        setTimeout( () => {
                                a.style.right = "10px"
                            }
                            , 1)),
                    a.className += " gantt_qi_" + (n.dx === 1 ? "left" : "right"),
                    i.$root.appendChild(a)
        }
        _qi_button_click(n) {
            const e = this._gantt
                , i = this._quickInfoBox;
            if (!n || n === i)
                return;
            if (n.closest(".gantt_cal_qi_close_btn"))
                return void this.hide();
            const a = n.className;
            if (a.indexOf("_icon") !== -1) {
                const r = this._quickInfoBoxId;
                e.$click.buttons[a.split(" ")[1].replace("icon_", "")](r)
            } else
                this._qi_button_click(n.parentNode)
        }
        _getContainer() {
            const n = this._gantt;
            let e = this._container ? this._container : n.$task_data;
            return e && e.offsetHeight && e.offsetWidth ? {
                parent: e,
                xViewport: n.$task,
                yViewport: n.$task_data
            } : (e = this._container ? this._container : n.$grid_data,
                e && e.offsetHeight && e.offsetWidth ? {
                    parent: e,
                    xViewport: n.$grid,
                    yViewport: n.$grid_data
                } : {
                    parent: this._container ? this._container : n.$layout,
                    xViewport: n.$layout,
                    yViewport: n.$layout
                })
        }
    }
    var we, pi = {}.constructor.toString();
    function X(t) {
        var n, e;
        if (t && typeof t == "object")
            switch (!0) {
                case nt(t):
                    e = new Date(t);
                    break;
                case Lt(t):
                    for (e = new Array(t.length),
                             n = 0; n < t.length; n++)
                        e[n] = X(t[n]);
                    break;
                default:
                    if (function(i) {
                        return i.constructor.toString() !== pi
                    }(t))
                        e = Object.create(t);
                    else {
                        if (function(i) {
                            return i.$$typeof && i.$$typeof.toString().includes("react.")
                        }(t))
                            return e = t;
                        e = {}
                    }
                    for (n in t)
                        Object.prototype.hasOwnProperty.apply(t, [n]) && (e[n] = X(t[n]))
            }
        return e || t
    }
    function O(t, n, e) {
        for (var i in n)
            (t[i] === void 0 || e) && (t[i] = n[i]);
        return t
    }
    function U(t) {
        return t !== void 0
    }
    function ut() {
        return we || (we = new Date().valueOf()),
            ++we
    }
    function z(t, n) {
        return t.bind ? t.bind(n) : function() {
            return t.apply(n, arguments)
        }
    }
    function pn(t, n, e, i) {
        t.addEventListener ? t.addEventListener(n, e, i !== void 0 && i) : t.attachEvent && t.attachEvent("on" + n, e)
    }
    function mn(t, n, e, i) {
        t.removeEventListener ? t.removeEventListener(n, e, i !== void 0 && i) : t.detachEvent && t.detachEvent("on" + n, e)
    }
    const vn = Object.freeze(Object.defineProperty({
        __proto__: null,
        bind: z,
        copy: X,
        defined: U,
        event: pn,
        eventRemove: mn,
        mixin: O,
        uid: ut
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function Se(t, n) {
        t = t || pn,
            n = n || mn;
        var e = []
            , i = {
            attach: function(a, r, s, o) {
                e.push({
                    element: a,
                    event: r,
                    callback: s,
                    capture: o
                }),
                    t(a, r, s, o)
            },
            detach: function(a, r, s, o) {
                n(a, r, s, o);
                for (var l = 0; l < e.length; l++) {
                    var d = e[l];
                    d.element === a && d.event === r && d.callback === s && d.capture === o && (e.splice(l, 1),
                        l--)
                }
            },
            detachAll: function() {
                for (var a = e.slice(), r = 0; r < a.length; r++) {
                    var s = a[r];
                    i.detach(s.element, s.event, s.callback, s.capture),
                        i.detach(s.element, s.event, s.callback, void 0),
                        i.detach(s.element, s.event, s.callback, !1),
                        i.detach(s.element, s.event, s.callback, !0)
                }
                e.splice(0, e.length)
            },
            extend: function() {
                return Se(this.event, this.eventRemove)
            }
        };
        return i
    }
    class mi {
        constructor(n) {
            this._gantt = n
        }
        getNode() {
            const n = this._gantt;
            return this._tooltipNode || (this._tooltipNode = document.createElement("div"),
                this._tooltipNode.className = "gantt_tooltip",
                n._waiAria.tooltipAttr(this._tooltipNode)),
                this._tooltipNode
        }
        setViewport(n) {
            return this._root = n,
                this
        }
        show(n, e) {
            const i = this._gantt
                , a = document.body
                , r = this.getNode();
            if (tt(r, a) || (this.hide(),
                r.style.top = r.style.top || "0px",
                r.style.left = r.style.left || "0px",
                a.appendChild(r)),
                this._isLikeMouseEvent(n)) {
                const s = this._calculateTooltipPosition(n);
                e = s.top,
                    n = s.left
            }
            return r.style.top = e + "px",
                r.style.left = n + "px",
                i._waiAria.tooltipVisibleAttr(r),
                this
        }
        hide() {
            const n = this._gantt
                , e = this.getNode();
            return e && e.parentNode && e.parentNode.removeChild(e),
                n._waiAria.tooltipHiddenAttr(e),
                this
        }
        setContent(n) {
            return this.getNode().innerHTML = n,
                this
        }
        _isLikeMouseEvent(n) {
            return !(!n || typeof n != "object") && "clientX"in n && "clientY"in n
        }
        _getViewPort() {
            return this._root || document.body
        }
        _calculateTooltipPosition(n) {
            const e = this._gantt
                , i = this._getViewPortSize()
                , a = this.getNode()
                , r = {
                top: 0,
                left: 0,
                width: a.offsetWidth,
                height: a.offsetHeight,
                bottom: 0,
                right: 0
            }
                , s = e.config.tooltip_offset_x
                , o = e.config.tooltip_offset_y
                , l = document.body
                , d = lt(n, l)
                , c = Y(l);
            d.y += c.y,
                r.top = d.y,
                r.left = d.x,
                r.top += o,
                r.left += s,
                r.bottom = r.top + r.height,
                r.right = r.left + r.width;
            const u = window.scrollY + l.scrollTop;
            return r.top < i.top - u ? (r.top = i.top,
                r.bottom = r.top + r.height) : r.bottom > i.bottom && (r.bottom = i.bottom,
                r.top = r.bottom - r.height),
                r.left < i.left ? (r.left = i.left,
                    r.right = i.left + r.width) : r.right > i.right && (r.right = i.right,
                    r.left = r.right - r.width),
            d.x >= r.left && d.x <= r.right && (r.left = d.x - r.width - s,
                r.right = r.left + r.width),
            d.y >= r.top && d.y <= r.bottom && (r.top = d.y - r.height - o,
                r.bottom = r.top + r.height),
            r.left < 0 && (r.left = 0),
            r.right < 0 && (r.right = 0),
                r
        }
        _getViewPortSize() {
            const n = this._gantt
                , e = this._getViewPort();
            let i, a = e, r = window.scrollY + document.body.scrollTop, s = window.scrollX + document.body.scrollLeft;
            return e === n.$task_data ? (a = n.$task,
                r = 0,
                s = 0,
                i = Y(n.$task)) : i = Y(a),
                {
                    left: i.x + s,
                    top: i.y + r,
                    width: i.width,
                    height: i.height,
                    bottom: i.y + i.height + r,
                    right: i.x + i.width + s
                }
        }
    }
    class vi {
        constructor(n) {
            this._listeners = {},
                this.tooltip = new mi(n),
                this._gantt = n,
                this._domEvents = Se(),
                this._initDelayedFunctions()
        }
        destructor() {
            this.tooltip.hide(),
                this._domEvents.detachAll()
        }
        hideTooltip() {
            this.delayHide()
        }
        attach(n) {
            let e = document.body;
            const i = this._gantt;
            n.global || (e = i.$root);
            let a = null;
            const r = s => {
                    const o = Et(s)
                        , l = dt(o, n.selector);
                    if (tt(o, this.tooltip.getNode()))
                        return;
                    const d = () => {
                            a = l,
                                n.onmouseenter(s, l)
                        }
                    ;
                    a ? l && l === a ? n.onmousemove(s, l) : (n.onmouseleave(s, a),
                        a = null,
                    l && l !== a && d()) : l && d()
                }
            ;
            this.detach(n.selector),
                this._domEvents.attach(e, "mousemove", r),
                this._listeners[n.selector] = {
                    node: e,
                    handler: r
                }
        }
        detach(n) {
            const e = this._listeners[n];
            e && this._domEvents.detach(e.node, "mousemove", e.handler)
        }
        tooltipFor(n) {
            const e = i => {
                    let a = i;
                    return document.createEventObject && !document.createEvent && (a = document.createEventObject(i)),
                        a
                }
            ;
            this._initDelayedFunctions(),
                this.attach({
                    selector: n.selector,
                    global: n.global,
                    onmouseenter: (i, a) => {
                        const r = n.html(i, a);
                        r && this.delayShow(e(i), r)
                    }
                    ,
                    onmousemove: (i, a) => {
                        const r = n.html(i, a);
                        r ? this.delayShow(e(i), r) : (this.delayShow.$cancelTimeout(),
                            this.delayHide())
                    }
                    ,
                    onmouseleave: () => {
                        this.delayShow.$cancelTimeout(),
                            this.delayHide()
                    }
                })
        }
        _initDelayedFunctions() {
            const n = this._gantt;
            this.delayShow && this.delayShow.$cancelTimeout(),
            this.delayHide && this.delayHide.$cancelTimeout(),
                this.tooltip.hide(),
                this.delayShow = Xt( (e, i) => {
                        n.callEvent("onBeforeTooltip", [e]) === !1 ? this.tooltip.hide() : (this.tooltip.setContent(i),
                            this.tooltip.show(e))
                    }
                    , n.config.tooltip_timeout || 1),
                this.delayHide = Xt( () => {
                        this.delayShow.$cancelTimeout(),
                            this.tooltip.hide()
                    }
                    , n.config.tooltip_hide_timeout || 1)
        }
    }
    const kn = {
        onBeforeUndo: "onAfterUndo",
        onBeforeRedo: "onAfterRedo"
    }
        , yn = ["onTaskDragStart", "onAfterTaskUpdate", "onAfterParentExpand", "onAfterTaskDelete", "onBeforeBatchUpdate"];
    class ki {
        constructor(n, e) {
            this._batchAction = null,
                this._batchMode = !1,
                this._ignore = !1,
                this._ignoreMoveEvents = !1,
                this._initialTasks = {},
                this._initialLinks = {},
                this._nestedTasks = {},
                this._nestedLinks = {},
                this._undo = n,
                this._gantt = e,
                this._attachEvents()
        }
        store(n, e, i=!1) {
            return e === this._gantt.config.undo_types.task ? this._storeTask(n, i) : e === this._gantt.config.undo_types.link && this._storeLink(n, i)
        }
        isMoveEventsIgnored() {
            return this._ignoreMoveEvents
        }
        toggleIgnoreMoveEvents(n) {
            this._ignoreMoveEvents = n || !1
        }
        startIgnore() {
            this._ignore = !0
        }
        stopIgnore() {
            this._ignore = !1
        }
        startBatchAction() {
            this._timeout || (this._timeout = setTimeout( () => {
                    this.stopBatchAction(),
                        this._timeout = null
                }
                , 10)),
            this._ignore || this._batchMode || (this._batchMode = !0,
                this._batchAction = this._undo.action.create())
        }
        stopBatchAction() {
            if (this._ignore)
                return;
            const n = this._undo;
            this._batchAction && n.logAction(this._batchAction),
                this._batchMode = !1,
                this._batchAction = null
        }
        onTaskAdded(n) {
            this._ignore || this._storeTaskCommand(n, this._undo.command.type.add)
        }
        onTaskUpdated(n) {
            this._ignore || this._storeTaskCommand(n, this._undo.command.type.update)
        }
        onTaskMoved(n) {
            this._ignore || (n.$local_index = this._gantt.getTaskIndex(n.id),
                this._storeEntityCommand(n, this.getInitialTask(n.id), this._undo.command.type.move, this._undo.command.entity.task))
        }
        onTaskDeleted(n) {
            if (!this._ignore) {
                if (this._storeTaskCommand(n, this._undo.command.type.remove),
                    this._nestedTasks[n.id]) {
                    const e = this._nestedTasks[n.id];
                    for (let i = 0; i < e.length; i++)
                        this._storeTaskCommand(e[i], this._undo.command.type.remove)
                }
                if (this._nestedLinks[n.id]) {
                    const e = this._nestedLinks[n.id];
                    for (let i = 0; i < e.length; i++)
                        this._storeLinkCommand(e[i], this._undo.command.type.remove)
                }
            }
        }
        onLinkAdded(n) {
            this._ignore || this._storeLinkCommand(n, this._undo.command.type.add)
        }
        onLinkUpdated(n) {
            this._ignore || this._storeLinkCommand(n, this._undo.command.type.update)
        }
        onLinkDeleted(n) {
            this._ignore || this._storeLinkCommand(n, this._undo.command.type.remove)
        }
        setNestedTasks(n, e) {
            const i = this._gantt;
            let a = null;
            const r = [];
            let s = this._getLinks(i.getTask(n));
            for (let d = 0; d < e.length; d++)
                a = this.setInitialTask(e[d]),
                    s = s.concat(this._getLinks(a)),
                    r.push(a);
            const o = {};
            for (let d = 0; d < s.length; d++)
                o[s[d]] = !0;
            const l = [];
            for (const d in o)
                l.push(this.setInitialLink(d));
            this._nestedTasks[n] = r,
                this._nestedLinks[n] = l
        }
        setInitialTask(n, e) {
            const i = this._gantt;
            if (e || !this._initialTasks[n] || !this._batchMode) {
                const a = i.copy(i.getTask(n));
                a.$index = i.getGlobalTaskIndex(n),
                    a.$local_index = i.getTaskIndex(n),
                    this.setInitialTaskObject(n, a)
            }
            return this._initialTasks[n]
        }
        getInitialTask(n) {
            return this._initialTasks[n]
        }
        clearInitialTasks() {
            this._initialTasks = {}
        }
        setInitialTaskObject(n, e) {
            this._initialTasks[n] = e
        }
        setInitialLink(n, e) {
            return this._initialLinks[n] && this._batchMode || (this._initialLinks[n] = this._gantt.copy(this._gantt.getLink(n))),
                this._initialLinks[n]
        }
        getInitialLink(n) {
            return this._initialLinks[n]
        }
        clearInitialLinks() {
            this._initialLinks = {}
        }
        _attachEvents() {
            let n = null;
            const e = this._gantt
                , i = () => {
                n || (n = setTimeout( () => {
                        n = null
                    }
                ),
                    this.clearInitialTasks(),
                    e.eachTask(l => {
                            this.setInitialTask(l.id)
                        }
                    ),
                    this.clearInitialLinks(),
                    e.getLinks().forEach(l => {
                            this.setInitialLink(l.id)
                        }
                    ))
            }
                , a = l => e.copy(e.getTask(l));
            for (const l in kn)
                e.attachEvent(l, () => (this.startIgnore(),
                    !0)),
                    e.attachEvent(kn[l], () => (this.stopIgnore(),
                        !0));
            for (let l = 0; l < yn.length; l++)
                e.attachEvent(yn[l], () => (this.startBatchAction(),
                    !0));
            e.attachEvent("onParse", () => {
                    this._undo.clearUndoStack(),
                        this._undo.clearRedoStack(),
                        i()
                }
            ),
                e.attachEvent("onAfterTaskAdd", (l, d) => {
                        this.setInitialTask(l, !0),
                            this.onTaskAdded(d)
                    }
                ),
                e.attachEvent("onAfterTaskUpdate", (l, d) => {
                        this.onTaskUpdated(d)
                    }
                ),
                e.attachEvent("onAfterParentExpand", (l, d) => {
                        this.onTaskUpdated(d)
                    }
                ),
                e.attachEvent("onAfterTaskDelete", (l, d) => {
                        this.onTaskDeleted(d)
                    }
                ),
                e.attachEvent("onAfterLinkAdd", (l, d) => {
                        this.setInitialLink(l, !0),
                            this.onLinkAdded(d)
                    }
                ),
                e.attachEvent("onAfterLinkUpdate", (l, d) => {
                        this.onLinkUpdated(d)
                    }
                ),
                e.attachEvent("onAfterLinkDelete", (l, d) => {
                        this.onLinkDeleted(d)
                    }
                ),
                e.attachEvent("onRowDragEnd", (l, d) => (this.onTaskMoved(a(l)),
                    this.toggleIgnoreMoveEvents(),
                    !0)),
                e.attachEvent("onBeforeTaskDelete", l => {
                        this.store(l, e.config.undo_types.task);
                        const d = [];
                        return i(),
                            e.eachTask(c => {
                                    d.push(c.id)
                                }
                                , l),
                            this.setNestedTasks(l, d),
                            !0
                    }
                );
            const r = e.getDatastore("task");
            r.attachEvent("onBeforeItemMove", (l, d, c) => (this.isMoveEventsIgnored() || i(),
                !0)),
                r.attachEvent("onAfterItemMove", (l, d, c) => (this.isMoveEventsIgnored() || this.onTaskMoved(a(l)),
                    !0)),
                e.attachEvent("onRowDragStart", (l, d, c) => (this.toggleIgnoreMoveEvents(!0),
                    i(),
                    !0));
            let s = null
                , o = !1;
            if (e.attachEvent("onBeforeTaskDrag", l => {
                    if (s = e.getState().drag_id,
                    s === l) {
                        const d = e.getTask(l);
                        e.isSummaryTask(d) && e.config.drag_project && (o = !0)
                    }
                    if (e.plugins().multiselect) {
                        const d = e.getSelectedTasks();
                        d.length > 1 && d.forEach(c => {
                                this.store(c, e.config.undo_types.task, !0)
                            }
                        )
                    }
                    return this.store(l, e.config.undo_types.task)
                }
            ),
                e.attachEvent("onAfterTaskDrag", l => {
                        (o || e.plugins().multiselect && e.getSelectedTasks().length > 1) && s === l && (o = !1,
                            s = null,
                            this.stopBatchAction()),
                            this.store(l, e.config.undo_types.task, !0)
                    }
                ),
                e.attachEvent("onLightbox", l => this.store(l, e.config.undo_types.task)),
                e.attachEvent("onBeforeTaskAutoSchedule", l => (this.store(l.id, e.config.undo_types.task, !0),
                    !0)),
                e.ext.inlineEditors) {
                let l = null
                    , d = null;
                e.attachEvent("onGanttLayoutReady", () => {
                        l && e.ext.inlineEditors.detachEvent(l),
                        d && e.ext.inlineEditors.detachEvent(d),
                            d = e.ext.inlineEditors.attachEvent("onEditStart", c => {
                                    this.store(c.id, e.config.undo_types.task)
                                }
                            ),
                            l = e.ext.inlineEditors.attachEvent("onBeforeEditStart", c => (this.stopBatchAction(),
                                !0))
                    }
                )
            }
        }
        _storeCommand(n) {
            const e = this._undo;
            if (e.updateConfigs(),
                e.undoEnabled)
                if (this._batchMode)
                    this._batchAction.commands.push(n);
                else {
                    const i = e.action.create([n]);
                    e.logAction(i)
                }
        }
        _storeEntityCommand(n, e, i, a) {
            const r = this._undo.command.create(n, e, i, a);
            this._storeCommand(r)
        }
        _storeTaskCommand(n, e) {
            this._gantt.isTaskExists(n.id) && (n.$local_index = this._gantt.getTaskIndex(n.id)),
                this._storeEntityCommand(n, this.getInitialTask(n.id), e, this._undo.command.entity.task)
        }
        _storeLinkCommand(n, e) {
            this._storeEntityCommand(n, this.getInitialLink(n.id), e, this._undo.command.entity.link)
        }
        _getLinks(n) {
            return n.$source.concat(n.$target)
        }
        _storeTask(n, e=!1) {
            const i = this._gantt;
            return this.setInitialTask(n, e),
                i.eachTask(a => {
                        this.setInitialTask(a.id)
                    }
                    , n),
                !0
        }
        _storeLink(n, e=!1) {
            return this.setInitialLink(n, e),
                !0
        }
    }
    class yi {
        constructor(n) {
            this.maxSteps = 100,
                this.undoEnabled = !0,
                this.redoEnabled = !0,
                this.action = {
                    create: e => ({
                        commands: e ? e.slice() : []
                    }),
                    invert: e => {
                        const i = this._gantt.copy(e)
                            , a = this.command;
                        for (let r = 0; r < e.commands.length; r++) {
                            const s = i.commands[r] = a.invert(i.commands[r]);
                            s.type !== a.type.update && s.type !== a.type.move || ([s.value,s.oldValue] = [s.oldValue, s.value])
                        }
                        return i
                    }
                },
                this.command = {
                    entity: null,
                    type: null,
                    create: (e, i, a, r) => {
                        const s = this._gantt;
                        return {
                            entity: r,
                            type: a,
                            value: s.copy(e),
                            oldValue: s.copy(i || e)
                        }
                    }
                    ,
                    invert: e => {
                        const i = this._gantt.copy(e);
                        return i.type = this.command.inverseCommands(e.type),
                            i
                    }
                    ,
                    inverseCommands: e => {
                        const i = this._gantt
                            , a = this.command.type;
                        switch (e) {
                            case a.update:
                                return a.update;
                            case a.remove:
                                return a.add;
                            case a.add:
                                return a.remove;
                            case a.move:
                                return a.move;
                            default:
                                return i.assert(!1, "Invalid command " + e),
                                    null
                        }
                    }
                },
                this._undoStack = [],
                this._redoStack = [],
                this._gantt = n
        }
        getUndoStack() {
            return this._undoStack
        }
        setUndoStack(n) {
            this._undoStack = n
        }
        getRedoStack() {
            return this._redoStack
        }
        setRedoStack(n) {
            this._redoStack = n
        }
        clearUndoStack() {
            this._undoStack = []
        }
        clearRedoStack() {
            this._redoStack = []
        }
        updateConfigs() {
            const n = this._gantt;
            this.maxSteps = n.config.undo_steps || 100,
                this.command.entity = n.config.undo_types,
                this.command.type = n.config.undo_actions,
                this.undoEnabled = !!n.config.undo,
                this.redoEnabled = !!n.config.redo
        }
        undo() {
            const n = this._gantt;
            if (this.updateConfigs(),
                !this.undoEnabled)
                return;
            const e = this._pop(this._undoStack);
            if (e && this._reorderCommands(e),
            n.callEvent("onBeforeUndo", [e]) !== !1 && e)
                return this._applyAction(this.action.invert(e)),
                    this._push(this._redoStack, n.copy(e)),
                    void n.callEvent("onAfterUndo", [e]);
            n.callEvent("onAfterUndo", [null])
        }
        redo() {
            const n = this._gantt;
            if (this.updateConfigs(),
                !this.redoEnabled)
                return;
            const e = this._pop(this._redoStack);
            if (e && this._reorderCommands(e),
            n.callEvent("onBeforeRedo", [e]) !== !1 && e)
                return this._applyAction(e),
                    this._push(this._undoStack, n.copy(e)),
                    void n.callEvent("onAfterRedo", [e]);
            n.callEvent("onAfterRedo", [null])
        }
        logAction(n) {
            this._push(this._undoStack, n),
                this._redoStack = []
        }
        _push(n, e) {
            const i = this._gantt;
            if (!e.commands.length)
                return;
            const a = n === this._undoStack ? "onBeforeUndoStack" : "onBeforeRedoStack";
            if (i.callEvent(a, [e]) !== !1 && e.commands.length) {
                for (n.push(e); n.length > this.maxSteps; )
                    n.shift();
                return e
            }
        }
        _pop(n) {
            return n.pop()
        }
        _reorderCommands(n) {
            const e = {
                any: 0,
                link: 1,
                task: 2
            }
                , i = {
                move: 1,
                any: 0
            };
            n.commands.sort(function(a, r) {
                if (a.entity === "task" && r.entity === "task")
                    return a.type !== r.type ? (i[r.type] || 0) - (i[a.type] || 0) : a.type === "move" && a.oldValue && r.oldValue && r.oldValue.parent === a.oldValue.parent ? a.oldValue.$index - r.oldValue.$index : 0;
                {
                    const s = e[a.entity] || e.any;
                    return (e[r.entity] || e.any) - s
                }
            })
        }
        _applyAction(n) {
            let e = null;
            const i = this.command.entity
                , a = this.command.type
                , r = this._gantt
                , s = {};
            s[i.task] = {
                add: "addTask",
                get: "getTask",
                update: "updateTask",
                remove: "deleteTask",
                move: "moveTask",
                isExists: "isTaskExists"
            },
                s[i.link] = {
                    add: "addLink",
                    get: "getLink",
                    update: "updateLink",
                    remove: "deleteLink",
                    isExists: "isLinkExists"
                },
                r.batchUpdate(function() {
                    for (let o = 0; o < n.commands.length; o++) {
                        e = n.commands[o];
                        const l = s[e.entity][e.type]
                            , d = s[e.entity].get
                            , c = s[e.entity].isExists;
                        if (e.type === a.add)
                            r[l](e.oldValue, e.oldValue.parent, e.oldValue.$local_index);
                        else if (e.type === a.remove)
                            r[c](e.value.id) && r[l](e.value.id);
                        else if (e.type === a.update) {
                            const u = r[d](e.value.id);
                            for (const h in e.value) {
                                let _ = !(h.startsWith("$") || h.startsWith("_"));
                                ["$open"].indexOf(h) > -1 && (_ = !0),
                                _ && (u[h] = e.value[h])
                            }
                            r[l](e.value.id)
                        } else
                            e.type === a.move && (r[l](e.value.id, e.value.$local_index, e.value.parent),
                                r.callEvent("onRowDragEnd", [e.value.id]))
                    }
                })
        }
    }
    const bi = {
        auto_scheduling: function(t) {
            It(t),
                tn(t);
            var n = rn(t)
                , e = an()
                , i = pe.Create(t)
                , a = new ai(t,e,i)
                , r = new ri(t,n)
                , s = new si(t,e,n);
            t.getConnectedGroup = r.getConnectedGroup,
                t.getConstraintType = i.getConstraintType,
                t.getConstraintLimitations = function(l) {
                    var d = i.processConstraint(l, null);
                    return d ? {
                        earliestStart: d.earliestStart || null,
                        earliestEnd: d.earliestEnd || null,
                        latestStart: d.latestStart || null,
                        latestEnd: d.latestEnd || null
                    } : {
                        earliestStart: null,
                        earliestEnd: null,
                        latestStart: null,
                        latestEnd: null
                    }
                }
                ,
                t.isCircularLink = s.isCircularLink,
                t.findCycles = s.findCycles,
                t.config.constraint_types = V,
                t.config.auto_scheduling = !1,
                t.config.auto_scheduling_descendant_links = !1,
                t.config.auto_scheduling_initial = !0,
                t.config.auto_scheduling_strict = !1,
                t.config.auto_scheduling_move_projects = !0,
                t.config.project_start = null,
                t.config.project_end = null,
                t.config.schedule_from_end = !1;
            var o = !1;
            t.attachEvent("onParse", function() {
                return o = !0,
                    !0
            }),
                t.attachEvent("onBeforeGanttRender", function() {
                    return o = !1,
                        !0
                }),
                t._autoSchedule = function(l, d) {
                    if (t.callEvent("onBeforeAutoSchedule", [l]) !== !1) {
                        t._autoscheduling_in_progress = !0;
                        var c = i.getConstraints(l, t.isTaskExists(l) ? d : null)
                            , u = []
                            , h = e.findLoops(d);
                        if (h.length)
                            t.callEvent("onAutoScheduleCircularLink", [h]);
                        else {
                            (function(f, y) {
                                    if (t.config.auto_scheduling_compatibility)
                                        for (var v = 0; v < y.length; v++) {
                                            var b = y[v]
                                                , g = t.getTask(b.target);
                                            t.config.auto_scheduling_strict && b.target != f || (b.preferredStart = new Date(g.start_date))
                                        }
                                }
                            )(l, d);
                            for (let f = 0; f < d.length; f++)
                                if (d[f].subtaskLink) {
                                    a._secondIterationRequired = !0,
                                        a._secondIteration = !1;
                                    break
                                }
                            var _ = a.generatePlan(d, c);
                            (function(f) {
                                    f.length && t.batchUpdate(function() {
                                        for (var y = 0; y < f.length; y++)
                                            t.updateTask(f[y])
                                    }, o)
                                }
                            )(u = a.applyProjectPlan(_))
                        }
                        t._autoscheduling_in_progress = !1,
                            t.callEvent("onAfterAutoSchedule", [l, u])
                    }
                }
                ,
                t.autoSchedule = function(l, d) {
                    var c;
                    d = d === void 0 || !!d,
                        c = l !== void 0 ? t.config.auto_scheduling_compatibility ? n.getLinkedTasks(l, d) : r.getConnectedGroupRelations(l) : n.getLinkedTasks(),
                        t._autoSchedule(l, c)
                }
                ,
                t.attachEvent("onTaskLoading", function(l) {
                    return l.constraint_date && typeof l.constraint_date == "string" && (l.constraint_date = t.date.parseDate(l.constraint_date, "parse_date")),
                        l.constraint_type = t.getConstraintType(l),
                        !0
                }),
                t.attachEvent("onTaskCreated", function(l) {
                    return l.constraint_type = t.getConstraintType(l),
                        !0
                }),
                oi(t, n, s, r)
        },
        click_drag: function(t) {
            t.ext || (t.ext = {});
            const n = {
                className: "gantt_click_drag_rect",
                useRequestAnimationFrame: !0,
                callback: void 0,
                singleRow: !1
            };
            function e() {
                const i = {
                    viewPort: t.$task_data,
                    ...n
                };
                t.ext.clickDrag && t.ext.clickDrag.destructor(),
                    t.ext.clickDrag = new hi(t);
                const a = t.config.click_drag;
                i.render = a.render || n.render,
                    i.className = a.className || n.className,
                    i.callback = a.callback || n.callback,
                    i.viewPort = a.viewPort || t.$task_data,
                    i.useRequestAnimationFrame = a.useRequestAnimationFrame === void 0 ? n.useRequestAnimationFrame : a.useRequestAnimationFrame,
                    i.singleRow = a.singleRow === void 0 ? n.singleRow : a.singleRow;
                const r = t.$ui.getView("timeline")
                    , s = new _i(i,t,r);
                t.ext.clickDrag.attach(s, a.useKey, a.ignore)
            }
            t.attachEvent("onGanttReady", () => {
                    t.config.click_drag && e()
                }
            ),
                t.attachEvent("onGanttLayoutReady", function() {
                    t.$container && t.config.click_drag && t.attachEvent("onGanttRender", function() {
                        e()
                    }, {
                        once: !0
                    })
                }),
                t.attachEvent("onDestroy", () => {
                        t.ext.clickDrag && t.ext.clickDrag.destructor()
                    }
                )
        },
        critical_path: function(t) {
            It(t),
                tn(t);
            var n = function(i) {
                var a = rn(i)
                    , r = an()
                    , s = {
                    _freeSlack: {},
                    _totalSlack: {},
                    _slackNeedCalculate: !0,
                    _linkedTasksById: {},
                    _successorsByTaskId: {},
                    _projectEnd: null,
                    _calculateSlacks: function() {
                        var o = a.getLinkedTasks()
                            , l = r.findLoops(o);
                        if (l.length) {
                            i.callEvent("onAutoScheduleCircularLink", [l]);
                            var d = {};
                            l.forEach(function(f) {
                                f.linkKeys.forEach(function(y) {
                                    d[y] = !0
                                })
                            });
                            for (var c = 0; c < o.length; c++)
                                o[c].hashSum in d && (o.splice(c, 1),
                                    c--)
                        }
                        const u = r.topologicalSort(o).reverse()
                            , h = {};
                        o.forEach(f => {
                                h[f.source] || (h[f.source] = {
                                    linked: []
                                }),
                                    h[f.source].linked.push({
                                        target: f.target,
                                        link: f
                                    })
                            }
                        );
                        const _ = {
                            _cache: {},
                            getDist: function(f, y) {
                                const v = `${f.id}_${y.id}`;
                                if (this._cache[v])
                                    return this._cache[v];
                                {
                                    const b = i.calculateDuration({
                                        start_date: f.end_date,
                                        end_date: y.start_date,
                                        task: f
                                    });
                                    return this._cache[v] = b,
                                        b
                                }
                            }
                        };
                        this._projectEnd = i.getSubtaskDates().end_date,
                            this._calculateFreeSlack(o, u, h, _),
                            this._calculateTotalSlack(o, u, h, _)
                    },
                    _isCompletedTask: function(o) {
                        return i.config.auto_scheduling_use_progress && o.progress == 1
                    },
                    _calculateFreeSlack: function(o, l, d, c) {
                        const u = this._freeSlack = {}
                            , h = {};
                        i.eachTask(function(f) {
                            i.isSummaryTask(f) || (h[f.id] = f)
                        });
                        const _ = {};
                        o.forEach(f => {
                                const y = h[f.source];
                                if (!y)
                                    return;
                                _[f.source] = !0;
                                let v = c.getDist(y, i.getTask(f.target));
                                v -= f.lag || 0,
                                    u[f.source] !== void 0 ? u[f.source] = Math.min(v, u[f.source]) : u[f.source] = v
                            }
                        );
                        for (const f in h) {
                            if (_[f])
                                continue;
                            const y = h[f];
                            this._isCompletedTask(y) || y.unscheduled ? u[y.id] = 0 : u[y.id] = i.calculateDuration({
                                start_date: y.end_date,
                                end_date: this._projectEnd,
                                task: y
                            })
                        }
                        return this._freeSlack
                    },
                    _disconnectedTaskSlack(o) {
                        return this._isCompletedTask(o) ? 0 : Math.max(i.calculateDuration(o.end_date, this._projectEnd), 0)
                    },
                    _calculateTotalSlack: function(o, l, d, c) {
                        this._totalSlack = {},
                            this._slackNeedCalculate = !1;
                        for (var u = {}, h = i.getTaskByTime(), _ = 0; _ < l.length; _++) {
                            const y = i.getTask(l[_]);
                            if (this._isCompletedTask(y))
                                u[y.id] = 0;
                            else if (d[y.id] || i.isSummaryTask(y)) {
                                const v = d[y.id].linked;
                                let b = null;
                                for (var f = 0; f < v.length; f++) {
                                    const g = v[f]
                                        , m = i.getTask(g.target);
                                    let p = 0;
                                    u[m.id] !== void 0 && (p += u[m.id]),
                                        p += c.getDist(y, m),
                                        p -= g.link.lag || 0,
                                        b = b === null ? p : Math.min(b, p)
                                }
                                u[y.id] = b || 0
                            } else
                                u[y.id] = this.getFreeSlack(y)
                        }
                        return h.forEach((function(y) {
                                u[y.id] !== void 0 || i.isSummaryTask(y) || (u[y.id] = this.getFreeSlack(y))
                            }
                        ).bind(this)),
                            this._totalSlack = u,
                            this._totalSlack
                    },
                    _resetTotalSlackCache: function() {
                        this._slackNeedCalculate = !0
                    },
                    _shouldCalculateTotalSlack: function() {
                        return this._slackNeedCalculate
                    },
                    getFreeSlack: function(o) {
                        return this._shouldCalculateTotalSlack() && this._calculateSlacks(),
                            i.isTaskExists(o.id) ? this._isCompletedTask(o) ? 0 : i.isSummaryTask(o) ? void 0 : this._freeSlack[o.id] || 0 : 0
                    },
                    getTotalSlack: function(o) {
                        if (this._shouldCalculateTotalSlack() && this._calculateSlacks(),
                        o === void 0)
                            return this._totalSlack;
                        var l;
                        if (l = o.id !== void 0 ? o.id : o,
                            this._isCompletedTask(o))
                            return 0;
                        if (this._totalSlack[l] === void 0) {
                            if (i.isSummaryTask(i.getTask(l))) {
                                var d = null;
                                return i.eachTask((function(c) {
                                        var u = this._totalSlack[c.id];
                                        u !== void 0 && (d === null || u < d) && (d = u)
                                    }
                                ).bind(this), l),
                                    this._totalSlack[l] = d !== null ? d : i.calculateDuration({
                                        start_date: o.end_date,
                                        end_date: this._projectEnd,
                                        task: o
                                    }),
                                    this._totalSlack[l]
                            }
                            return 0
                        }
                        return this._totalSlack[l] || 0
                    },
                    dropCachedFreeSlack: function() {
                        this._freeSlack = {},
                            this._resetTotalSlackCache()
                    },
                    init: function() {
                        function o() {
                            s.dropCachedFreeSlack()
                        }
                        i.attachEvent("onAfterLinkAdd", o),
                            i.attachEvent("onTaskIdChange", o),
                            i.attachEvent("onAfterLinkUpdate", o),
                            i.attachEvent("onAfterLinkDelete", o),
                            i.attachEvent("onAfterTaskAdd", o),
                            i.attachEvent("onAfterTaskUpdate", o),
                            i.attachEvent("onAfterTaskDelete", o),
                            i.attachEvent("onRowDragEnd", o),
                            i.attachEvent("onAfterTaskMove", o),
                            i.attachEvent("onParse", o),
                            i.attachEvent("onClear", o),
                            i.$data.tasksStore.attachEvent("onClearAll", o),
                            i.$data.linksStore.attachEvent("onClearAll", o)
                    }
                };
                return s
            }(t);
            n.init(),
                t.getFreeSlack = function(i) {
                    return n.getFreeSlack(i)
                }
                ,
                t.getTotalSlack = function(i) {
                    return n.getTotalSlack(i)
                }
            ;
            var e = function(i) {
                return i._isProjectEnd = function(a) {
                    return !this._hasDuration({
                        start_date: a.end_date,
                        end_date: this._getProjectEnd(),
                        task: a
                    })
                }
                    ,
                    {
                        _cache: {},
                        _slackHelper: null,
                        reset: function() {
                            this._cache = {}
                        },
                        _calculateCriticalPath: function() {
                            this.reset()
                        },
                        isCriticalTask: function(a) {
                            if (!a)
                                return !1;
                            if (i.config.auto_scheduling_use_progress && a.progress === 1)
                                return this._cache[a.id] = !1,
                                    !1;
                            if (a.unscheduled)
                                return !1;
                            if (this._cache[a.id] === void 0)
                                if (i.isSummaryTask(a)) {
                                    let r = !1;
                                    i.eachTask((function(s) {
                                            r || (r = this.isCriticalTask(s))
                                        }
                                    ).bind(this), a.id),
                                        this._cache[a.id] = r
                                } else
                                    this._cache[a.id] = this._slackHelper.getTotalSlack(a) <= 0;
                            return this._cache[a.id]
                        },
                        init: function(a) {
                            this._slackHelper = a;
                            var r = i.bind(function() {
                                return this.reset(),
                                    !0
                            }, this)
                                , s = i.bind(function(l, d) {
                                return this._cache && (this._cache[d] = this._cache[l],
                                    delete this._cache[l]),
                                    !0
                            }, this);
                            i.attachEvent("onAfterLinkAdd", r),
                                i.attachEvent("onAfterLinkUpdate", r),
                                i.attachEvent("onAfterLinkDelete", r),
                                i.attachEvent("onAfterTaskAdd", r),
                                i.attachEvent("onTaskIdChange", s),
                                i.attachEvent("onAfterTaskUpdate", r),
                                i.attachEvent("onAfterTaskDelete", r),
                                i.attachEvent("onParse", r),
                                i.attachEvent("onClear", r),
                                i.$data.tasksStore.attachEvent("onClearAll", r),
                                i.$data.linksStore.attachEvent("onClearAll", r);
                            var o = function() {
                                i.config.highlight_critical_path && !i.getState("batchUpdate").batch_update && i.render()
                            };
                            i.attachEvent("onAfterLinkAdd", o),
                                i.attachEvent("onAfterLinkUpdate", o),
                                i.attachEvent("onAfterLinkDelete", o),
                                i.attachEvent("onAfterTaskAdd", o),
                                i.attachEvent("onTaskIdChange", function(l, d) {
                                    return i.config.highlight_critical_path && i.isTaskExists(d) && i.refreshTask(d),
                                        !0
                                }),
                                i.attachEvent("onAfterTaskUpdate", o),
                                i.attachEvent("onAfterTaskDelete", o)
                        }
                    }
            }(t);
            t.config.highlight_critical_path = !1,
                e.init(n),
                t.isCriticalTask = function(i) {
                    return t.assert(!(!i || i.id === void 0), "Invalid argument for gantt.isCriticalTask"),
                        e.isCriticalTask(i)
                }
                ,
                t.isCriticalLink = function(i) {
                    return this.isCriticalTask(t.getTask(i.source))
                }
                ,
                t.getSlack = function(i, a) {
                    for (var r = 0, s = [], o = {}, l = 0; l < i.$source.length; l++)
                        o[i.$source[l]] = !0;
                    for (l = 0; l < a.$target.length; l++)
                        o[a.$target[l]] && s.push(a.$target[l]);
                    if (s[0])
                        for (l = 0; l < s.length; l++) {
                            var d = this.getLink(s[l])
                                , c = this._getSlack(i, a, this._convertToFinishToStartLink(d.id, d, i, a, i.parent, a.parent));
                            (r > c || l === 0) && (r = c)
                        }
                    else
                        r = this._getSlack(i, a, {});
                    return r
                }
                ,
                t._getSlack = function(i, a, r) {
                    var s = this.config.types
                        , o = null;
                    o = this.getTaskType(i.type) == s.milestone ? i.start_date : i.end_date;
                    var l = a.start_date
                        , d = 0;
                    d = +o > +l ? -this.calculateDuration({
                        start_date: l,
                        end_date: o,
                        task: i
                    }) : this.calculateDuration({
                        start_date: o,
                        end_date: l,
                        task: i
                    });
                    var c = r.lag;
                    return c && 1 * c == c && (d -= c),
                        d
                }
        },
        drag_timeline: function(t) {
            t.ext || (t.ext = {}),
                t.ext.dragTimeline = {
                    create: () => Qt.create(t),
                    _isDragInProgress: () => Qt._isDragInProgress
                },
                t.config.drag_timeline = {
                    enabled: !0,
                    render: !1
                }
        },
        fullscreen: function(t) {
            function n() {
                const c = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
                return !(!c || c !== document.body)
            }
            function e() {
                try {
                    return document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled
                } catch (c) {
                    console.error("Fullscreen is not available:", c)
                }
            }
            t.$services.getService("state").registerProvider("fullscreen", () => e() ? {
                fullscreen: n()
            } : void 0);
            let i = {
                overflow: null,
                padding: null,
                paddingTop: null,
                paddingRight: null,
                paddingBottom: null,
                paddingLeft: null
            };
            const a = {
                width: null,
                height: null,
                top: null,
                left: null,
                position: null,
                zIndex: null,
                modified: !1
            };
            let r = null;
            function s(c, u) {
                u.width = c.width,
                    u.height = c.height,
                    u.top = c.top,
                    u.left = c.left,
                    u.position = c.position,
                    u.zIndex = c.zIndex
            }
            let o = !1;
            function l() {
                if (!t.$container)
                    return;
                let c;
                n() ? o && (c = "onExpand",
                    function() {
                        const u = t.ext.fullscreen.getFullscreenElement()
                            , h = document.body;
                        s(u.style, a),
                            i = {
                                overflow: h.style.overflow,
                                padding: h.style.padding ? h.style.padding : null,
                                paddingTop: h.style.paddingTop ? h.style.paddingTop : null,
                                paddingRight: h.style.paddingRight ? h.style.paddingRight : null,
                                paddingBottom: h.style.paddingBottom ? h.style.paddingBottom : null,
                                paddingLeft: h.style.paddingLeft ? h.style.paddingLeft : null
                            },
                        h.style.padding && (h.style.padding = "0"),
                        h.style.paddingTop && (h.style.paddingTop = "0"),
                        h.style.paddingRight && (h.style.paddingRight = "0"),
                        h.style.paddingBottom && (h.style.paddingBottom = "0"),
                        h.style.paddingLeft && (h.style.paddingLeft = "0"),
                            h.style.overflow = "hidden",
                            u.style.width = "100vw",
                            u.style.height = "100vh",
                            u.style.top = "0px",
                            u.style.left = "0px",
                            u.style.position = "absolute",
                            u.style.zIndex = 1,
                            a.modified = !0,
                            r = function(_) {
                                let f = _.parentNode;
                                const y = [];
                                for (; f && f.style; )
                                    y.push({
                                        element: f,
                                        originalPositioning: f.style.position
                                    }),
                                        f.style.position = "static",
                                        f = f.parentNode;
                                return y
                            }(u)
                    }()) : o && (o = !1,
                    c = "onCollapse",
                    function() {
                        const u = t.ext.fullscreen.getFullscreenElement()
                            , h = document.body;
                        a.modified && (i.padding && (h.style.padding = i.padding),
                        i.paddingTop && (h.style.paddingTop = i.paddingTop),
                        i.paddingRight && (h.style.paddingRight = i.paddingRight),
                        i.paddingBottom && (h.style.paddingBottom = i.paddingBottom),
                        i.paddingLeft && (h.style.paddingLeft = i.paddingLeft),
                            h.style.overflow = i.overflow,
                            i = {
                                overflow: null,
                                padding: null,
                                paddingTop: null,
                                paddingRight: null,
                                paddingBottom: null,
                                paddingLeft: null
                            },
                            s(a, u.style),
                            a.modified = !1),
                            r.forEach(_ => {
                                    _.element.style.position = _.originalPositioning
                                }
                            ),
                            r = null
                    }()),
                    setTimeout( () => {
                            t.render()
                        }
                    ),
                    setTimeout( () => {
                            t.callEvent(c, [t.ext.fullscreen.getFullscreenElement()])
                        }
                    )
            }
            function d() {
                return !t.$container || !t.ext.fullscreen.getFullscreenElement() ? !0 : e() ? !1 : ((console.warning || console.log)("The `fullscreen` feature not being allowed, or full-screen mode not being supported"),
                    !0)
            }
            t.ext.fullscreen = {
                expand() {
                    if (d() || n() || !t.callEvent("onBeforeExpand", [this.getFullscreenElement()]))
                        return;
                    o = !0;
                    const c = document.body
                        , u = c.webkitRequestFullscreen ? [Element.ALLOW_KEYBOARD_INPUT] : []
                        , h = c.msRequestFullscreen || c.mozRequestFullScreen || c.webkitRequestFullscreen || c.requestFullscreen;
                    h && h.apply(c, u)
                },
                collapse() {
                    if (d() || !n() || !t.callEvent("onBeforeCollapse", [this.getFullscreenElement()]))
                        return;
                    const c = document.msExitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.exitFullscreen;
                    c && c.apply(document)
                },
                toggle() {
                    d() || (n() ? this.collapse() : this.expand())
                },
                getFullscreenElement: () => t.$root
            },
                t.expand = function() {
                    t.ext.fullscreen.expand()
                }
                ,
                t.collapse = function() {
                    t.ext.fullscreen.collapse()
                }
                ,
                t.attachEvent("onGanttReady", function() {
                    t.event(document, "webkitfullscreenchange", l),
                        t.event(document, "mozfullscreenchange", l),
                        t.event(document, "MSFullscreenChange", l),
                        t.event(document, "fullscreenChange", l),
                        t.event(document, "fullscreenchange", l)
                })
        },
        keyboard_navigation: function(t) {
            (function(n) {
                    n.config.keyboard_navigation = !0,
                        n.config.keyboard_navigation_cells = !1,
                        n.$keyboardNavigation = {},
                        n._compose = function() {
                            for (var e = Array.prototype.slice.call(arguments, 0), i = {}, a = 0; a < e.length; a++) {
                                var r = e[a];
                                for (var s in typeof r == "function" && (r = new r),
                                    r)
                                    i[s] = r[s]
                            }
                            return i
                        }
                        ,
                        function(e) {
                            e.$keyboardNavigation.shortcuts = {
                                createCommand: function() {
                                    return {
                                        modifiers: {
                                            shift: !1,
                                            alt: !1,
                                            ctrl: !1,
                                            meta: !1
                                        },
                                        keyCode: null
                                    }
                                },
                                parse: function(i) {
                                    for (var a = [], r = this.getExpressions(this.trim(i)), s = 0; s < r.length; s++) {
                                        for (var o = this.getWords(r[s]), l = this.createCommand(), d = 0; d < o.length; d++)
                                            this.commandKeys[o[d]] ? l.modifiers[o[d]] = !0 : this.specialKeys[o[d]] ? l.keyCode = this.specialKeys[o[d]] : l.keyCode = o[d].charCodeAt(0);
                                        a.push(l)
                                    }
                                    return a
                                },
                                getCommandFromEvent: function(i) {
                                    var a = this.createCommand();
                                    a.modifiers.shift = !!i.shiftKey,
                                        a.modifiers.alt = !!i.altKey,
                                        a.modifiers.ctrl = !!i.ctrlKey,
                                        a.modifiers.meta = !!i.metaKey,
                                        a.keyCode = i.which || i.keyCode,
                                    a.keyCode >= 96 && a.keyCode <= 105 && (a.keyCode -= 48);
                                    var r = String.fromCharCode(a.keyCode);
                                    return r && (a.keyCode = r.toLowerCase().charCodeAt(0)),
                                        a
                                },
                                getHashFromEvent: function(i) {
                                    return this.getHash(this.getCommandFromEvent(i))
                                },
                                getHash: function(i) {
                                    var a = [];
                                    for (var r in i.modifiers)
                                        i.modifiers[r] && a.push(r);
                                    return a.push(i.keyCode),
                                        a.join(this.junctionChar)
                                },
                                getExpressions: function(i) {
                                    return i.split(this.junctionChar)
                                },
                                getWords: function(i) {
                                    return i.split(this.combinationChar)
                                },
                                trim: function(i) {
                                    return i.replace(/\s/g, "")
                                },
                                junctionChar: ",",
                                combinationChar: "+",
                                commandKeys: {
                                    shift: 16,
                                    alt: 18,
                                    ctrl: 17,
                                    meta: !0
                                },
                                specialKeys: {
                                    backspace: 8,
                                    tab: 9,
                                    enter: 13,
                                    esc: 27,
                                    space: 32,
                                    up: 38,
                                    down: 40,
                                    left: 37,
                                    right: 39,
                                    home: 36,
                                    end: 35,
                                    pageup: 33,
                                    pagedown: 34,
                                    delete: 46,
                                    insert: 45,
                                    plus: 107,
                                    f1: 112,
                                    f2: 113,
                                    f3: 114,
                                    f4: 115,
                                    f5: 116,
                                    f6: 117,
                                    f7: 118,
                                    f8: 119,
                                    f9: 120,
                                    f10: 121,
                                    f11: 122,
                                    f12: 123
                                }
                            }
                        }(n),
                        function(e) {
                            e.$keyboardNavigation.EventHandler = {
                                _handlers: null,
                                findHandler: function(i) {
                                    this._handlers || (this._handlers = {});
                                    var a = e.$keyboardNavigation.shortcuts.getHash(i);
                                    return this._handlers[a]
                                },
                                doAction: function(i, a) {
                                    var r = this.findHandler(i);
                                    if (r) {
                                        if (e.$keyboardNavigation.facade.callEvent("onBeforeAction", [i, a]) === !1)
                                            return;
                                        r.call(this, a),
                                            a.preventDefault ? a.preventDefault() : a.returnValue = !1
                                    }
                                },
                                bind: function(i, a) {
                                    this._handlers || (this._handlers = {});
                                    for (var r = e.$keyboardNavigation.shortcuts, s = r.parse(i), o = 0; o < s.length; o++)
                                        this._handlers[r.getHash(s[o])] = a
                                },
                                unbind: function(i) {
                                    for (var a = e.$keyboardNavigation.shortcuts, r = a.parse(i), s = 0; s < r.length; s++)
                                        this._handlers[a.getHash(r[s])] && delete this._handlers[a.getHash(r[s])]
                                },
                                bindAll: function(i) {
                                    for (var a in i)
                                        this.bind(a, i[a])
                                },
                                initKeys: function() {
                                    this._handlers || (this._handlers = {}),
                                    this.keys && this.bindAll(this.keys)
                                }
                            }
                        }(n),
                        function(e) {
                            e.$keyboardNavigation.getFocusableNodes = zt,
                                e.$keyboardNavigation.trapFocus = function(i, a) {
                                    if (a.keyCode != 9)
                                        return !1;
                                    for (var r = e.$keyboardNavigation.getFocusableNodes(i), s = $e(), o = -1, l = 0; l < r.length; l++)
                                        if (r[l] == s) {
                                            o = l;
                                            break
                                        }
                                    if (a.shiftKey) {
                                        if (o <= 0) {
                                            var d = r[r.length - 1];
                                            if (d)
                                                return d.focus(),
                                                    a.preventDefault(),
                                                    !0
                                        }
                                    } else if (o >= r.length - 1) {
                                        var c = r[0];
                                        if (c)
                                            return c.focus(),
                                                a.preventDefault(),
                                                !0
                                    }
                                    return !1
                                }
                        }(n),
                        function(e) {
                            e.$keyboardNavigation.GanttNode = function() {}
                                ,
                                e.$keyboardNavigation.GanttNode.prototype = e._compose(e.$keyboardNavigation.EventHandler, {
                                    focus: function() {
                                        e.focus()
                                    },
                                    blur: function() {},
                                    isEnabled: function() {
                                        return e.$container.hasAttribute("tabindex")
                                    },
                                    scrollHorizontal: function(i) {
                                        var a = e.dateFromPos(e.getScrollState().x)
                                            , r = e.getScale()
                                            , s = i < 0 ? -r.step : r.step;
                                        a = e.date.add(a, s, r.unit),
                                            e.scrollTo(e.posFromDate(a))
                                    },
                                    scrollVertical: function(i) {
                                        var a = e.getScrollState().y
                                            , r = e.config.row_height;
                                        e.scrollTo(null, a + (i < 0 ? -1 : 1) * r)
                                    },
                                    keys: {
                                        "alt+left": function(i) {
                                            this.scrollHorizontal(-1)
                                        },
                                        "alt+right": function(i) {
                                            this.scrollHorizontal(1)
                                        },
                                        "alt+up": function(i) {
                                            this.scrollVertical(-1)
                                        },
                                        "alt+down": function(i) {
                                            this.scrollVertical(1)
                                        },
                                        "ctrl+z": function() {
                                            e.undo && e.undo()
                                        },
                                        "ctrl+r": function() {
                                            e.redo && e.redo()
                                        }
                                    }
                                }),
                                e.$keyboardNavigation.GanttNode.prototype.bindAll(e.$keyboardNavigation.GanttNode.prototype.keys)
                        }(n),
                        function(e) {
                            e.$keyboardNavigation.KeyNavNode = function() {}
                                ,
                                e.$keyboardNavigation.KeyNavNode.prototype = e._compose(e.$keyboardNavigation.EventHandler, {
                                    isValid: function() {
                                        return !0
                                    },
                                    fallback: function() {
                                        return null
                                    },
                                    moveTo: function(i) {
                                        e.$keyboardNavigation.dispatcher.setActiveNode(i)
                                    },
                                    compareTo: function(i) {
                                        if (!i)
                                            return !1;
                                        for (var a in this) {
                                            if (!!this[a] != !!i[a])
                                                return !1;
                                            var r = !(!this[a] || !this[a].toString)
                                                , s = !(!i[a] || !i[a].toString);
                                            if (s != r)
                                                return !1;
                                            if (s && r) {
                                                if (i[a].toString() != this[a].toString())
                                                    return !1
                                            } else if (i[a] != this[a])
                                                return !1
                                        }
                                        return !0
                                    },
                                    getNode: function() {},
                                    focus: function() {
                                        var i = this.getNode();
                                        if (i) {
                                            var a = e.$keyboardNavigation.facade;
                                            a.callEvent("onBeforeFocus", [i]) !== !1 && i && (i.setAttribute("tabindex", "-1"),
                                            i.$eventAttached || (i.$eventAttached = !0,
                                                e.event(i, "focus", function(r) {
                                                    return r.preventDefault(),
                                                        !1
                                                }, !1)),
                                            e.utils.dom.isChildOf(document.activeElement, i) && (i = document.activeElement),
                                            i.focus && i.focus(),
                                                a.callEvent("onFocus", [this.getNode()]))
                                        }
                                    },
                                    blur: function() {
                                        var i = this.getNode();
                                        i && (e.$keyboardNavigation.facade.callEvent("onBlur", [i]),
                                            i.setAttribute("tabindex", "-1"))
                                    }
                                })
                        }(n),
                        function(e) {
                            e.$keyboardNavigation.HeaderCell = function(i) {
                                this.index = i || 0
                            }
                                ,
                                e.$keyboardNavigation.HeaderCell.prototype = e._compose(e.$keyboardNavigation.KeyNavNode, {
                                    _handlers: null,
                                    isValid: function() {
                                        return !(!e.config.show_grid && e.getVisibleTaskCount() || !e.getGridColumns()[this.index] && e.getVisibleTaskCount())
                                    },
                                    fallback: function() {
                                        if (!e.config.show_grid)
                                            return e.getVisibleTaskCount() ? new e.$keyboardNavigation.TaskRow : null;
                                        for (var i = e.getGridColumns(), a = this.index; a >= 0 && !i[a]; )
                                            a--;
                                        return i[a] ? new e.$keyboardNavigation.HeaderCell(a) : null
                                    },
                                    fromDomElement: function(i) {
                                        var a = mt(i, "gantt_grid_head_cell");
                                        if (a) {
                                            for (var r = 0; a && a.previousSibling; )
                                                a = a.previousSibling,
                                                    r += 1;
                                            return new e.$keyboardNavigation.HeaderCell(r)
                                        }
                                        return null
                                    },
                                    getNode: function() {
                                        const i = e.$grid_scale;
                                        return i ? i.childNodes[this.index] : null
                                    },
                                    keys: {
                                        left: function() {
                                            this.index > 0 && this.moveTo(new e.$keyboardNavigation.HeaderCell(this.index - 1))
                                        },
                                        right: function() {
                                            var i = e.getGridColumns();
                                            this.index < i.length - 1 && this.moveTo(new e.$keyboardNavigation.HeaderCell(this.index + 1))
                                        },
                                        down: function() {
                                            var i, a = e.getChildren(e.config.root_id);
                                            e.isTaskExists(a[0]) && (i = a[0]),
                                            i && (e.config.keyboard_navigation_cells ? this.moveTo(new e.$keyboardNavigation.TaskCell(i,this.index)) : this.moveTo(new e.$keyboardNavigation.TaskRow(i)))
                                        },
                                        end: function() {
                                            var i = e.getGridColumns();
                                            this.moveTo(new e.$keyboardNavigation.HeaderCell(i.length - 1))
                                        },
                                        home: function() {
                                            this.moveTo(new e.$keyboardNavigation.HeaderCell(0))
                                        },
                                        "enter, space": function() {
                                            $e().click()
                                        },
                                        "ctrl+enter": function() {
                                            e.isReadonly(this) || e.createTask({}, this.taskId)
                                        }
                                    }
                                }),
                                e.$keyboardNavigation.HeaderCell.prototype.bindAll(e.$keyboardNavigation.HeaderCell.prototype.keys)
                        }(n),
                        function(e) {
                            e.$keyboardNavigation.TaskRow = function(i) {
                                if (!i) {
                                    var a = e.getChildren(e.config.root_id);
                                    a[0] && (i = a[0])
                                }
                                this.taskId = i,
                                e.isTaskExists(this.taskId) && (this.index = e.getTaskIndex(this.taskId),
                                    this.globalIndex = e.getGlobalTaskIndex(this.taskId),
                                    this.splitItem = !!e.getTask(this.taskId).$split_subtask,
                                    this.parentId = e.getParent(this.taskId))
                            }
                                ,
                                e.$keyboardNavigation.TaskRow.prototype = e._compose(e.$keyboardNavigation.KeyNavNode, {
                                    _handlers: null,
                                    isValid: function() {
                                        return e.isTaskExists(this.taskId) && e.getTaskIndex(this.taskId) > -1
                                    },
                                    fallback: function() {
                                        if (!e.getVisibleTaskCount()) {
                                            var i = new e.$keyboardNavigation.HeaderCell;
                                            return i.isValid() ? i : null
                                        }
                                        if (this.splitItem)
                                            return new e.$keyboardNavigation.TaskRow(this.parentId);
                                        var a = -1;
                                        if (e.getTaskByIndex(this.globalIndex - 1))
                                            a = this.globalIndex - 1;
                                        else if (e.getTaskByIndex(this.globalIndex + 1))
                                            a = this.globalIndex + 1;
                                        else
                                            for (var r = this.globalIndex; r >= 0; ) {
                                                if (e.getTaskByIndex(r)) {
                                                    a = r;
                                                    break
                                                }
                                                r--
                                            }
                                        return a > -1 ? new e.$keyboardNavigation.TaskRow(e.getTaskByIndex(a).id) : void 0
                                    },
                                    fromDomElement: function(i) {
                                        if (e.config.keyboard_navigation_cells)
                                            return null;
                                        var a = e.locate(i);
                                        return e.isTaskExists(a) ? new e.$keyboardNavigation.TaskRow(a) : null
                                    },
                                    getNode: function() {
                                        if (e.isTaskExists(this.taskId) && e.isTaskVisible(this.taskId))
                                            return e.config.show_grid ? e.$grid.querySelector(`.gantt_row[${e.config.task_attribute}="${String(this.taskId).replaceAll('"', '\\"')}"]`) : e.getTaskNode(this.taskId)
                                    },
                                    focus: function(i) {
                                        if (!i) {
                                            const a = e.getTaskPosition(e.getTask(this.taskId))
                                                , r = e.getTaskHeight(this.taskId)
                                                , s = e.getScrollState();
                                            let o, l;
                                            o = e.$task ? e.$task.offsetWidth : s.inner_width,
                                                l = e.$grid_data || e.$task_data ? (e.$grid_data || e.$task_data).offsetHeight : s.inner_height;
                                            const d = e.config.show_chart && e.$ui.getView("timeline");
                                            a.top < s.y || a.top + r > s.y + l ? e.scrollTo(null, a.top - 20) : e.config.scroll_on_click && d && (a.left > s.x + o ? e.scrollTo(a.left - e.config.task_scroll_offset) : a.left + a.width < s.x && e.scrollTo(a.left + a.width - e.config.task_scroll_offset))
                                        }
                                        e.$keyboardNavigation.KeyNavNode.prototype.focus.apply(this, [i]),
                                            function() {
                                                var a = e.$ui.getView("grid");
                                                if (a && a.$grid_data) {
                                                    var r = parseInt(a.$grid.scrollLeft)
                                                        , s = parseInt(a.$grid_data.scrollTop)
                                                        , o = a.$config.scrollX;
                                                    if (o && a.$config.scrollable) {
                                                        var l = e.$ui.getView(o);
                                                        l && l.scrollTo(r, s)
                                                    }
                                                    var d = a.$config.scrollY;
                                                    if (d) {
                                                        var c = e.$ui.getView(d);
                                                        c && c.scrollTo(r, s)
                                                    }
                                                }
                                            }()
                                    },
                                    keys: {
                                        pagedown: function() {
                                            e.getVisibleTaskCount() && this.moveTo(new e.$keyboardNavigation.TaskRow(e.getTaskByIndex(e.getVisibleTaskCount() - 1).id))
                                        },
                                        pageup: function() {
                                            e.getVisibleTaskCount() && this.moveTo(new e.$keyboardNavigation.TaskRow(e.getTaskByIndex(0).id))
                                        },
                                        up: function() {
                                            var i = null
                                                , a = e.getPrev(this.taskId);
                                            i = e.isTaskExists(a) ? new e.$keyboardNavigation.TaskRow(a) : new e.$keyboardNavigation.HeaderCell,
                                                this.moveTo(i)
                                        },
                                        down: function() {
                                            var i = e.getNext(this.taskId);
                                            e.isTaskExists(i) && this.moveTo(new e.$keyboardNavigation.TaskRow(i))
                                        },
                                        "shift+down": function() {
                                            e.hasChild(this.taskId) && !e.getTask(this.taskId).$open && e.open(this.taskId)
                                        },
                                        "shift+up": function() {
                                            e.hasChild(this.taskId) && e.getTask(this.taskId).$open && e.close(this.taskId)
                                        },
                                        "shift+right": function() {
                                            if (!e.isReadonly(this)) {
                                                var i = e.getPrevSibling(this.taskId);
                                                e.isTaskExists(i) && !e.isChildOf(this.taskId, i) && (e.getTask(i).$open = !0,
                                                e.moveTask(this.taskId, -1, i) !== !1 && e.updateTask(this.taskId))
                                            }
                                        },
                                        "shift+left": function() {
                                            if (!e.isReadonly(this)) {
                                                var i = e.getParent(this.taskId);
                                                e.isTaskExists(i) && e.moveTask(this.taskId, e.getTaskIndex(i) + 1, e.getParent(i)) !== !1 && e.updateTask(this.taskId)
                                            }
                                        },
                                        space: function(i) {
                                            e.isSelectedTask(this.taskId) ? e.unselectTask(this.taskId) : e.selectTask(this.taskId)
                                        },
                                        "ctrl+left": function(i) {
                                            e.close(this.taskId)
                                        },
                                        "ctrl+right": function(i) {
                                            e.open(this.taskId)
                                        },
                                        delete: function(i) {
                                            e.isReadonly(this) || e.$click.buttons.delete(this.taskId)
                                        },
                                        enter: function() {
                                            e.isReadonly(this) || e.showLightbox(this.taskId)
                                        },
                                        "ctrl+enter": function() {
                                            e.isReadonly(this) || e.createTask({}, this.taskId)
                                        }
                                    }
                                }),
                                e.$keyboardNavigation.TaskRow.prototype.bindAll(e.$keyboardNavigation.TaskRow.prototype.keys)
                        }(n),
                        function(e) {
                            e.$keyboardNavigation.TaskCell = function(i, a) {
                                if (!(i = ot(i, e.config.root_id))) {
                                    var r = e.getChildren(e.config.root_id);
                                    r[0] && (i = r[0])
                                }
                                this.taskId = i,
                                    this.columnIndex = a || 0,
                                e.isTaskExists(this.taskId) && (this.index = e.getTaskIndex(this.taskId),
                                    this.globalIndex = e.getGlobalTaskIndex(this.taskId))
                            }
                                ,
                                e.$keyboardNavigation.TaskCell.prototype = e._compose(e.$keyboardNavigation.TaskRow, {
                                    _handlers: null,
                                    isValid: function() {
                                        return e.$keyboardNavigation.TaskRow.prototype.isValid.call(this) && !!e.getGridColumns()[this.columnIndex]
                                    },
                                    fallback: function() {
                                        var i = e.$keyboardNavigation.TaskRow.prototype.fallback.call(this)
                                            , a = i;
                                        if (i instanceof e.$keyboardNavigation.TaskRow) {
                                            for (var r = e.getGridColumns(), s = this.columnIndex; s >= 0 && !r[s]; )
                                                s--;
                                            r[s] && (a = new e.$keyboardNavigation.TaskCell(i.taskId,s))
                                        }
                                        return a
                                    },
                                    fromDomElement: function(i) {
                                        if (!e.config.keyboard_navigation_cells)
                                            return null;
                                        var a = e.locate(i);
                                        if (e.isTaskExists(a)) {
                                            var r = 0
                                                , s = Q(i, "data-column-index");
                                            return s && (r = 1 * s.getAttribute("data-column-index")),
                                                new e.$keyboardNavigation.TaskCell(a,r)
                                        }
                                        return null
                                    },
                                    getNode: function() {
                                        if (e.isTaskExists(this.taskId) && (e.isTaskVisible(this.taskId) || e.config.show_tasks_outside_timescale)) {
                                            if (e.config.show_grid && e.$grid) {
                                                var i = e.$grid.querySelector(".gantt_row[" + e.config.task_attribute + "='" + this.taskId + "']");
                                                return i ? i.querySelector("[data-column-index='" + this.columnIndex + "']") : null
                                            }
                                            return e.getTaskNode(this.taskId)
                                        }
                                    },
                                    keys: {
                                        up: function() {
                                            var i = null
                                                , a = e.getPrev(this.taskId);
                                            i = e.isTaskExists(a) ? new e.$keyboardNavigation.TaskCell(a,this.columnIndex) : new e.$keyboardNavigation.HeaderCell(this.columnIndex),
                                                this.moveTo(i)
                                        },
                                        down: function() {
                                            var i = e.getNext(this.taskId);
                                            e.isTaskExists(i) && this.moveTo(new e.$keyboardNavigation.TaskCell(i,this.columnIndex))
                                        },
                                        left: function() {
                                            this.columnIndex > 0 && this.moveTo(new e.$keyboardNavigation.TaskCell(this.taskId,this.columnIndex - 1))
                                        },
                                        right: function() {
                                            var i = e.getGridColumns();
                                            this.columnIndex < i.length - 1 && this.moveTo(new e.$keyboardNavigation.TaskCell(this.taskId,this.columnIndex + 1))
                                        },
                                        end: function() {
                                            var i = e.getGridColumns();
                                            this.moveTo(new e.$keyboardNavigation.TaskCell(this.taskId,i.length - 1))
                                        },
                                        home: function() {
                                            this.moveTo(new e.$keyboardNavigation.TaskCell(this.taskId,0))
                                        },
                                        pagedown: function() {
                                            e.getVisibleTaskCount() && this.moveTo(new e.$keyboardNavigation.TaskCell(e.getTaskByIndex(e.getVisibleTaskCount() - 1).id,this.columnIndex))
                                        },
                                        pageup: function() {
                                            e.getVisibleTaskCount() && this.moveTo(new e.$keyboardNavigation.TaskCell(e.getTaskByIndex(0).id,this.columnIndex))
                                        }
                                    }
                                }),
                                e.$keyboardNavigation.TaskCell.prototype.bindAll(e.$keyboardNavigation.TaskRow.prototype.keys),
                                e.$keyboardNavigation.TaskCell.prototype.bindAll(e.$keyboardNavigation.TaskCell.prototype.keys)
                        }(n),
                        gi(n),
                        function(e) {
                            e.$keyboardNavigation.dispatcher = {
                                isActive: !1,
                                activeNode: null,
                                globalNode: new e.$keyboardNavigation.GanttNode,
                                enable: function() {
                                    this.isActive = !0,
                                        this.setActiveNode(this.getActiveNode())
                                },
                                disable: function() {
                                    this.isActive = !1
                                },
                                isEnabled: function() {
                                    return !!this.isActive
                                },
                                getDefaultNode: function() {
                                    var i;
                                    return (i = e.config.keyboard_navigation_cells ? new e.$keyboardNavigation.TaskCell : new e.$keyboardNavigation.TaskRow).isValid() || (i = i.fallback()),
                                        i
                                },
                                setDefaultNode: function() {
                                    this.setActiveNode(this.getDefaultNode())
                                },
                                getActiveNode: function() {
                                    var i = this.activeNode;
                                    return i && !i.isValid() && (i = i.fallback()),
                                        i
                                },
                                fromDomElement: function(i) {
                                    for (var a = [e.$keyboardNavigation.TaskRow, e.$keyboardNavigation.TaskCell, e.$keyboardNavigation.HeaderCell], r = 0; r < a.length; r++)
                                        if (a[r].prototype.fromDomElement) {
                                            var s = a[r].prototype.fromDomElement(i);
                                            if (s)
                                                return s
                                        }
                                    return null
                                },
                                focusGlobalNode: function() {
                                    this.blurNode(this.globalNode),
                                        this.focusNode(this.globalNode)
                                },
                                setActiveNode: function(i) {
                                    var a = !0;
                                    this.activeNode && this.activeNode.compareTo(i) && (a = !1),
                                    this.isEnabled() && (a && this.blurNode(this.activeNode),
                                        this.activeNode = i,
                                        this.focusNode(this.activeNode, !a))
                                },
                                focusNode: function(i, a) {
                                    i && i.focus && i.focus(a)
                                },
                                blurNode: function(i) {
                                    i && i.blur && i.blur()
                                },
                                keyDownHandler: function(i) {
                                    if (!e.$keyboardNavigation.isModal() && this.isEnabled() && !i.defaultPrevented) {
                                        var a = this.globalNode
                                            , r = e.$keyboardNavigation.shortcuts.getCommandFromEvent(i)
                                            , s = this.getActiveNode();
                                        e.$keyboardNavigation.facade.callEvent("onKeyDown", [r, i]) !== !1 && (s ? s.findHandler(r) ? s.doAction(r, i) : a.findHandler(r) && a.doAction(r, i) : this.setDefaultNode())
                                    }
                                },
                                _timeout: null,
                                awaitsFocus: function() {
                                    return this._timeout !== null
                                },
                                delay: function(i, a) {
                                    clearTimeout(this._timeout),
                                        this._timeout = setTimeout(e.bind(function() {
                                            this._timeout = null,
                                                i()
                                        }, this), a || 1)
                                },
                                clearDelay: function() {
                                    clearTimeout(this._timeout)
                                }
                            }
                        }(n),
                        function() {
                            var e = n.$keyboardNavigation.dispatcher;
                            e.isTaskFocused = function(v) {
                                var b = e.activeNode;
                                return (b instanceof n.$keyboardNavigation.TaskRow || b instanceof n.$keyboardNavigation.TaskCell) && b.taskId == v
                            }
                            ;
                            var i = function(v) {
                                if (n.config.keyboard_navigation && (n.config.keyboard_navigation_cells || !s(v)) && !o(v) && !function(b) {
                                    return !!dt(b.target, ".gantt_cal_light")
                                }(v))
                                    return e.keyDownHandler(v)
                            }
                                , a = function(v) {
                                if (e.$preventDefault)
                                    return v.preventDefault(),
                                        n.$container.blur(),
                                        !1;
                                e.awaitsFocus() || e.focusGlobalNode()
                            }
                                , r = function() {
                                if (!e.isEnabled())
                                    return;
                                const v = !tt(document.activeElement, n.$container) && document.activeElement.localName != "body";
                                var b = e.getActiveNode();
                                if (b && !v) {
                                    var g, m, p = b.getNode();
                                    p && p.parentNode && (g = p.parentNode.scrollTop,
                                        m = p.parentNode.scrollLeft),
                                        b.focus(!0),
                                    p && p.parentNode && (p.parentNode.scrollTop = g,
                                        p.parentNode.scrollLeft = m)
                                }
                            };
                            function s(v) {
                                return !!dt(v.target, ".gantt_grid_editor_placeholder")
                            }
                            function o(v) {
                                return !!dt(v.target, ".no_keyboard_navigation")
                            }
                            function l(v) {
                                if (!n.config.keyboard_navigation || !n.config.keyboard_navigation_cells && s(v))
                                    return !0;
                                if (!o(v)) {
                                    var b, g = e.fromDomElement(v);
                                    if (g && (e.activeNode instanceof n.$keyboardNavigation.TaskCell && tt(v.target, n.$task) && (g = new n.$keyboardNavigation.TaskCell(g.taskId,e.activeNode.columnIndex)),
                                        b = g,
                                    n.config.show_grid && n.$ui.getView("grid") && n.config.keyboard_navigation_cells)) {
                                        const m = v.target.classList.contains("gantt_row")
                                            , p = v.target.closest(".gantt_task_line")
                                            , k = n.utils.dom.getNodePosition(n.$grid).x
                                            , w = k + n.$grid.offsetWidth
                                            , x = n.utils.dom.getNodePosition(document.activeElement).x;
                                        if (m || p && (x < k || w < x)) {
                                            let $ = n.$grid.scrollLeft;
                                            const S = $ + n.$grid.offsetWidth;
                                            let T = 0;
                                            m && ($ = n.utils.dom.getRelativeEventPosition(v, n.$grid).x);
                                            for (let E = 0; E < n.config.columns.length; E++) {
                                                const C = n.config.columns[E];
                                                if (!C.hide && (T += C.width,
                                                $ < T)) {
                                                    S < T && (T -= C.width),
                                                        b.columnIndex = E;
                                                    break
                                                }
                                            }
                                        }
                                    }
                                    b ? e.isEnabled() ? e.delay(function() {
                                        e.setActiveNode(b)
                                    }) : e.activeNode = b : (e.$preventDefault = !0,
                                        setTimeout(function() {
                                            e.$preventDefault = !1
                                        }, 300))
                                }
                            }
                            n.attachEvent("onDataRender", function() {
                                n.config.keyboard_navigation && r()
                            }),
                                n.attachEvent("onGanttRender", function() {
                                    n.$root && (n.eventRemove(n.$root, "keydown", i),
                                        n.eventRemove(n.$container, "focus", a),
                                        n.eventRemove(n.$container, "mousedown", l),
                                        n.config.keyboard_navigation ? (n.event(n.$root, "keydown", i),
                                            n.event(n.$container, "focus", a),
                                            n.event(n.$container, "mousedown", l),
                                            n.$container.setAttribute("tabindex", "0")) : n.$container.removeAttribute("tabindex"))
                                });
                            var d = n.attachEvent("onGanttReady", function() {
                                if (n.detachEvent(d),
                                    n.$data.tasksStore.attachEvent("onStoreUpdated", function(b) {
                                        if (n.config.keyboard_navigation && e.isEnabled()) {
                                            const g = e.getActiveNode()
                                                , m = n.$ui.getView("grid");
                                            if (!m || !m.$grid_data)
                                                return;
                                            const p = m.getItemTop(b)
                                                , k = m.$grid_data.scrollTop
                                                , w = k + m.$grid_data.getBoundingClientRect().height;
                                            g && g.taskId == b && k <= p && w >= p && r()
                                        }
                                    }),
                                    n._smart_render) {
                                    var v = n._smart_render._redrawTasks;
                                    n._smart_render._redrawTasks = function(b, g) {
                                        if (n.config.keyboard_navigation && e.isEnabled()) {
                                            var m = e.getActiveNode();
                                            if (m && m.taskId !== void 0) {
                                                for (var p = !1, k = 0; k < g.length; k++)
                                                    if (g[k].id == m.taskId && g[k].start_date) {
                                                        p = !0;
                                                        break
                                                    }
                                                p || g.push(n.getTask(m.taskId))
                                            }
                                        }
                                        return v.apply(this, arguments)
                                    }
                                }
                            });
                            let c = null
                                , u = !1;
                            n.attachEvent("onTaskCreated", function(v) {
                                return c = v.id,
                                    !0
                            }),
                                n.attachEvent("onAfterTaskAdd", function(v, b) {
                                    if (!n.config.keyboard_navigation)
                                        return !0;
                                    if (e.isEnabled()) {
                                        if (v == c && (u = !0,
                                            setTimeout( () => {
                                                    u = !1,
                                                        c = null
                                                }
                                            )),
                                        u && b.type == n.config.types.placeholder)
                                            return;
                                        var g = 0
                                            , m = e.activeNode;
                                        m instanceof n.$keyboardNavigation.TaskCell && (g = m.columnIndex);
                                        var p = n.config.keyboard_navigation_cells ? n.$keyboardNavigation.TaskCell : n.$keyboardNavigation.TaskRow;
                                        b.type == n.config.types.placeholder && n.config.placeholder_task.focusOnCreate === !1 || e.setActiveNode(new p(v,g))
                                    }
                                }),
                                n.attachEvent("onTaskIdChange", function(v, b) {
                                    if (!n.config.keyboard_navigation)
                                        return !0;
                                    var g = e.activeNode;
                                    return e.isTaskFocused(v) && (g.taskId = b),
                                        !0
                                });
                            var h = setInterval(function() {
                                n.config.keyboard_navigation && (e.isEnabled() || e.enable())
                            }, 500);
                            function _(v) {
                                var b = {
                                    gantt: n.$keyboardNavigation.GanttNode,
                                    headerCell: n.$keyboardNavigation.HeaderCell,
                                    taskRow: n.$keyboardNavigation.TaskRow,
                                    taskCell: n.$keyboardNavigation.TaskCell
                                };
                                return b[v] || b.gantt
                            }
                            function f(v) {
                                for (var b = n.getGridColumns(), g = 0; g < b.length; g++)
                                    if (b[g].name == v)
                                        return g;
                                return 0
                            }
                            n.attachEvent("onDestroy", function() {
                                clearInterval(h)
                            });
                            var y = {};
                            ct(y),
                                n.mixin(y, {
                                    addShortcut: function(v, b, g) {
                                        var m = _(g);
                                        m && m.prototype.bind(v, b)
                                    },
                                    getShortcutHandler: function(v, b) {
                                        var g = n.$keyboardNavigation.shortcuts.parse(v);
                                        if (g.length)
                                            return y.getCommandHandler(g[0], b)
                                    },
                                    getCommandHandler: function(v, b) {
                                        var g = _(b);
                                        if (g && v)
                                            return g.prototype.findHandler(v)
                                    },
                                    removeShortcut: function(v, b) {
                                        var g = _(b);
                                        g && g.prototype.unbind(v)
                                    },
                                    focus: function(v) {
                                        var b, g = v ? v.type : null, m = _(g);
                                        switch (g) {
                                            case "taskCell":
                                                b = new m(v.id,f(v.column));
                                                break;
                                            case "taskRow":
                                                b = new m(v.id);
                                                break;
                                            case "headerCell":
                                                b = new m(f(v.column))
                                        }
                                        e.delay(function() {
                                            b ? e.setActiveNode(b) : (e.enable(),
                                                e.getActiveNode() ? e.awaitsFocus() || e.enable() : e.setDefaultNode())
                                        })
                                    },
                                    getActiveNode: function() {
                                        if (e.isEnabled()) {
                                            var v = e.getActiveNode()
                                                , b = (m = v)instanceof n.$keyboardNavigation.GanttNode ? "gantt" : m instanceof n.$keyboardNavigation.HeaderCell ? "headerCell" : m instanceof n.$keyboardNavigation.TaskRow ? "taskRow" : m instanceof n.$keyboardNavigation.TaskCell ? "taskCell" : null
                                                , g = n.getGridColumns();
                                            switch (b) {
                                                case "taskCell":
                                                    return {
                                                        type: "taskCell",
                                                        id: v.taskId,
                                                        column: g[v.columnIndex].name
                                                    };
                                                case "taskRow":
                                                    return {
                                                        type: "taskRow",
                                                        id: v.taskId
                                                    };
                                                case "headerCell":
                                                    return {
                                                        type: "headerCell",
                                                        column: g[v.index].name
                                                    }
                                            }
                                        }
                                        var m;
                                        return null
                                    }
                                }),
                                n.$keyboardNavigation.facade = y,
                                n.ext.keyboardNavigation = y,
                                n.focus = function() {
                                    y.focus()
                                }
                                ,
                                n.addShortcut = y.addShortcut,
                                n.getShortcutHandler = y.getShortcutHandler,
                                n.removeShortcut = y.removeShortcut
                        }()
                }
            )(t)
        },
        quick_info: function(t) {
            t.ext || (t.ext = {}),
                t.ext.quickInfo = new fi(t),
                t.config.quickinfo_buttons = ["icon_edit", "icon_delete"],
                t.config.quick_info_detached = !0,
                t.config.show_quick_info = !0,
                t.templates.quick_info_title = function(a, r, s) {
                    return s.text.substr(0, 50)
                }
                ,
                t.templates.quick_info_content = function(a, r, s) {
                    return s.details || s.text
                }
                ,
                t.templates.quick_info_date = function(a, r, s) {
                    return t.templates.task_time(a, r, s)
                }
                ,
                t.templates.quick_info_class = function(a, r, s) {
                    return ""
                }
                ,
                t.attachEvent("onTaskClick", function(a, r) {
                    const s = t.utils.dom.closest(r.target, ".gantt_add")
                        , o = t.utils.dom.closest(r.target, ".gantt_close")
                        , l = t.utils.dom.closest(r.target, ".gantt_open");
                    return !s && !o && !l && setTimeout(function() {
                        t.ext.quickInfo.show(a)
                    }, 0),
                        !0
                });
            const n = ["onViewChange", "onLightbox", "onBeforeTaskDelete", "onBeforeDrag"]
                , e = function() {
                return t.ext.quickInfo.hide(),
                    !0
            };
            for (let a = 0; a < n.length; a++)
                t.attachEvent(n[a], e);
            function i() {
                return t.ext.quickInfo.hide(),
                    t.ext.quickInfo._quickInfoBox = null,
                    !0
            }
            t.attachEvent("onEmptyClick", function(a) {
                let r = !0;
                const s = document.querySelector(".gantt_cal_quick_info");
                s && t.utils.dom.isChildOf(a.target, s) && (r = !1),
                r && e()
            }),
                t.attachEvent("onGanttReady", i),
                t.attachEvent("onDestroy", i),
                t.event(window, "keydown", function(a) {
                    a.keyCode === 27 && t.ext.quickInfo.hide()
                }),
                t.showQuickInfo = function() {
                    t.ext.quickInfo.show.apply(t.ext.quickInfo, arguments)
                }
                ,
                t.hideQuickInfo = function() {
                    t.ext.quickInfo.hide.apply(t.ext.quickInfo, arguments)
                }
        },
        tooltip: function(t) {
            t.config.tooltip_timeout = 30,
                t.config.tooltip_offset_y = 20,
                t.config.tooltip_offset_x = 10,
                t.config.tooltip_hide_timeout = 30;
            const n = new vi(t);
            t.ext.tooltips = n,
                t.attachEvent("onGanttReady", function() {
                    t.$root && n.tooltipFor({
                        selector: "[" + t.config.task_attribute + "]:not(.gantt_task_row)",
                        html: e => {
                            if (t.config.touch && !t.config.touch_tooltip)
                                return;
                            const i = t.locate(e);
                            if (t.isTaskExists(i)) {
                                const a = t.getTask(i);
                                return t.templates.tooltip_text(a.start_date, a.end_date, a)
                            }
                            return null
                        }
                        ,
                        global: !1
                    })
                }),
                t.attachEvent("onDestroy", function() {
                    n.destructor()
                }),
                t.attachEvent("onLightbox", function() {
                    n.hideTooltip()
                }),
                t.attachEvent("onBeforeTooltip", function() {
                    if (t.getState().link_source_id)
                        return !1
                }),
                t.attachEvent("onGanttScroll", function() {
                    n.hideTooltip()
                })
        },
        undo: function(t) {
            const n = new yi(t)
                , e = new ki(n,t);
            function i(c, u) {
                return String(c) === String(u)
            }
            function a(c, u, h) {
                c && (i(c.id, u) && (c.id = h),
                i(c.parent, u) && (c.parent = h))
            }
            function r(c, u, h) {
                a(c.value, u, h),
                    a(c.oldValue, u, h)
            }
            function s(c, u, h) {
                c && (i(c.source, u) && (c.source = h),
                i(c.target, u) && (c.target = h))
            }
            function o(c, u, h) {
                s(c.value, u, h),
                    s(c.oldValue, u, h)
            }
            function l(c, u, h) {
                const _ = n;
                for (let f = 0; f < c.length; f++) {
                    const y = c[f];
                    for (let v = 0; v < y.commands.length; v++)
                        y.commands[v].entity === _.command.entity.task ? r(y.commands[v], u, h) : y.commands[v].entity === _.command.entity.link && o(y.commands[v], u, h)
                }
            }
            function d(c, u, h) {
                const _ = n;
                for (let f = 0; f < c.length; f++) {
                    const y = c[f];
                    for (let v = 0; v < y.commands.length; v++) {
                        const b = y.commands[v];
                        b.entity === _.command.entity.link && (b.value && b.value.id === u && (b.value.id = h),
                        b.oldValue && b.oldValue.id === u && (b.oldValue.id = h))
                    }
                }
            }
            t.config.undo = !0,
                t.config.redo = !0,
                t.config.undo_types = {
                    link: "link",
                    task: "task"
                },
                t.config.undo_actions = {
                    update: "update",
                    remove: "remove",
                    add: "add",
                    move: "move"
                },
            t.ext || (t.ext = {}),
                t.ext.undo = {
                    undo: () => n.undo(),
                    redo: () => n.redo(),
                    getUndoStack: () => n.getUndoStack(),
                    setUndoStack: c => n.setUndoStack(c),
                    getRedoStack: () => n.getRedoStack(),
                    setRedoStack: c => n.setRedoStack(c),
                    clearUndoStack: () => n.clearUndoStack(),
                    clearRedoStack: () => n.clearRedoStack(),
                    saveState: (c, u) => e.store(c, u, !0),
                    getInitialState: (c, u) => u === t.config.undo_types.link ? e.getInitialLink(c) : e.getInitialTask(c)
                },
                t.undo = t.ext.undo.undo,
                t.redo = t.ext.undo.redo,
                t.getUndoStack = t.ext.undo.getUndoStack,
                t.getRedoStack = t.ext.undo.getRedoStack,
                t.clearUndoStack = t.ext.undo.clearUndoStack,
                t.clearRedoStack = t.ext.undo.clearRedoStack,
                t.attachEvent("onTaskIdChange", (c, u) => {
                        const h = n;
                        l(h.getUndoStack(), c, u),
                            l(h.getRedoStack(), c, u)
                    }
                ),
                t.attachEvent("onLinkIdChange", (c, u) => {
                        const h = n;
                        d(h.getUndoStack(), c, u),
                            d(h.getRedoStack(), c, u)
                    }
                ),
                t.attachEvent("onGanttReady", () => {
                        n.updateConfigs()
                    }
                )
        },
        grouping: function(t) {
            function n(l, d, c) {
                if (!l || Array.isArray(c) && !c[0])
                    return 0;
                if (l && !Array.isArray(c)) {
                    const h = [];
                    return l.map(function(_) {
                        h.push({
                            resource_id: _,
                            value: 8
                        })
                    }),
                        h
                }
                if (c[0].resource_id || (c = [{
                    resource_id: c,
                    value: 8
                }]),
                typeof l == "string" && (l = l.split(",")),
                l.length == 1)
                    return c[0].resource_id = l[0],
                        [c[0]];
                const u = [];
                l.length > 1 && (l = [...new Set(l)]);
                for (let h = 0; h < l.length; h++) {
                    let _ = l[h]
                        , f = c.map(function(y) {
                        return y.resource_id
                    }).reduce(function(y, v, b) {
                        return v === _ && y.push(b),
                            y
                    }, []);
                    if (f.length > 0)
                        f.forEach(y => {
                                c[y].resource_id = _,
                                    u.push(c[y])
                            }
                        );
                    else {
                        let y = t.copy(c[0]);
                        y.resource_id = _,
                            u.push(y)
                    }
                }
                return u
            }
            function e(l, d, c) {
                return l
            }
            function i(l, d) {
                for (var c = !1, u = !1, h = 0; h < l.length; h++) {
                    var _ = l[h][d];
                    if (Array.isArray(_) && (u = !0,
                    _.length && _[0].resource_id !== void 0)) {
                        c = !0;
                        break
                    }
                }
                return {
                    haveArrays: u,
                    haveResourceAssignments: c
                }
            }
            function a(l) {
                return l.map(r).sort().join(",")
            }
            function r(l) {
                return String(l && typeof l == "object" ? l.resource_id : l)
            }
            function s(l, d) {
                return l[d]instanceof Array ? l[d].length ? a(l[d]) : 0 : l[d]
            }
            function o() {
                const l = this;
                this.$data.tasksStore._listenerToDrop && this.$data.tasksStore.detachEvent(this.$data.tasksStore._listenerToDrop);
                const d = Xt(function() {
                    if (l._groups.is_active() && i(t.getTaskByTime(), l._groups.relation_property).haveArrays && (l._groups.dynamicGroups = !0),
                    l._groups.regroup && t.getScrollState) {
                        const c = t.getScrollState();
                        l._groups.regroup(),
                        c && t.scrollTo(c.x, c.y)
                    }
                    return !0
                });
                this.$data.tasksStore.attachEvent("onAfterUpdate", function() {
                    return d.$pending || d(),
                        !0
                }),
                    t.attachEvent("onParse", function() {
                        d.$pending || l._groups.is_active() && d()
                    })
            }
            t._groups = {
                relation_property: null,
                relation_id_property: "$group_id",
                group_id: null,
                group_text: null,
                loading: !1,
                loaded: 0,
                dynamicGroups: !1,
                set_relation_value: void 0,
                _searchCache: null,
                init: function(l) {
                    var d = this;
                    l.attachEvent("onClear", function() {
                        d.clear()
                    }),
                        d.clear();
                    var c = l.$data.tasksStore.getParent;
                    this._searchCache = null,
                        l.attachEvent("onBeforeTaskMove", function(h, _, f) {
                            var y = _ === this.config.root_id
                                , v = this._groups.dynamicGroups && !(this._groups.set_relation_value instanceof Function);
                            if (d.is_active() && (y || v))
                                return !1;
                            var b = l.getTask(h);
                            if (this._groups.save_tree_structure && l.isTaskExists(b.parent) && l.isTaskExists(_)) {
                                var g = l.getTask(b.parent)
                                    , m = l.getTask(_);
                                m.$virtual && l.isChildOf(g.id, m.id) && (b.parent = l.config.root_id);
                                let p = !1
                                    , k = m;
                                for (; k; )
                                    h == k.parent && (p = !0),
                                        k = l.isTaskExists(k.parent) ? l.getTask(k.parent) : null;
                                if (p)
                                    return !1
                            }
                            return !0
                        }),
                        l.attachEvent("onRowDragStart", function(h, _) {
                            var f = l.getTask(h);
                            return this._groups.save_tree_structure && l.isTaskExists(f.parent) && l.config.order_branch && l.config.order_branch != "marker" && (f.$initial_parent = f.parent),
                                !0
                        }),
                        l.attachEvent("onRowDragEnd", function(h, _) {
                            if (l.config.order_branch && l.config.order_branch != "marker") {
                                var f = l.getTask(h);
                                if (f.$initial_parent) {
                                    if (f.parent == l.config.root_id) {
                                        var y = l.getTask(f.$rendered_parent)
                                            , v = l.getTask(f.$initial_parent)
                                            , b = !1;
                                        this._groups.dynamicGroups && y[this._groups.group_id] != v[this._groups.group_id] && (b = !0),
                                        this._groups.dynamicGroups || y[this._groups.group_id] == v[this._groups.relation_property] || (b = !0),
                                        b && (f.parent = f.$initial_parent)
                                    }
                                    delete f.$initial_parent
                                }
                            }
                        }),
                        l.$data.tasksStore._listenerToDrop = l.$data.tasksStore.attachEvent("onStoreUpdated", l.bind(o, l)),
                        l.$data.tasksStore.getParent = function(h) {
                            return d.is_active() ? d.get_parent(l, h) : c.apply(this, arguments)
                        }
                    ;
                    var u = l.$data.tasksStore.setParent;
                    l.$data.tasksStore.setParent = function(h, _) {
                        if (!d.is_active())
                            return u.apply(this, arguments);
                        if (d.set_relation_value instanceof Function && l.isTaskExists(_)) {
                            var f = (b = l.getTask(_))[d.relation_id_property];
                            if (!b.$virtual) {
                                var y = s(b, d.relation_property);
                                d._searchCache || d._buildCache();
                                var v = d._searchCache[y];
                                f = l.getTask(v)[d.relation_id_property]
                            }
                            h[d.group_id] === void 0 && (h[d.group_id] = f),
                            d.save_tree_structure && h[d.group_id] != f && (h[d.group_id] = f),
                            f && (f = typeof f == "string" ? f.split(",") : [f]),
                                h[d.relation_property] = d.set_relation_value(f, h.id, h[d.relation_property]) || f
                        } else if (l.isTaskExists(_)) {
                            var b = l.getTask(_);
                            d.dynamicGroups || (b.$virtual ? h[d.relation_property] = b[d.relation_id_property] : h[d.relation_property] = b[d.relation_property]),
                                this._setParentInner.apply(this, arguments)
                        } else
                            d.dynamicGroups && (h[d.group_id] === void 0 || !h.$virtual && h[d.relation_property][0] === [][0]) && (h[d.relation_property] !== d.group_id ? h[d.relation_property] = h[d.relation_property] || 0 : h[d.relation_property] = 0);
                        return l.isTaskExists(_) && (h.$rendered_parent = _,
                            !l.getTask(_).$virtual) ? u.apply(this, arguments) || _ : void 0
                    }
                        ,
                        l.attachEvent("onBeforeTaskDisplay", function(h, _) {
                            return !(d.is_active() && _.type == l.config.types.project && !_.$virtual)
                        }),
                        l.attachEvent("onBeforeParse", function() {
                            d.loading = !0,
                                d._clearCache()
                        }),
                        l.attachEvent("onTaskLoading", function() {
                            return d.is_active() && (d.loaded--,
                            d.loaded <= 0 && (d.loading = !1,
                                d._clearCache(),
                                l.eachTask(l.bind(function(h) {
                                    this.get_parent(l, h)
                                }, d)))),
                                !0
                        }),
                        l.attachEvent("onParse", function() {
                            d.loading = !1,
                                d.loaded = 0
                        })
                },
                _clearCache: function() {
                    this._searchCache = null
                },
                _buildCache: function() {
                    this._searchCache = {};
                    for (var l = t.$data.tasksStore.getItems(), d = 0; d < l.length; d++)
                        this._searchCache[l[d][this.relation_id_property]] = l[d].id
                },
                get_parent: function(l, d, c) {
                    d.id === void 0 && (d = l.getTask(d));
                    var u = s(d, this.relation_property);
                    if (this.save_tree_structure && l.isTaskExists(d.parent)) {
                        let f = l.getTask(d.parent);
                        const y = s(f, this.relation_property);
                        if (f.type != "project" && u == y)
                            return d.parent
                    }
                    if (this._groups_pull[u] === d.id)
                        return l.config.root_id;
                    if (this._groups_pull[u] !== void 0)
                        return this._groups_pull[u];
                    var h = l.config.root_id;
                    if (!this.loading && u !== void 0) {
                        this._searchCache || this._buildCache();
                        var _ = this._searchCache[u];
                        l.isTaskExists(_) && _ != d.id && (h = this._searchCache[u]),
                            this._groups_pull[u] = h
                    }
                    return h
                },
                clear: function() {
                    this._groups_pull = {},
                        this.relation_property = null,
                        this.group_id = null,
                        this.group_text = null,
                        this._clearCache()
                },
                is_active: function() {
                    return !!this.relation_property
                },
                generate_sections: function(l, d) {
                    for (var c = [], u = 0; u < l.length; u++) {
                        var h = t.copy(l[u]);
                        h.type = d,
                        h.open === void 0 && (h.open = !0),
                            h.$virtual = !0,
                            h.readonly = !0,
                            h[this.relation_id_property] = h[this.group_id],
                            h.text = h[this.group_text],
                            c.push(h)
                    }
                    return c
                },
                clear_temp_tasks: function(l) {
                    for (var d = 0; d < l.length; d++)
                        l[d].$virtual && (l.splice(d, 1),
                            d--)
                },
                generate_data: function(l, d) {
                    var c = l.getLinks()
                        , u = l.getTaskByTime();
                    this.clear_temp_tasks(u),
                        u.forEach(function(f) {
                            f.$calculate_duration = !1
                        });
                    var h = [];
                    this.is_active() && d && d.length && (h = this.generate_sections(d, l.config.types.project));
                    var _ = {
                        links: c
                    };
                    return _.data = h.concat(u),
                        _
                },
                update_settings: function(l, d, c) {
                    this.clear(),
                        this.relation_property = l,
                        this.group_id = d,
                        this.group_text = c
                },
                group_tasks: function(l, d, c, u, h) {
                    this.update_settings(c, u, h);
                    var _ = this.generate_data(l, d);
                    this.loaded = _.data.length;
                    var f = [];
                    l.eachTask(function(v) {
                        l.isSelectedTask(v.id) && f.push(v.id)
                    }),
                        l._clear_data();
                    var y = l.config.auto_scheduling_initial;
                    l.config.auto_scheduling_initial = !1,
                        l.parse(_),
                        f.forEach(function(v) {
                            l.isTaskExists(v) && l.selectTask(v)
                        }),
                        l.config.auto_scheduling_initial = y
                }
            },
                t._groups.init(t),
                t.groupBy = function(l) {
                    var d = this
                        , c = t.getTaskByTime();
                    this._groups.set_relation_value = l.set_relation_value,
                        this._groups.dynamicGroups = !1,
                        this._groups.save_tree_structure = l.save_tree_structure;
                    var u = i(c, l.relation_property);
                    u.haveArrays && (this._groups.dynamicGroups = !0),
                    this._groups.set_relation_value || (this._groups.set_relation_value = function(y) {
                        return y.haveResourceAssignments ? n : y.haveArrays ? e : null
                    }(u)),
                        (l = l || {}).default_group_label = l.default_group_label || this.locale.labels.default_group || "None";
                    var h = l.relation_property || null
                        , _ = l.group_id || "key"
                        , f = l.group_text || "label";
                    this._groups.regroup = function() {
                        var y = t.getTaskByTime()
                            , v = {}
                            , b = !1;
                        y.forEach(function(m) {
                            m.$virtual && m.$open !== void 0 && (v[m[_]] = m.$open,
                                b = !0)
                        });
                        var g = function(m, p, k) {
                            var w;
                            return w = m.groups ? k._groups.dynamicGroups ? function(x, $) {
                                var S = {}
                                    , T = []
                                    , E = {}
                                    , C = $.relation_property
                                    , D = $.delimiter || ","
                                    , A = !1
                                    , I = 0;
                                st($.groups, function(R) {
                                    R.default && (A = !0,
                                        I = R.group_id),
                                        E[R.key || R[$.group_id]] = R
                                });
                                for (var M = 0; M < x.length; M++) {
                                    var L, N, P = x[M][C];
                                    if (Lt(P))
                                        if (P.length > 0)
                                            L = a(P),
                                                N = P.map(function(R, B) {
                                                    var H;
                                                    return H = R && typeof R == "object" ? R.resource_id : R,
                                                    (R = E[H]).label || R.text
                                                }).sort(),
                                                N = [...new Set(N)].join(D);
                                        else {
                                            if (A)
                                                continue;
                                            L = 0,
                                                N = $.default_group_label
                                        }
                                    else if (P)
                                        N = E[L = P].label || E[L].text;
                                    else {
                                        if (A)
                                            continue;
                                        L = 0,
                                            N = $.default_group_label
                                    }
                                    L !== void 0 && S[L] === void 0 && (S[L] = {
                                        key: L,
                                        label: N
                                    },
                                    L === I && (S[L].default = !0),
                                        S[L][$.group_text] = N,
                                        S[L][$.group_id] = L)
                                }
                                return (T = function(R) {
                                    var B = [];
                                    for (var H in R)
                                        R.hasOwnProperty(H) && B.push(R[H]);
                                    return B
                                }(S)).forEach(function(R) {
                                    R.key == I && (R.default = !0)
                                }),
                                    T
                            }(p, m) : m.groups : null,
                                w
                        }(l, y, t);
                        return g && b && g.forEach(function(m) {
                            v[m[_]] !== void 0 && (m.open = v[m[_]])
                        }),
                            d._groups.group_tasks(d, g, h, _, f),
                            !0
                    }
                        ,
                        this._groups.regroup()
                }
                ,
                t.$services.getService("state").registerProvider("groupBy", function() {
                    return {
                        group_mode: t._groups.is_active() ? t._groups.relation_property : null
                    }
                })
        },
        marker: function(t) {
            function n(i) {
                if (!t.config.show_markers || !i.start_date)
                    return !1;
                var a = t.getState();
                if (+i.start_date > +a.max_date || (!i.end_date || +i.end_date < +a.min_date) && +i.start_date < +a.min_date)
                    return;
                var r = document.createElement("div");
                r.setAttribute("data-marker-id", i.id);
                var s = "gantt_marker";
                t.templates.marker_class && (s += " " + t.templates.marker_class(i)),
                i.css && (s += " " + i.css),
                t.templates.marker_class && (s += " " + t.templates.marker_class(i)),
                i.title && (r.title = i.title),
                    r.className = s;
                var o = t.posFromDate(i.start_date);
                r.style.left = o + "px";
                let l = Math.max(t.getRowTop(t.getVisibleTaskCount()), 0) + "px";
                if (t.config.timeline_placeholder && t.$task_data && (l = t.$task_data.scrollHeight + "px"),
                    r.style.height = l,
                    i.end_date) {
                    var d = t.posFromDate(i.end_date);
                    r.style.width = Math.max(d - o, 0) + "px"
                }
                if (i.text) {
                    let c = null;
                    c = typeof i.text == "function" ? i.text(i) : i.text,
                    c && (t.config.external_render && t.config.external_render.isElement(c) ? (r.innerHTML = "<div class='gantt_marker_content' ></div>",
                        t.config.external_render.renderElement(c, r.querySelector(".gantt_marker_content"))) : r.innerHTML = "<div class='gantt_marker_content' >" + i.text + "</div>")
                }
                return r
            }
            function e() {
                if (t.$task_data && t.$root.contains(t.$task_data)) {
                    if (!t.$marker_area || !t.$task_data.contains(t.$marker_area)) {
                        var i = document.createElement("div");
                        i.className = "gantt_marker_area",
                            t.$task_data.appendChild(i),
                            t.$marker_area = i
                    }
                } else
                    t.$marker_area = null
            }
            t._markers || (t._markers = t.createDatastore({
                name: "marker",
                initItem: function(i) {
                    return i.id = i.id || t.uid(),
                        i
                }
            })),
                t.config.show_markers = !0,
                t.attachEvent("onBeforeGanttRender", function() {
                    t.$marker_area || e()
                }),
                t.attachEvent("onDataRender", function() {
                    t.$marker_area || (e(),
                        t.renderMarkers())
                }),
                t.attachEvent("onGanttLayoutReady", function() {
                    t.attachEvent("onBeforeGanttRender", function() {
                        t.$marker_area && (t.$marker_area.innerHTML = ""),
                            e(),
                            t.$services.getService("layers").createDataRender({
                                name: "marker",
                                defaultContainer: function() {
                                    return t.$marker_area
                                }
                            }).addLayer(n)
                    }, {
                        once: !0
                    })
                }),
                t.getMarker = function(i) {
                    return this._markers ? this._markers.getItem(i) : null
                }
                ,
                t.addMarker = function(i) {
                    return this._markers.addItem(i)
                }
                ,
                t.deleteMarker = function(i) {
                    return !!this._markers.exists(i) && (this._markers.removeItem(i),
                        !0)
                }
                ,
                t.updateMarker = function(i) {
                    this._markers.refresh(i)
                }
                ,
                t._getMarkers = function() {
                    return this._markers.getItems()
                }
                ,
                t.renderMarkers = function() {
                    this._markers.refresh()
                }
        },
        multiselect: function(t) {
            t.config.multiselect = !0,
                t.config.multiselect_one_level = !1,
                t._multiselect = {
                    _selected: {},
                    _one_level: !1,
                    _active: !0,
                    _first_selected_when_shift: null,
                    getDefaultSelected: function() {
                        var n = this.getSelected();
                        return n.length ? n[n.length - 1] : null
                    },
                    setFirstSelected: function(n) {
                        this._first_selected_when_shift = n
                    },
                    getFirstSelected: function() {
                        return this._first_selected_when_shift
                    },
                    isActive: function() {
                        return this.updateState(),
                            this._active
                    },
                    updateState: function() {
                        this._one_level = t.config.multiselect_one_level;
                        var n = this._active;
                        this._active = t.config.select_task,
                        this._active != n && this.reset()
                    },
                    reset: function() {
                        this._selected = {}
                    },
                    setLastSelected: function(n) {
                        t.$data.tasksStore.silent(function() {
                            var e = t.$data.tasksStore;
                            n ? e.select(n + "") : e.unselect(null)
                        })
                    },
                    getLastSelected: function() {
                        var n = t.$data.tasksStore.getSelectedId();
                        return n && t.isTaskExists(n) ? n : null
                    },
                    select: function(n, e) {
                        return !!(n && t.callEvent("onBeforeTaskMultiSelect", [n, !0, e]) && t.callEvent("onBeforeTaskSelected", [n])) && (this._selected[n] = !0,
                            this.setLastSelected(n),
                            this.afterSelect(n),
                            t.callEvent("onTaskMultiSelect", [n, !0, e]),
                            t.callEvent("onTaskSelected", [n]),
                            !0)
                    },
                    toggle: function(n, e) {
                        this._selected[n] ? this.unselect(n, e) : this.select(n, e)
                    },
                    unselect: function(n, e) {
                        n && t.callEvent("onBeforeTaskMultiSelect", [n, !1, e]) && (this._selected[n] = !1,
                        this.getLastSelected() == n && this.setLastSelected(this.getDefaultSelected()),
                            this.afterSelect(n),
                            t.callEvent("onTaskMultiSelect", [n, !1, e]),
                            t.callEvent("onTaskUnselected", [n]))
                    },
                    isSelected: function(n) {
                        return !(!t.isTaskExists(n) || !this._selected[n])
                    },
                    getSelected: function() {
                        var n = [];
                        for (var e in this._selected)
                            this._selected[e] && t.isTaskExists(e) ? n.push(e) : this._selected[e] = !1;
                        return n.sort(function(i, a) {
                            return t.getGlobalTaskIndex(i) > t.getGlobalTaskIndex(a) ? 1 : -1
                        }),
                            n
                    },
                    forSelected: function(n) {
                        for (var e = this.getSelected(), i = 0; i < e.length; i++)
                            n(e[i])
                    },
                    isSameLevel: function(n) {
                        if (!this._one_level)
                            return !0;
                        var e = this.getLastSelected();
                        return !e || !t.isTaskExists(e) || !t.isTaskExists(n) || t.calculateTaskLevel(t.getTask(e)) == t.calculateTaskLevel(t.getTask(n))
                    },
                    afterSelect: function(n) {
                        t.isTaskExists(n) && t._quickRefresh(function() {
                            t.refreshTask(n)
                        })
                    },
                    doSelection: function(n) {
                        if (!this.isActive() || t._is_icon_open_click(n))
                            return !1;
                        var e = t.locate(n);
                        if (!e || !t.callEvent("onBeforeMultiSelect", [n]))
                            return !1;
                        var i = this.getSelected()
                            , a = this.getFirstSelected()
                            , r = !1
                            , s = this.getLastSelected()
                            , o = t.config.multiselect
                            , l = (function() {
                                const c = t.ext.inlineEditors;
                                if (c && c.getState) {
                                    const h = c.getState()
                                        , _ = c.locateCell(n.target);
                                    t.config.inline_editors_multiselect_open && _ && c.getEditorConfig(_.columnName) && (c.isVisible() && h.id == _.id && h.columnName == _.columnName || c.startEdit(_.id, _.columnName))
                                }
                                this.setFirstSelected(e),
                                this.isSelected(e) || this.select(e, n),
                                    i = this.getSelected();
                                for (var u = 0; u < i.length; u++)
                                    i[u] !== e && this.unselect(i[u], n)
                            }
                        ).bind(this)
                            , d = (function() {
                                if (s) {
                                    if (e) {
                                        var c = t.getGlobalTaskIndex(this.getFirstSelected())
                                            , u = t.getGlobalTaskIndex(e)
                                            , h = t.getGlobalTaskIndex(s);
                                        c != -1 && h != -1 || (c = u,
                                            this.reset());
                                        for (var _ = s; t.getGlobalTaskIndex(_) !== c; )
                                            this.unselect(_, n),
                                                _ = c > h ? t.getNext(_) : t.getPrev(_);
                                        for (_ = e; t.getGlobalTaskIndex(_) !== c; )
                                            this.select(_, n) && !r && (r = !0,
                                                a = _),
                                                _ = c > u ? t.getNext(_) : t.getPrev(_)
                                    }
                                } else
                                    s = e
                            }
                        ).bind(this);
                        return o && (n.ctrlKey || n.metaKey) ? (this.isSelected(e) || this.setFirstSelected(e),
                        e && this.toggle(e, n)) : o && n.shiftKey ? (t.isTaskExists(this.getFirstSelected()) && this.getFirstSelected() !== null || this.setFirstSelected(e),
                            i.length ? d() : l()) : l(),
                            this.isSelected(e) ? this.setLastSelected(e) : a ? e == s && this.setLastSelected(n.shiftKey ? a : this.getDefaultSelected()) : this.setLastSelected(null),
                        this.getSelected().length || this.setLastSelected(null),
                        this.getLastSelected() && this.isSelected(this.getFirstSelected()) || this.setFirstSelected(this.getLastSelected()),
                            !0
                    }
                },
                function() {
                    var n = t.selectTask;
                    t.selectTask = function(i) {
                        if (!(i = ot(i, this.config.root_id)))
                            return !1;
                        var a = t._multiselect
                            , r = i;
                        return a.isActive() ? (a.select(i, null) && a.setLastSelected(i),
                            a.setFirstSelected(a.getLastSelected())) : r = n.call(this, i),
                            r
                    }
                    ;
                    var e = t.unselectTask;
                    t.unselectTask = function(i) {
                        var a = t._multiselect
                            , r = a.isActive();
                        (i = i || a.getLastSelected()) && r && (a.unselect(i, null),
                        i == a.getLastSelected() && a.setLastSelected(null),
                            t.refreshTask(i),
                            a.setFirstSelected(a.getLastSelected()));
                        var s = i;
                        return r || (s = e.call(this, i)),
                            s
                    }
                        ,
                        t.toggleTaskSelection = function(i) {
                            var a = t._multiselect;
                            i && a.isActive() && (a.toggle(i),
                                a.setFirstSelected(a.getLastSelected()))
                        }
                        ,
                        t.getSelectedTasks = function() {
                            var i = t._multiselect;
                            return i.isActive(),
                                i.getSelected()
                        }
                        ,
                        t.eachSelectedTask = function(i) {
                            return this._multiselect.forSelected(i)
                        }
                        ,
                        t.isSelectedTask = function(i) {
                            return this._multiselect.isSelected(i)
                        }
                        ,
                        t.getLastSelectedTask = function() {
                            return this._multiselect.getLastSelected()
                        }
                        ,
                        t.attachEvent("onGanttReady", function() {
                            var i = t.$data.tasksStore.isSelected;
                            t.$data.tasksStore.isSelected = function(a) {
                                return t._multiselect.isActive() ? t._multiselect.isSelected(a) : i.call(this, a)
                            }
                        })
                }(),
                t.attachEvent("onTaskIdChange", function(n, e) {
                    var i = t._multiselect;
                    if (!i.isActive())
                        return !0;
                    t.isSelectedTask(n) && (i.unselect(n, null),
                        i.select(e, null))
                }),
                t.attachEvent("onAfterTaskDelete", function(n, e) {
                    var i = t._multiselect;
                    if (!i.isActive())
                        return !0;
                    i._selected[n] && (i._selected[n] = !1,
                        i.setLastSelected(i.getDefaultSelected())),
                        i.forSelected(function(a) {
                            t.isTaskExists(a) || i.unselect(a, null)
                        })
                }),
                t.attachEvent("onBeforeTaskMultiSelect", function(n, e, i) {
                    const a = t._multiselect;
                    if (e && a.isActive()) {
                        let r = t.getSelectedId()
                            , s = null;
                        r && (s = t.getTask(r));
                        let o = t.getTask(n)
                            , l = !1;
                        if (s && s.$level != o.$level && (l = !0),
                        t.config.multiselect_one_level && l && !i.ctrlKey && !i.shiftKey)
                            return !0;
                        if (a._one_level)
                            return a.isSameLevel(n)
                    }
                    return !0
                }),
                t.attachEvent("onTaskClick", function(n, e) {
                    return t._multiselect.doSelection(e) && t.callEvent("onMultiSelect", [e]),
                        !0
                })
        },
        overlay: function(t) {
            t.ext || (t.ext = {}),
                t.ext.overlay = {};
            var n = {};
            function e() {
                if (t.$task_data) {
                    t.event(t.$task_data, "scroll", function(l) {
                        t.ext.$overlay_area && (t.ext.$overlay_area.style.top = l.target.scrollTop + "px")
                    });
                    var o = document.createElement("div");
                    o.className = "gantt_overlay_area",
                        t.$task_data.appendChild(o),
                        t.ext.$overlay_area = o,
                        i()
                }
            }
            function i() {
                for (var o in n) {
                    var l = n[o];
                    l.isAttached || a(l)
                }
            }
            function a(o) {
                t.ext.$overlay_area.appendChild(o.node),
                    o.isAttached = !0
            }
            function r() {
                t.ext.$overlay_area.style.display = "block"
            }
            function s() {
                var o = !1;
                for (var l in n)
                    if (n[l].isVisible) {
                        o = !0;
                        break
                    }
                o || (t.ext.$overlay_area.style.display = "none")
            }
            t.attachEvent("onBeforeGanttRender", function() {
                if (t.$root) {
                    if (t.ext.$overlay_area || e(),
                        !t.ext.$overlay_area.isConnected)
                        for (var o in t.ext.$overlay_area.innerHTML = "",
                            t.ext.$overlay_area.remove(),
                            t.ext.$overlay_area = null,
                            e(),
                            n)
                            n[o].isAttached = !1;
                    i(),
                        s()
                }
            }),
                t.attachEvent("onGanttReady", function() {
                    t.$root && (e(),
                        i(),
                        s())
                }),
                t.ext.overlay.addOverlay = function(o, l) {
                    return l = l || t.uid(),
                        n[l] = function(d, c) {
                            var u = document.createElement("div");
                            return u.setAttribute("data-overlay-id", d),
                                u.className = "gantt_overlay",
                                u.style.display = "none",
                                {
                                    id: d,
                                    render: c,
                                    isVisible: !1,
                                    isAttached: !1,
                                    node: u
                                }
                        }(l, o),
                        l
                }
                ,
                t.ext.overlay.deleteOverlay = function(o) {
                    return !!n[o] && (delete n[o],
                        s(),
                        !0)
                }
                ,
                t.ext.overlay.getOverlaysIds = function() {
                    var o = [];
                    for (var l in n)
                        o.push(l);
                    return o
                }
                ,
                t.ext.overlay.refreshOverlay = function(o) {
                    r(),
                        n[o].isVisible = !0,
                        n[o].node.innerHTML = "",
                        n[o].node.style.display = "block",
                        n[o].render(n[o].node)
                }
                ,
                t.ext.overlay.showOverlay = function(o) {
                    r(),
                        this.refreshOverlay(o)
                }
                ,
                t.ext.overlay.hideOverlay = function(o) {
                    n[o].isVisible = !1,
                        n[o].node.style.display = "none",
                        s()
                }
                ,
                t.ext.overlay.isOverlayVisible = function(o) {
                    return !!o && n[o].isVisible
                }
        },
        export_api: function(t) {
            return t.ext = t.ext || {},
                t.ext.export_api = t.ext.export_api || {
                    _apiUrl: "https://export.dhtmlx.com/gantt",
                    _preparePDFConfigRaw(n, e) {
                        let i = null;
                        n.start && n.end && (i = {
                            start_date: t.config.start_date,
                            end_date: t.config.end_date
                        },
                            t.config.start_date = t.date.str_to_date(t.config.date_format)(n.start),
                            t.config.end_date = t.date.str_to_date(t.config.date_format)(n.end)),
                            n = t.mixin(n, {
                                name: "gantt." + e,
                                data: t.ext.export_api._serializeHtml()
                            }),
                        i && (t.config.start_date = i.start_date,
                            t.config.end_date = i.end_date)
                    },
                    _prepareConfigPDF: (n, e) => (n = t.mixin(n || {}, {
                        name: "gantt." + e,
                        data: t.ext.export_api._serializeAll(),
                        config: t.config
                    }),
                        t.ext.export_api._fixColumns(n.config.columns),
                        n),
                    _pdfExportRouter(n, e) {
                        n && n.raw ? t.ext.export_api._preparePDFConfigRaw(n, e) : n = t.ext.export_api._prepareConfigPDF(n, e),
                            n.version = t.version,
                            t.ext.export_api._sendToExport(n, e)
                    },
                    exportToPDF(n) {
                        t.ext.export_api._pdfExportRouter(n, "pdf")
                    },
                    exportToPNG(n) {
                        t.ext.export_api._pdfExportRouter(n, "png")
                    },
                    exportToICal(n) {
                        n = t.mixin(n || {}, {
                            name: "gantt.ical",
                            data: t.ext.export_api._serializePlain().data,
                            version: t.version
                        }),
                            t.ext.export_api._sendToExport(n, "ical")
                    },
                    exportToExcel(n) {
                        let e, i, a, r;
                        n = n || {};
                        const s = t.config.smart_rendering;
                        if (n.visual === "base-colors" && (t.config.smart_rendering = !1),
                        n.start || n.end) {
                            a = t.getState(),
                                i = [t.config.start_date, t.config.end_date],
                                r = t.getScrollState();
                            const o = t.date.str_to_date(t.config.date_format);
                            e = t.eachTask,
                            n.start && (t.config.start_date = o(n.start)),
                            n.end && (t.config.end_date = o(n.end)),
                                t.render(),
                                t.config.smart_rendering = s,
                                t.eachTask = t.ext.export_api._eachTaskTimed(t.config.start_date, t.config.end_date)
                        } else
                            n.visual === "base-colors" && (t.render(),
                                t.config.smart_rendering = s);
                        t._no_progress_colors = n.visual === "base-colors",
                        (n = t.mixin(n, {
                            name: "gantt.xlsx",
                            title: "Tasks",
                            data: t.ext.export_api._serializeTimeline(n).data,
                            columns: t.ext.export_api._serializeGrid({
                                rawDates: !0
                            }),
                            version: t.version
                        })).visual && (n.scales = t.ext.export_api._serializeScales(n)),
                            t.ext.export_api._sendToExport(n, "excel"),
                        (n.start || n.end) && (t.config.start_date = a.min_date,
                            t.config.end_date = a.max_date,
                            t.eachTask = e,
                            t.render(),
                            t.scrollTo(r.x, r.y),
                            t.config.start_date = i[0],
                            t.config.end_date = i[1])
                    },
                    exportToJSON(n) {
                        n = t.mixin(n || {}, {
                            name: "gantt.json",
                            data: t.ext.export_api._serializeAll(),
                            config: t.config,
                            columns: t.ext.export_api._serializeGrid(),
                            worktime: t.ext.export_api._getWorktimeSettings(),
                            version: t.version
                        }),
                            t.ext.export_api._sendToExport(n, "json")
                    },
                    importFromExcel(n) {
                        try {
                            const e = n.data;
                            if (e instanceof File) {
                                const i = new FormData;
                                i.append("file", e),
                                    n.data = i
                            }
                        } catch {}
                        t.ext.export_api._sendImportAjaxExcel(n)
                    },
                    importFromMSProject(n) {
                        const e = n.data;
                        try {
                            if (e instanceof File) {
                                const i = new FormData;
                                i.append("file", e),
                                    n.data = i
                            }
                        } catch {}
                        t.ext.export_api._sendImportAjaxMSP(n)
                    },
                    importFromPrimaveraP6: n => (n.type = "primaveraP6-parse",
                        t.importFromMSProject(n)),
                    exportToMSProject(n) {
                        (n = n || {}).skip_circular_links = n.skip_circular_links === void 0 || !!n.skip_circular_links;
                        const e = t.templates.xml_format
                            , i = t.templates.format_date
                            , a = t.config.xml_date
                            , r = t.config.date_format
                            , s = "%d-%m-%Y %H:%i:%s";
                        t.config.xml_date = s,
                            t.config.date_format = s,
                            t.templates.xml_format = t.date.date_to_str(s),
                            t.templates.format_date = t.date.date_to_str(s);
                        const o = t.ext.export_api._serializeAll();
                        t.ext.export_api._customProjectProperties(o, n),
                            t.ext.export_api._customTaskProperties(o, n),
                        n.skip_circular_links && t.ext.export_api._clearRecLinks(o),
                            n = t.ext.export_api._exportConfig(o, n),
                            t.ext.export_api._sendToExport(n, n.type || "msproject"),
                            t.config.xml_date = a,
                            t.config.date_format = r,
                            t.templates.xml_format = e,
                            t.templates.format_date = i,
                            t.config.$custom_data = null,
                            t.config.custom = null
                    },
                    exportToPrimaveraP6: n => ((n = n || {}).type = "primaveraP6",
                        t.exportToMSProject(n)),
                    _fixColumns(n) {
                        for (let e = 0; e < n.length; e++)
                            n[e].label = n[e].label || t.locale.labels["column_" + n[e].name],
                            typeof n[e].width == "string" && (n[e].width = 1 * n[e].width)
                    },
                    _xdr(n, e, i) {
                        t.ajax.post(n, e, i)
                    },
                    _markColumns(n) {
                        const e = n.config.columns;
                        if (e)
                            for (let i = 0; i < e.length; i++)
                                e[i].template && (e[i].$template = !0)
                    },
                    _sendImportAjaxExcel(n) {
                        const e = n.server || t.ext.export_api._apiUrl
                            , i = n.store || 0
                            , a = n.data
                            , r = n.callback;
                        a.append("type", "excel-parse"),
                            a.append("data", JSON.stringify({
                                sheet: n.sheet || 0
                            })),
                        i && a.append("store", i);
                        const s = new XMLHttpRequest;
                        s.onreadystatechange = function(o) {
                            s.readyState === 4 && s.status === 0 && r && r(null)
                        }
                            ,
                            s.onload = function() {
                                let o = null;
                                if (!(s.status > 400))
                                    try {
                                        o = JSON.parse(s.responseText)
                                    } catch {}
                                r && r(o)
                            }
                            ,
                            s.open("POST", e, !0),
                            s.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
                            s.send(a)
                    },
                    _ajaxToExport(n, e, i) {
                        delete n.callback;
                        const a = n.server || t.ext.export_api._apiUrl
                            , r = "type=" + e + "&store=1&data=" + encodeURIComponent(JSON.stringify(n));
                        t.ext.export_api._xdr(a, r, function(s) {
                            const o = s.xmlDoc || s;
                            let l = null;
                            if (!(o.status > 400))
                                try {
                                    l = JSON.parse(o.responseText)
                                } catch {}
                            i(l)
                        })
                    },
                    _serializableGanttConfig(n) {
                        const e = t.mixin({}, n);
                        return e.columns && (e.columns = e.columns.map(function(i) {
                            const a = t.mixin({}, i);
                            return delete a.editor,
                                a
                        })),
                            delete e.editor_types,
                            e
                    },
                    _sendToExport(n, e) {
                        const i = t.date.date_to_str(t.config.date_format || t.config.xml_date);
                        if (n.skin || (n.skin = t.skin),
                        n.config && (n.config = t.copy(t.ext.export_api._serializableGanttConfig(n.config)),
                            t.ext.export_api._markColumns(n, e),
                        n.config.start_date && n.config.end_date && (n.config.start_date instanceof Date && (n.config.start_date = i(n.config.start_date)),
                        n.config.end_date instanceof Date && (n.config.end_date = i(n.config.end_date)))),
                            n.callback)
                            return t.ext.export_api._ajaxToExport(n, e, n.callback);
                        const a = t.ext.export_api._createHiddenForm();
                        a.firstChild.action = n.server || t.ext.export_api._apiUrl,
                            a.firstChild.childNodes[0].value = JSON.stringify(n),
                            a.firstChild.childNodes[1].value = e,
                            a.firstChild.submit()
                    },
                    _createHiddenForm() {
                        if (!t.ext.export_api._hidden_export_form) {
                            const n = t.ext.export_api._hidden_export_form = document.createElement("div");
                            n.style.display = "none",
                                n.innerHTML = "<form method='POST' target='_blank'><textarea name='data' style='width:0px; height:0px;' readonly='true'></textarea><input type='hidden' name='type' value=''></form>",
                                document.body.appendChild(n)
                        }
                        return t.ext.export_api._hidden_export_form
                    },
                    _copyObjectBase(n) {
                        const e = {
                            start_date: void 0,
                            end_date: void 0,
                            constraint_date: void 0,
                            deadline: void 0
                        };
                        for (const a in n)
                            a.charAt(0) !== "$" && a !== "baselines" && (e[a] = n[a]);
                        const i = t.templates.xml_format || t.templates.format_date;
                        return e.start_date = i(e.start_date),
                        e.end_date && (e.end_date = i(e.end_date)),
                        e.constraint_date && (e.constraint_date = i(e.constraint_date)),
                        e.deadline && (e.deadline = i(e.deadline)),
                            e
                    },
                    _color_box: null,
                    _color_hash: {},
                    _getStyles(n) {
                        if (t.ext.export_api._color_box || (t.ext.export_api._color_box = document.createElement("DIV"),
                            t.ext.export_api._color_box.style.cssText = "position:absolute; display:none;",
                            document.body.appendChild(t.ext.export_api._color_box)),
                            t.ext.export_api._color_hash[n])
                            return t.ext.export_api._color_hash[n];
                        t.ext.export_api._color_box.className = n;
                        const e = t.ext.export_api._getColor(t.ext.export_api._color_box, "color")
                            , i = t.ext.export_api._getColor(t.ext.export_api._color_box, "backgroundColor");
                        return t.ext.export_api._color_hash[n] = e + ";" + i
                    },
                    _getMinutesWorktimeSettings(n) {
                        const e = [];
                        return n.forEach(function(i) {
                            e.push(i.startMinute),
                                e.push(i.endMinute)
                        }),
                            e
                    },
                    _getWorktimeSettings() {
                        const n = {
                            hours: [0, 24],
                            minutes: null,
                            dates: {
                                0: !0,
                                1: !0,
                                2: !0,
                                3: !0,
                                4: !0,
                                5: !0,
                                6: !0
                            }
                        };
                        let e;
                        if (t.config.work_time) {
                            const i = t._working_time_helper;
                            if (i && i.get_calendar)
                                e = i.get_calendar();
                            else if (i)
                                e = {
                                    hours: i.hours,
                                    minutes: null,
                                    dates: i.dates
                                };
                            else if (t.config.worktimes && t.config.worktimes.global) {
                                const a = t.config.worktimes.global;
                                if (a.parsed) {
                                    e = {
                                        hours: null,
                                        minutes: t.ext.export_api._getMinutesWorktimeSettings(a.parsed.hours),
                                        dates: {}
                                    };
                                    for (const r in a.parsed.dates)
                                        Array.isArray(a.parsed.dates[r]) ? e.dates[r] = t.ext.export_api._getMinutesWorktimeSettings(a.parsed.dates[r]) : e.dates[r] = a.parsed.dates[r]
                                } else
                                    e = {
                                        hours: a.hours,
                                        minutes: null,
                                        dates: a.dates
                                    }
                            } else
                                e = n
                        } else
                            e = n;
                        return e
                    },
                    _eachTaskTimed: (n, e) => function(i, a, r) {
                        a = a || t.config.root_id,
                            r = r || t;
                        const s = t.getChildren(a);
                        if (s)
                            for (let o = 0; o < s.length; o++) {
                                const l = t._pull[s[o]];
                                (!n || l.end_date > n) && (!e || l.start_date < e) && i.call(r, l),
                                t.hasChild(l.id) && t.eachTask(i, l.id, r)
                            }
                    }
                    ,
                    _originalCopyObject: t.json._copyObject,
                    _copyObjectPlain(n) {
                        const e = t.templates.task_text(n.start_date, n.end_date, n)
                            , i = t.ext.export_api._copyObjectBase(n);
                        return i.text = e || i.text,
                            i
                    },
                    _getColor(n, e) {
                        const i = n.currentStyle ? n.currentStyle[e] : getComputedStyle(n, null)[e]
                            , a = i.replace(/\s/g, "").match(/^rgba?\((\d+),(\d+),(\d+)/i);
                        return (a && a.length === 4 ? ("0" + parseInt(a[1], 10).toString(16)).slice(-2) + ("0" + parseInt(a[2], 10).toString(16)).slice(-2) + ("0" + parseInt(a[3], 10).toString(16)).slice(-2) : i).replace("#", "")
                    },
                    _copyObjectTable(n) {
                        const e = t.date.date_to_str("%Y-%m-%dT%H:%i:%s.000Z")
                            , i = t.ext.export_api._copyObjectColumns(n, t.ext.export_api._copyObjectPlain(n));
                        i.start_date && (i.start_date = e(n.start_date)),
                        i.end_date && (i.end_date = e(n.end_date));
                        const a = t._day_index_by_date ? t._day_index_by_date : t.columnIndexByDate;
                        i.$start = a.call(t, n.start_date),
                            i.$end = a.call(t, n.end_date);
                        let r = 0;
                        const s = t.getScale().width;
                        if (s.indexOf(0) > -1) {
                            let l = 0;
                            for (; l < i.$start; l++)
                                s[l] || r++;
                            for (i.$start -= r; l < i.$end; l++)
                                s[l] || r++;
                            i.$end -= r
                        }
                        i.$level = n.$level,
                            i.$type = n.$rendered_type;
                        const o = t.templates;
                        return i.$text = o.task_text(n.start, n.end_date, n),
                            i.$left = o.leftside_text ? o.leftside_text(n.start, n.end_date, n) : "",
                            i.$right = o.rightside_text ? o.rightside_text(n.start, n.end_date, n) : "",
                            i
                    },
                    _copyObjectColors(n) {
                        const e = t.ext.export_api._copyObjectTable(n)
                            , i = t.getTaskNode(n.id);
                        if (i && i.firstChild) {
                            let a = t.ext.export_api._getColor(t._no_progress_colors ? i : i.firstChild, "backgroundColor");
                            a === "363636" && (a = t.ext.export_api._getColor(i, "backgroundColor")),
                                e.$color = a
                        } else
                            n.color && (e.$color = n.color);
                        return e
                    },
                    _copyObjectColumns(n, e) {
                        for (let i = 0; i < t.config.columns.length; i++) {
                            const a = t.config.columns[i].template;
                            if (a) {
                                let r = a(n);
                                r instanceof Date && (r = t.templates.date_grid(r, n)),
                                    e["_" + i] = r
                            }
                        }
                        return e
                    },
                    _copyObjectAll(n) {
                        const e = t.ext.export_api._copyObjectBase(n)
                            , i = ["leftside_text", "rightside_text", "task_text", "progress_text", "task_class"];
                        for (let a = 0; a < i.length; a++) {
                            const r = t.templates[i[a]];
                            r && (e["$" + a] = r(n.start_date, n.end_date, n))
                        }
                        return t.ext.export_api._copyObjectColumns(n, e),
                            e.open = n.$open,
                            e
                    },
                    _serializeHtml() {
                        const n = t.config.smart_scales
                            , e = t.config.smart_rendering;
                        (n || e) && (t.config.smart_rendering = !1,
                            t.config.smart_scales = !1,
                            t.render());
                        const i = t.$container.parentNode.innerHTML;
                        return (n || e) && (t.config.smart_scales = n,
                            t.config.smart_rendering = e,
                            t.render()),
                            i
                    },
                    _serializeAll() {
                        t.json._copyObject = t.ext.export_api._copyObjectAll;
                        const n = t.ext.export_api._exportSerialize();
                        return t.json._copyObject = t.ext.export_api._originalCopyObject,
                            n
                    },
                    _serializePlain() {
                        const n = t.templates.xml_format
                            , e = t.templates.format_date;
                        t.templates.xml_format = t.date.date_to_str("%Y%m%dT%H%i%s", !0),
                            t.templates.format_date = t.date.date_to_str("%Y%m%dT%H%i%s", !0),
                            t.json._copyObject = t.ext.export_api._copyObjectPlain;
                        const i = t.ext.export_api._exportSerialize();
                        return t.templates.xml_format = n,
                            t.templates.format_date = e,
                            t.json._copyObject = t.ext.export_api._originalCopyObject,
                            delete i.links,
                            i
                    },
                    _getRaw() {
                        if (t._scale_helpers) {
                            const n = t._get_scales()
                                , e = t.config.min_column_width
                                , i = t._get_resize_options().x ? Math.max(t.config.autosize_min_width, 0) : t.config.$task.offsetWidth
                                , a = t.config.config.scale_height - 1;
                            return t._scale_helpers.prepareConfigs(n, e, i, a)
                        }
                        {
                            const n = t.$ui.getView("timeline");
                            if (n) {
                                let e = n.$config.width;
                                t.config.autosize !== "x" && t.config.autosize !== "xy" || (e = Math.max(t.config.autosize_min_width, 0));
                                const i = t.getState()
                                    , a = n._getScales()
                                    , r = t.config.min_column_width
                                    , s = t.config.scale_height - 1
                                    , o = t.config.rtl;
                                return n.$scaleHelper.prepareConfigs(a, r, e, s, i.min_date, i.max_date, o)
                            }
                        }
                    },
                    _serializeTimeline(n) {
                        t.json._copyObject = n.visual ? t.ext.export_api._copyObjectColors : t.ext.export_api._copyObjectTable;
                        const e = t.ext.export_api._exportSerialize();
                        if (t.json._copyObject = t.ext.export_api._originalCopyObject,
                            delete e.links,
                            n.cellColors) {
                            const i = t.templates.timeline_cell_class || t.templates.task_cell_class;
                            if (i) {
                                const a = t.ext.export_api._getRaw();
                                let r = a[0].trace_x;
                                for (let s = 1; s < a.length; s++)
                                    a[s].trace_x.length > r.length && (r = a[s].trace_x);
                                for (let s = 0; s < e.data.length; s++) {
                                    e.data[s].styles = [];
                                    const o = t.getTask(e.data[s].id);
                                    for (let l = 0; l < r.length; l++) {
                                        const d = i(o, r[l]);
                                        d && e.data[s].styles.push({
                                            index: l,
                                            styles: t.ext.export_api._getStyles(d)
                                        })
                                    }
                                }
                            }
                        }
                        return e
                    },
                    _serializeScales(n) {
                        const e = []
                            , i = t.ext.export_api._getRaw();
                        let a = 1 / 0
                            , r = 0;
                        for (let s = 0; s < i.length; s++)
                            a = Math.min(a, i[s].col_width);
                        for (let s = 0; s < i.length; s++) {
                            let o = 0
                                , l = 0;
                            const d = [];
                            e.push(d);
                            const c = i[s];
                            r = Math.max(r, c.trace_x.length);
                            const u = c.format || c.template || (c.date ? t.date.date_to_str(c.date) : t.config.date_scale);
                            for (let h = 0; h < c.trace_x.length; h++) {
                                const _ = c.trace_x[h];
                                l = o + Math.round(c.width[h] / a);
                                const f = {
                                    text: u(_),
                                    start: o,
                                    end: l,
                                    styles: ""
                                };
                                if (n.cellColors) {
                                    const y = c.css || t.templates.scaleCell_class;
                                    if (y) {
                                        const v = y(_);
                                        v && (f.styles = t.ext.export_api._getStyles(v))
                                    }
                                }
                                d.push(f),
                                    o = l
                            }
                        }
                        return {
                            width: r,
                            height: e.length,
                            data: e
                        }
                    },
                    _serializeGrid(n) {
                        t.exportMode = !0;
                        const e = []
                            , i = t.config.columns;
                        let a = 0;
                        for (let r = 0; r < i.length; r++)
                            i[r].name !== "add" && i[r].name !== "buttons" && (e[a] = {
                                id: i[r].template ? "_" + r : i[r].name,
                                header: i[r].label || t.locale.labels["column_" + i[r].name],
                                width: i[r].width ? Math.floor(i[r].width / 4) : "",
                                tree: i[r].tree || !1
                            },
                            i[r].name === "duration" && (e[a].type = "number"),
                            i[r].name !== "start_date" && i[r].name !== "end_date" || (e[a].type = "date",
                            n && n.rawDates && (e[a].id = i[r].name)),
                                a++);
                        return t.exportMode = !1,
                            e
                    },
                    _exportSerialize() {
                        t.exportMode = !0;
                        const n = t.templates.xml_format
                            , e = t.templates.format_date;
                        t.templates.xml_format = t.templates.format_date = t.date.date_to_str(t.config.date_format || t.config.xml_date);
                        const i = t.serialize();
                        return t.templates.xml_format = n,
                            t.templates.format_date = e,
                            t.exportMode = !1,
                            i
                    },
                    _setLevel(n) {
                        for (let e = 0; e < n.length; e++) {
                            n[e].parent == 0 && (n[e]._lvl = 1);
                            for (let i = e + 1; i < n.length; i++)
                                n[e].id == n[i].parent && (n[i]._lvl = n[e]._lvl + 1)
                        }
                    },
                    _clearLevel(n) {
                        for (let e = 0; e < n.length; e++)
                            delete n[e]._lvl
                    },
                    _clearRecLinks(n) {
                        t.ext.export_api._setLevel(n.data);
                        const e = {};
                        for (let r = 0; r < n.data.length; r++)
                            e[n.data[r].id] = n.data[r];
                        const i = {};
                        for (let r = 0; r < n.links.length; r++) {
                            const s = n.links[r];
                            t.isTaskExists(s.source) && t.isTaskExists(s.target) && e[s.source] && e[s.target] && (i[s.id] = s)
                        }
                        for (const r in i)
                            t.ext.export_api._makeLinksSameLevel(i[r], e);
                        const a = {};
                        for (const r in e)
                            t.ext.export_api._clearCircDependencies(e[r], i, e, {}, a, null);
                        Object.keys(i) && t.ext.export_api._clearLinksSameLevel(i, e);
                        for (let r = 0; r < n.links.length; r++)
                            i[n.links[r].id] || (n.links.splice(r, 1),
                                r--);
                        t.ext.export_api._clearLevel(n.data)
                    },
                    _clearCircDependencies(n, e, i, a, r, s) {
                        const o = n.$_source;
                        if (!o)
                            return;
                        a[n.id] && t.ext.export_api._onCircDependencyFind(s, e, a, r),
                            a[n.id] = !0;
                        const l = {};
                        for (let d = 0; d < o.length; d++) {
                            if (r[o[d]])
                                continue;
                            const c = e[o[d]]
                                , u = i[c._target];
                            l[u.id] && t.ext.export_api._onCircDependencyFind(c, e, a, r),
                                l[u.id] = !0,
                                t.ext.export_api._clearCircDependencies(u, e, i, a, r, c)
                        }
                        a[n.id] = !1
                    },
                    _onCircDependencyFind(n, e, i, a) {
                        n && (t.callEvent("onExportCircularDependency", [n.id, n]) && delete e[n.id],
                            delete i[n._source],
                            delete i[n._target],
                            a[n.id] = !0)
                    },
                    _makeLinksSameLevel(n, e) {
                        let i, a;
                        const r = {
                            target: e[n.target],
                            source: e[n.source]
                        };
                        if (r.target._lvl != r.source._lvl) {
                            r.target._lvl < r.source._lvl ? (i = "source",
                                a = r.target._lvl) : (i = "target",
                                a = r.source._lvl);
                            do {
                                const l = e[r[i].parent];
                                if (!l)
                                    break;
                                r[i] = l
                            } while (r[i]._lvl < a);
                            let s = e[r.source.parent]
                                , o = e[r.target.parent];
                            for (; s && o && s.id != o.id; )
                                r.source = s,
                                    r.target = o,
                                    s = e[r.source.parent],
                                    o = e[r.target.parent]
                        }
                        n._target = r.target.id,
                            n._source = r.source.id,
                        r.target.$_target || (r.target.$_target = []),
                            r.target.$_target.push(n.id),
                        r.source.$_source || (r.source.$_source = []),
                            r.source.$_source.push(n.id)
                    },
                    _clearLinksSameLevel(n, e) {
                        for (const i in n)
                            delete n[i]._target,
                                delete n[i]._source;
                        for (const i in e)
                            delete e[i].$_source,
                                delete e[i].$_target
                    },
                    _customProjectProperties(n, e) {
                        if (e && e.project) {
                            for (const i in e.project)
                                t.config.$custom_data || (t.config.$custom_data = {}),
                                    t.config.$custom_data[i] = typeof e.project[i] == "function" ? e.project[i](t.config) : e.project[i];
                            delete e.project
                        }
                    },
                    _customTaskProperties(n, e) {
                        e && e.tasks && (n.data.forEach(function(i) {
                            for (const a in e.tasks)
                                i.$custom_data || (i.$custom_data = {}),
                                    i.$custom_data[a] = typeof e.tasks[a] == "function" ? e.tasks[a](i, t.config) : e.tasks[a]
                        }),
                            delete e.tasks)
                    },
                    _exportConfig(n, e) {
                        const i = e.name || "gantt.xml";
                        delete e.name,
                            t.config.custom = e;
                        const a = t.ext.export_api._getWorktimeSettings()
                            , r = t.getSubtaskDates();
                        if (r.start_date && r.end_date) {
                            const l = t.templates.format_date || t.templates.xml_format;
                            t.config.start_end = {
                                start_date: l(r.start_date),
                                end_date: l(r.end_date)
                            }
                        }
                        const s = e.auto_scheduling !== void 0 && !!e.auto_scheduling
                            , o = {
                            callback: e.callback || null,
                            config: t.config,
                            data: n,
                            manual: s,
                            name: i,
                            worktime: a
                        };
                        for (const l in e)
                            o[l] = e[l];
                        return o
                    },
                    _sendImportAjaxMSP(n) {
                        const e = n.server || t.ext.export_api._apiUrl
                            , i = n.store || 0
                            , a = n.data
                            , r = n.callback
                            , s = {
                            durationUnit: n.durationUnit || void 0,
                            projectProperties: n.projectProperties || void 0,
                            taskProperties: n.taskProperties || void 0
                        };
                        a.append("type", n.type || "msproject-parse"),
                            a.append("data", JSON.stringify(s)),
                        i && a.append("store", i);
                        const o = new XMLHttpRequest;
                        o.onreadystatechange = function(l) {
                            o.readyState === 4 && o.status === 0 && r && r(null)
                        }
                            ,
                            o.onload = function() {
                                let l = null;
                                if (!(o.status > 400))
                                    try {
                                        l = JSON.parse(o.responseText)
                                    } catch {}
                                r && r(l)
                            }
                            ,
                            o.open("POST", e, !0),
                            o.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
                            o.send(a)
                    }
                },
                t.exportToPDF = t.ext.export_api.exportToPDF,
                t.exportToPNG = t.ext.export_api.exportToPNG,
                t.exportToICal = t.ext.export_api.exportToICal,
                t.exportToExcel = t.ext.export_api.exportToExcel,
                t.exportToJSON = t.ext.export_api.exportToJSON,
                t.importFromExcel = t.ext.export_api.importFromExcel,
                t.importFromMSProject = t.ext.export_api.importFromMSProject,
                t.exportToMSProject = t.ext.export_api.exportToMSProject,
                t.importFromPrimaveraP6 = t.ext.export_api.importFromPrimaveraP6,
                t.exportToPrimaveraP6 = t.ext.export_api.exportToPrimaveraP6,
                t.ext.export_api
        }
    };
    class bn {
        constructor(n) {
            this.addExtension = (e, i) => {
                this._extensions[e] = i
            }
                ,
                this.getExtension = e => this._extensions[e],
                this._extensions = {};
            for (const e in n)
                this._extensions[e] = n[e]
        }
    }
    const $i = {
        KEY_CODES: {
            UP: 38,
            DOWN: 40,
            LEFT: 37,
            RIGHT: 39,
            SPACE: 32,
            ENTER: 13,
            DELETE: 46,
            ESC: 27,
            TAB: 9
        }
    };
    var vt = typeof window < "u";
    const kt = {
        isIE: vt && (navigator.userAgent.indexOf("MSIE") >= 0 || navigator.userAgent.indexOf("Trident") >= 0),
        isOpera: vt && (navigator.userAgent.indexOf("Opera") >= 0 || navigator.userAgent.indexOf("OPR") >= 0),
        isChrome: vt && navigator.userAgent.indexOf("Chrome") >= 0,
        isSafari: vt && (navigator.userAgent.indexOf("Safari") >= 0 || navigator.userAgent.indexOf("Konqueror") >= 0),
        isFF: vt && navigator.userAgent.indexOf("Firefox") >= 0,
        isIPad: vt && navigator.userAgent.search(/iPad/gi) >= 0,
        isEdge: vt && navigator.userAgent.indexOf("Edge") != -1,
        isNode: !vt || typeof navigator > "u" || !1,
        isSalesforce: vt && (!!J.Sfdc || !!J.$A || J.Aura)
    };
    function $n(t) {
        if (typeof t == "string" || typeof t == "number")
            return t;
        let n = "";
        for (const e in t) {
            let i = "";
            t.hasOwnProperty(e) && (i = typeof t[e] == "string" ? encodeURIComponent(t[e]) : typeof t[e] == "number" ? String(t[e]) : encodeURIComponent(JSON.stringify(t[e])),
                i = e + "=" + i,
            n.length && (i = "&" + i),
                n += i)
        }
        return n
    }
    function Rt(t, n) {
        var e = {
            method: t
        };
        if (n.length === 0)
            throw new Error("Arguments list of query is wrong.");
        if (n.length === 1)
            return typeof n[0] == "string" ? (e.url = n[0],
                e.async = !0) : (e.url = n[0].url,
                e.async = n[0].async || !0,
                e.callback = n[0].callback,
                e.headers = n[0].headers),
                n[0].data ? typeof n[0].data != "string" ? e.data = $n(n[0].data) : e.data = n[0].data : e.data = "",
                e;
        switch (e.url = n[0],
            t) {
            case "GET":
            case "DELETE":
                e.callback = n[1],
                    e.headers = n[2];
                break;
            case "POST":
            case "PUT":
                n[1] ? typeof n[1] != "string" ? e.data = $n(n[1]) : e.data = n[1] : e.data = "",
                    e.callback = n[2],
                    e.headers = n[3]
        }
        return e
    }
    const xn = {
        date_to_str: (t, n, e) => {
            t = t.replace(/%[a-zA-Z]/g, a => {
                    switch (a) {
                        case "%d":
                            return `"+to_fixed(date.get${n ? "UTC" : ""}Date())+"`;
                        case "%m":
                            return `"+to_fixed((date.get${n ? "UTC" : ""}Month()+1))+"`;
                        case "%j":
                            return `"+date.get${n ? "UTC" : ""}Date()+"`;
                        case "%n":
                            return `"+(date.get${n ? "UTC" : ""}Month()+1)+"`;
                        case "%y":
                            return `"+to_fixed(date.get${n ? "UTC" : ""}FullYear()%100)+"`;
                        case "%Y":
                            return `"+date.get${n ? "UTC" : ""}FullYear()+"`;
                        case "%D":
                            return `"+locale.date.day_short[date.get${n ? "UTC" : ""}Day()]+"`;
                        case "%l":
                            return `"+locale.date.day_full[date.get${n ? "UTC" : ""}Day()]+"`;
                        case "%M":
                            return `"+locale.date.month_short[date.get${n ? "UTC" : ""}Month()]+"`;
                        case "%F":
                            return `"+locale.date.month_full[date.get${n ? "UTC" : ""}Month()]+"`;
                        case "%h":
                            return `"+to_fixed((date.get${n ? "UTC" : ""}Hours()+11)%12+1)+"`;
                        case "%g":
                            return `"+((date.get${n ? "UTC" : ""}Hours()+11)%12+1)+"`;
                        case "%G":
                            return `"+date.get${n ? "UTC" : ""}Hours()+"`;
                        case "%H":
                            return `"+to_fixed(date.get${n ? "UTC" : ""}Hours())+"`;
                        case "%i":
                            return `"+to_fixed(date.get${n ? "UTC" : ""}Minutes())+"`;
                        case "%a":
                            return `"+(date.get${n ? "UTC" : ""}Hours()>11?"pm":"am")+"`;
                        case "%A":
                            return `"+(date.get${n ? "UTC" : ""}Hours()>11?"PM":"AM")+"`;
                        case "%s":
                            return `"+to_fixed(date.get${n ? "UTC" : ""}Seconds())+"`;
                        case "%W":
                            return '"+to_fixed(getISOWeek(date))+"';
                        case "%w":
                            return '"+to_fixed(getWeek(date))+"';
                        default:
                            return a
                    }
                }
            );
            const i = new Function("date","to_fixed","locale","getISOWeek","getWeek",`return "${t}";`);
            return a => i(a, e.date.to_fixed, e.locale, e.date.getISOWeek, e.date.getWeek)
        }
        ,
        str_to_date: (t, n, e) => {
            let i = "var temp=date.match(/[a-zA-Z]+|[0-9]+/g);";
            const a = t.match(/%[a-zA-Z]/g);
            for (let o = 0; o < a.length; o++)
                switch (a[o]) {
                    case "%j":
                    case "%d":
                        i += `set[2]=temp[${o}]||1;`;
                        break;
                    case "%n":
                    case "%m":
                        i += `set[1]=(temp[${o}]||1)-1;`;
                        break;
                    case "%y":
                        i += `set[0]=temp[${o}]*1+(temp[${o}]>50?1900:2000);`;
                        break;
                    case "%g":
                    case "%G":
                    case "%h":
                    case "%H":
                        i += `set[3]=temp[${o}]||0;`;
                        break;
                    case "%i":
                        i += `set[4]=temp[${o}]||0;`;
                        break;
                    case "%Y":
                        i += `set[0]=temp[${o}]||0;`;
                        break;
                    case "%a":
                    case "%A":
                        i += `set[3]=set[3]%12+((temp[${o}]||'').toLowerCase()=='am'?0:12);`;
                        break;
                    case "%s":
                        i += `set[5]=temp[${o}]||0;`;
                        break;
                    case "%M":
                        i += `set[1]=locale.date.month_short_hash[temp[${o}]]||0;`;
                        break;
                    case "%F":
                        i += `set[1]=locale.date.month_full_hash[temp[${o}]]||0;`
                }
            let r = "set[0],set[1],set[2],set[3],set[4],set[5]";
            n && (r = ` Date.UTC(${r})`);
            const s = new Function("date","locale",`var set=[0,0,1,0,0,0]; ${i} return new Date(${r});`);
            return o => s(o, e.locale)
        }
    }
        , wn = {
        date_to_str: (t, n, e) => i => t.replace(/%[a-zA-Z]/g, a => {
                switch (a) {
                    case "%d":
                        return n ? e.date.to_fixed(i.getUTCDate()) : e.date.to_fixed(i.getDate());
                    case "%m":
                        return n ? e.date.to_fixed(i.getUTCMonth() + 1) : e.date.to_fixed(i.getMonth() + 1);
                    case "%j":
                        return n ? i.getUTCDate() : i.getDate();
                    case "%n":
                        return n ? i.getUTCMonth() + 1 : i.getMonth() + 1;
                    case "%y":
                        return n ? e.date.to_fixed(i.getUTCFullYear() % 100) : e.date.to_fixed(i.getFullYear() % 100);
                    case "%Y":
                        return n ? i.getUTCFullYear() : i.getFullYear();
                    case "%D":
                        return n ? e.locale.date.day_short[i.getUTCDay()] : e.locale.date.day_short[i.getDay()];
                    case "%l":
                        return n ? e.locale.date.day_full[i.getUTCDay()] : e.locale.date.day_full[i.getDay()];
                    case "%M":
                        return n ? e.locale.date.month_short[i.getUTCMonth()] : e.locale.date.month_short[i.getMonth()];
                    case "%F":
                        return n ? e.locale.date.month_full[i.getUTCMonth()] : e.locale.date.month_full[i.getMonth()];
                    case "%h":
                        return n ? e.date.to_fixed((i.getUTCHours() + 11) % 12 + 1) : e.date.to_fixed((i.getHours() + 11) % 12 + 1);
                    case "%g":
                        return n ? (i.getUTCHours() + 11) % 12 + 1 : (i.getHours() + 11) % 12 + 1;
                    case "%G":
                        return n ? i.getUTCHours() : i.getHours();
                    case "%H":
                        return n ? e.date.to_fixed(i.getUTCHours()) : e.date.to_fixed(i.getHours());
                    case "%i":
                        return n ? e.date.to_fixed(i.getUTCMinutes()) : e.date.to_fixed(i.getMinutes());
                    case "%a":
                        return n ? i.getUTCHours() > 11 ? "pm" : "am" : i.getHours() > 11 ? "pm" : "am";
                    case "%A":
                        return n ? i.getUTCHours() > 11 ? "PM" : "AM" : i.getHours() > 11 ? "PM" : "AM";
                    case "%s":
                        return n ? e.date.to_fixed(i.getUTCSeconds()) : e.date.to_fixed(i.getSeconds());
                    case "%W":
                        return n ? e.date.to_fixed(e.date.getUTCISOWeek(i)) : e.date.to_fixed(e.date.getISOWeek(i));
                    default:
                        return a
                }
            }
        ),
        str_to_date: (t, n, e) => i => {
            const a = [0, 0, 1, 0, 0, 0]
                , r = i.match(/[a-zA-Z]+|[0-9]+/g)
                , s = t.match(/%[a-zA-Z]/g);
            for (let o = 0; o < s.length; o++)
                switch (s[o]) {
                    case "%j":
                    case "%d":
                        a[2] = r[o] || 1;
                        break;
                    case "%n":
                    case "%m":
                        a[1] = (r[o] || 1) - 1;
                        break;
                    case "%y":
                        a[0] = 1 * r[o] + (r[o] > 50 ? 1900 : 2e3);
                        break;
                    case "%g":
                    case "%G":
                    case "%h":
                    case "%H":
                        a[3] = r[o] || 0;
                        break;
                    case "%i":
                        a[4] = r[o] || 0;
                        break;
                    case "%Y":
                        a[0] = r[o] || 0;
                        break;
                    case "%a":
                    case "%A":
                        a[3] = a[3] % 12 + ((r[o] || "").toLowerCase() === "am" ? 0 : 12);
                        break;
                    case "%s":
                        a[5] = r[o] || 0;
                        break;
                    case "%M":
                        a[1] = e.locale.date.month_short_hash[r[o]] || 0;
                        break;
                    case "%F":
                        a[1] = e.locale.date.month_full_hash[r[o]] || 0
                }
            return n ? new Date(Date.UTC(a[0], a[1], a[2], a[3], a[4], a[5])) : new Date(a[0],a[1],a[2],a[3],a[4],a[5])
        }
    };
    function xi(t) {
        var n = null;
        function e() {
            var a = !1;
            return t.config.csp === "auto" ? (n === null && function() {
                try {
                    new Function("canUseCsp = false;")
                } catch {
                    n = !0
                }
            }(),
                a = n) : a = t.config.csp,
                a
        }
        var i = {
            init: function() {
                for (var a = t.locale, r = a.date.month_short, s = a.date.month_short_hash = {}, o = 0; o < r.length; o++)
                    s[r[o]] = o;
                for (r = a.date.month_full,
                         s = a.date.month_full_hash = {},
                         o = 0; o < r.length; o++)
                    s[r[o]] = o
            },
            date_part: function(a) {
                var r = new Date(a);
                return a.setHours(0),
                    this.hour_start(a),
                a.getHours() && (a.getDate() < r.getDate() || a.getMonth() < r.getMonth() || a.getFullYear() < r.getFullYear()) && a.setTime(a.getTime() + 36e5 * (24 - a.getHours())),
                    a
            },
            time_part: function(a) {
                return (a.valueOf() / 1e3 - 60 * a.getTimezoneOffset()) % 86400
            },
            week_start: function(a) {
                var r = a.getDay();
                return t.config.start_on_monday && (r === 0 ? r = 6 : r--),
                    this.date_part(this.add(a, -1 * r, "day"))
            },
            month_start: function(a) {
                return a.setDate(1),
                    this.date_part(a)
            },
            quarter_start: function(a) {
                this.month_start(a);
                var r, s = a.getMonth();
                return r = s >= 9 ? 9 : s >= 6 ? 6 : s >= 3 ? 3 : 0,
                    a.setMonth(r),
                    a
            },
            year_start: function(a) {
                return a.setMonth(0),
                    this.month_start(a)
            },
            day_start: function(a) {
                return this.date_part(a)
            },
            hour_start: function(a) {
                return a.getMinutes() && a.setMinutes(0),
                    this.minute_start(a),
                    a
            },
            minute_start: function(a) {
                return a.getSeconds() && a.setSeconds(0),
                a.getMilliseconds() && a.setMilliseconds(0),
                    a
            },
            _add_days: function(a, r, s) {
                a.setDate(a.getDate() + r);
                var o = r >= 0
                    , l = !s.getHours() && a.getHours()
                    , d = a.getDate() <= s.getDate() || a.getMonth() < s.getMonth() || a.getFullYear() < s.getFullYear();
                return o && l && d && a.setTime(a.getTime() + 36e5 * (24 - a.getHours())),
                r > 1 && l && a.setHours(0),
                    a
            },
            add: function(a, r, s) {
                var o = new Date(a.valueOf());
                switch (s) {
                    case "day":
                        o = this._add_days(o, r, a);
                        break;
                    case "week":
                        o = this._add_days(o, 7 * r, a);
                        break;
                    case "month":
                        o.setMonth(o.getMonth() + r);
                        break;
                    case "year":
                        o.setYear(o.getFullYear() + r);
                        break;
                    case "hour":
                        o.setTime(o.getTime() + 60 * r * 60 * 1e3);
                        break;
                    case "minute":
                        o.setTime(o.getTime() + 60 * r * 1e3);
                        break;
                    default:
                        return this["add_" + s](a, r, s)
                }
                return o
            },
            add_quarter: function(a, r) {
                return this.add(a, 3 * r, "month")
            },
            to_fixed: function(a) {
                return a < 10 ? "0" + a : a
            },
            copy: function(a) {
                return new Date(a.valueOf())
            },
            date_to_str: function(a, r) {
                var s = xn;
                return e() && (s = wn),
                    s.date_to_str(a, r, t)
            },
            str_to_date: function(a, r) {
                var s = xn;
                return e() && (s = wn),
                    s.str_to_date(a, r, t)
            },
            getISOWeek: function(a) {
                return t.date._getWeekNumber(a, !0)
            },
            _getWeekNumber: function(a, r) {
                if (!a)
                    return !1;
                var s = a.getDay();
                r && s === 0 && (s = 7);
                var o = new Date(a.valueOf());
                o.setDate(a.getDate() + (4 - s));
                var l = o.getFullYear()
                    , d = Math.round((o.getTime() - new Date(l,0,1).getTime()) / 864e5);
                return 1 + Math.floor(d / 7)
            },
            getWeek: function(a) {
                return t.date._getWeekNumber(a, t.config.start_on_monday)
            },
            getUTCISOWeek: function(a) {
                return t.date.getISOWeek(a)
            },
            convert_to_utc: function(a) {
                return new Date(a.getUTCFullYear(),a.getUTCMonth(),a.getUTCDate(),a.getUTCHours(),a.getUTCMinutes(),a.getUTCSeconds())
            },
            parseDate: function(a, r) {
                return a && !a.getFullYear && (typeof r != "function" && (r = typeof r == "string" ? r === "parse_date" || r === "xml_date" ? t.defined(t.templates.xml_date) ? t.templates.xml_date : t.templates.parse_date : t.defined(t.templates[r]) ? t.templates[r] : t.date.str_to_date(r) : t.defined(t.templates.xml_date) ? t.templates.xml_date : t.templates.parse_date),
                    a = a ? r(a) : null),
                    a
            }
        };
        return i
    }
    class wi {
        constructor(n) {
            const {url: e, token: i} = n;
            this._url = e,
                this._token = i,
                this._mode = 1,
                this._seed = 1,
                this._queue = [],
                this.data = {},
                this.api = {},
                this._events = {}
        }
        headers() {
            return {
                Accept: "application/json",
                "Content-Type": "application/json",
                "Remote-Token": this._token
            }
        }
        fetch(n, e) {
            const i = {
                credentials: "include",
                headers: this.headers()
            };
            return e && (i.method = "POST",
                i.body = e),
                fetch(n, i).then(a => a.json())
        }
        load(n) {
            return n && (this._url = n),
                this.fetch(this._url).then(e => this.parse(e))
        }
        parse(n) {
            const {key: e, websocket: i} = n;
            e && (this._token = n.key);
            for (const a in n.data)
                this.data[a] = n.data[a];
            for (const a in n.api) {
                const r = this.api[a] = {}
                    , s = n.api[a];
                for (const o in s)
                    r[o] = this._wrapper(a + "." + o)
            }
            return i && this.connect(),
                this
        }
        connect() {
            const n = this._socket;
            n && (this._socket = null,
                n.onclose = function() {}
                ,
                n.close()),
                this._mode = 2,
                this._socket = function(e, i, a, r) {
                    let s = i;
                    s[0] === "/" && (s = document.location.protocol + "//" + document.location.host + i),
                        s = s.replace(/^http(s|):/, "ws$1:");
                    const o = s.indexOf("?") != -1 ? "&" : "?";
                    s = `${s}${o}token=${a}&ws=1`;
                    const l = new WebSocket(s);
                    return l.onclose = () => setTimeout( () => e.connect(), 2e3),
                        l.onmessage = d => {
                            const c = JSON.parse(d.data);
                            switch (c.action) {
                                case "result":
                                    e.result(c.body, []);
                                    break;
                                case "event":
                                    e.fire(c.body.name, c.body.value);
                                    break;
                                case "start":
                                    r();
                                    break;
                                default:
                                    e.onError(c.data)
                            }
                        }
                        ,
                        l
                }(this, this._url, this._token, () => (this._mode = 3,
                    this._send(),
                    this._resubscribe(),
                    this))
        }
        _wrapper(n) {
            return (function() {
                    const e = [].slice.call(arguments);
                    let i = null;
                    const a = new Promise( (r, s) => {
                            i = {
                                data: {
                                    id: this._uid(),
                                    name: n,
                                    args: e
                                },
                                status: 1,
                                resolve: r,
                                reject: s
                            },
                                this._queue.push(i)
                        }
                    );
                    return this.onCall(i, a),
                        this._mode === 3 ? this._send(i) : setTimeout( () => this._send(), 1),
                        a
                }
            ).bind(this)
        }
        _uid() {
            return (this._seed++).toString()
        }
        _send(n) {
            if (this._mode == 2)
                return void setTimeout( () => this._send(), 100);
            const e = n ? [n] : this._queue.filter(a => a.status === 1);
            if (!e.length)
                return;
            const i = e.map(a => (a.status = 2,
                a.data));
            this._mode !== 3 ? this.fetch(this._url, JSON.stringify(i)).catch(a => this.onError(a)).then(a => this.result(a, i)) : this._socket.send(JSON.stringify({
                action: "call",
                body: i
            }))
        }
        result(n, e) {
            const i = {};
            if (n)
                for (let a = 0; a < n.length; a++)
                    i[n[a].id] = n[a];
            else
                for (let a = 0; a < e.length; a++)
                    i[e[a].id] = {
                        id: e[a].id,
                        error: "Network Error",
                        data: null
                    };
            for (let a = this._queue.length - 1; a >= 0; a--) {
                const r = this._queue[a]
                    , s = i[r.data.id];
                s && (this.onResponse(r, s),
                    s.error ? r.reject(s.error) : r.resolve(s.data),
                    this._queue.splice(a, 1))
            }
        }
        on(n, e) {
            const i = this._uid();
            let a = this._events[n];
            const r = !!a;
            return r || (a = this._events[n] = []),
                a.push({
                    id: i,
                    handler: e
                }),
            r || this._mode != 3 || this._socket.send(JSON.stringify({
                action: "subscribe",
                name: n
            })),
                {
                    name: n,
                    id: i
                }
        }
        _resubscribe() {
            if (this._mode == 3)
                for (const n in this._events)
                    this._socket.send(JSON.stringify({
                        action: "subscribe",
                        name: n
                    }))
        }
        detach(n) {
            if (!n) {
                if (this._mode == 3)
                    for (const r in this._events)
                        this._socket.send(JSON.stringify({
                            action: "unsubscribe",
                            key: r
                        }));
                return void (this._events = {})
            }
            const {id: e, name: i} = n
                , a = this._events[i];
            if (a) {
                const r = a.filter(s => s.id != e);
                r.length ? this._events[i] = r : (delete this._events[i],
                this._mode == 3 && this._socket.send(JSON.stringify({
                    action: "unsubscribe",
                    name: i
                })))
            }
        }
        fire(n, e) {
            const i = this._events[n];
            if (i)
                for (let a = 0; a < i.length; a++)
                    i[a].handler(e)
        }
        onError(n) {
            return null
        }
        onCall(n, e) {}
        onResponse(n, e) {}
    }
    const Si = function(t, n) {
        const e = new wi({
            url: t,
            token: n
        });
        e.fetch = function(i, a) {
            const r = {
                headers: this.headers()
            };
            return a && (r.method = "POST",
                r.body = a),
                fetch(i, r).then(s => s.json())
        }
            ,
            this._ready = e.load().then(i => this._remote = i),
            this.ready = function() {
                return this._ready
            }
            ,
            this.on = function(i, a) {
                this.ready().then(r => {
                        if (typeof i == "string")
                            r.on(i, a);
                        else
                            for (const s in i)
                                r.on(s, i[s])
                    }
                )
            }
    };
    function Sn(t, n) {
        if (!n)
            return !0;
        if (t._on_timeout)
            return !1;
        var e = Math.ceil(1e3 / n);
        return e < 2 || (setTimeout(function() {
            delete t._on_timeout
        }, e),
            t._on_timeout = !0),
            !0
    }
    var Ti = function() {
        var t = {};
        return {
            getState: function(n) {
                if (t[n])
                    return t[n].method();
                var e = {};
                for (var i in t)
                    t[i].internal || O(e, t[i].method(), !0);
                return e
            },
            registerProvider: function(n, e, i) {
                t[n] = {
                    method: e,
                    internal: i
                }
            },
            unregisterProvider: function(n) {
                delete t[n]
            }
        }
    };
    const Ei = Promise;
    var rt = {
        $create: function(t) {
            return O(t || [], this)
        },
        $removeAt: function(t, n) {
            t >= 0 && this.splice(t, n || 1)
        },
        $remove: function(t) {
            this.$removeAt(this.$find(t))
        },
        $insertAt: function(t, n) {
            if (n || n === 0) {
                var e = this.splice(n, this.length - n);
                this[n] = t,
                    this.push.apply(this, e)
            } else
                this.push(t)
        },
        $find: function(t) {
            for (var n = 0; n < this.length; n++)
                if (t == this[n])
                    return n;
            return -1
        },
        $each: function(t, n) {
            for (var e = 0; e < this.length; e++)
                t.call(n || this, this[e])
        },
        $map: function(t, n) {
            for (var e = 0; e < this.length; e++)
                this[e] = t.call(n || this, this[e]);
            return this
        },
        $filter: function(t, n) {
            for (var e = 0; e < this.length; e++)
                t.call(n || this, this[e]) || (this.splice(e, 1),
                    e--);
            return this
        }
    };
    function jt(t, n, e, i) {
        return (i = n ? n.config : i) && i.placeholder_task && e.exists(t) ? e.getItem(t).type === i.types.placeholder : !1
    }
    var ht = function(t) {
        return this.pull = {},
            this.$initItem = t.initItem,
            this.visibleOrder = rt.$create(),
            this.fullOrder = rt.$create(),
            this._skip_refresh = !1,
            this._filterRule = null,
            this._searchVisibleOrder = {},
            this._indexRangeCache = {},
            this._getItemsCache = null,
            this.$config = t,
            ct(this),
            this._attachDataChange(function() {
                return this._indexRangeCache = {},
                    this._getItemsCache = null,
                    !0
            }),
            this
    };
    ht.prototype = {
        _attachDataChange: function(t) {
            this.attachEvent("onClearAll", t),
                this.attachEvent("onBeforeParse", t),
                this.attachEvent("onBeforeUpdate", t),
                this.attachEvent("onBeforeDelete", t),
                this.attachEvent("onBeforeAdd", t),
                this.attachEvent("onParse", t),
                this.attachEvent("onBeforeFilter", t)
        },
        _parseInner: function(t) {
            for (var n = null, e = [], i = 0, a = t.length; i < a; i++)
                n = t[i],
                this.$initItem && (this.$config.copyOnParse() && (n = X(n)),
                    n = this.$initItem(n)),
                this.callEvent("onItemLoading", [n]) && (this.pull.hasOwnProperty(n.id) || this.fullOrder.push(n.id),
                    e.push(n),
                    this.pull[n.id] = n);
            return e
        },
        parse: function(t) {
            this.isSilent() || this.callEvent("onBeforeParse", [t]);
            var n = this._parseInner(t);
            this.isSilent() || (this.refresh(),
                this.callEvent("onParse", [n]))
        },
        getItem: function(t) {
            return this.pull[t]
        },
        _updateOrder: function(t) {
            t.call(this.visibleOrder),
                t.call(this.fullOrder)
        },
        updateItem: function(t, n) {
            if (U(n) || (n = this.getItem(t)),
            !this.isSilent() && this.callEvent("onBeforeUpdate", [n.id, n]) === !1)
                return !1;
            O(this.pull[t], n, !0),
            this.isSilent() || (this.callEvent("onAfterUpdate", [n.id, n]),
                this.callEvent("onStoreUpdated", [n.id, n, "update"]))
        },
        _removeItemInner: function(t) {
            this._updateOrder(function() {
                this.$remove(t)
            }),
                delete this.pull[t]
        },
        removeItem: function(t) {
            var n = this.getItem(t);
            if (!this.isSilent() && this.callEvent("onBeforeDelete", [n.id, n]) === !1)
                return !1;
            this.callEvent("onAfterDeleteConfirmed", [n.id, n]),
                this._removeItemInner(t),
            this.isSilent() && this.callEvent("onAfterSilentDelete", [n.id, n]),
            this.isSilent() || (this.filter(),
                this.callEvent("onAfterDelete", [n.id, n]),
                this.callEvent("onStoreUpdated", [n.id, n, "delete"]))
        },
        _addItemInner: function(t, n) {
            if (this.exists(t.id))
                this.silent(function() {
                    this.updateItem(t.id, t)
                });
            else {
                var e = this.visibleOrder
                    , i = e.length;
                (!U(n) || n < 0) && (n = i),
                n > i && (n = Math.min(e.length, n))
            }
            this.pull[t.id] = t,
                this._updateOrder(function() {
                    this.$find(t.id) === -1 && this.$insertAt(t.id, n)
                }),
                this.filter()
        },
        isVisible: function(t) {
            return this.visibleOrder.$find(t) > -1
        },
        getVisibleItems: function() {
            return this.getIndexRange()
        },
        addItem: function(t, n) {
            return U(t.id) || (t.id = ut()),
            this.$initItem && (t = this.$initItem(t)),
            !(!this.isSilent() && this.callEvent("onBeforeAdd", [t.id, t]) === !1) && (this._addItemInner(t, n),
            this.isSilent() || (this.callEvent("onAfterAdd", [t.id, t]),
                this.callEvent("onStoreUpdated", [t.id, t, "add"])),
                t.id)
        },
        _changeIdInner: function(t, n) {
            this.pull[t] && (this.pull[n] = this.pull[t]);
            var e = this._searchVisibleOrder[t];
            this.pull[n].id = n,
                this._updateOrder(function() {
                    this[this.$find(t)] = n
                }),
                this._searchVisibleOrder[n] = e,
                delete this._searchVisibleOrder[t],
                delete this.pull[t]
        },
        changeId: function(t, n) {
            this._changeIdInner(t, n),
                this.callEvent("onIdChange", [t, n])
        },
        exists: function(t) {
            return !!this.pull[t]
        },
        _moveInner: function(t, n) {
            var e = this.getIdByIndex(t);
            this._updateOrder(function() {
                this.$removeAt(t),
                    this.$insertAt(e, Math.min(this.length, n))
            })
        },
        move: function(t, n) {
            var e = this.getIdByIndex(t)
                , i = this.getItem(e);
            this._moveInner(t, n),
            this.isSilent() || this.callEvent("onStoreUpdated", [i.id, i, "move"])
        },
        clearAll: function() {
            this.$destroyed || (this.silent(function() {
                this.unselect()
            }),
                this.pull = {},
                this.visibleOrder = rt.$create(),
                this.fullOrder = rt.$create(),
            this.isSilent() || (this.callEvent("onClearAll", []),
                this.refresh()))
        },
        silent: function(t, n) {
            var e = !1;
            this.isSilent() && (e = !0),
                this._skip_refresh = !0,
                t.call(n || this),
            e || (this._skip_refresh = !1)
        },
        isSilent: function() {
            return !!this._skip_refresh
        },
        arraysEqual: function(t, n) {
            if (t.length !== n.length)
                return !1;
            for (var e = 0; e < t.length; e++)
                if (t[e] !== n[e])
                    return !1;
            return !0
        },
        refresh: function(t, n) {
            var e, i;
            if (!this.$destroyed && !this.isSilent() && (t && (e = this.getItem(t)),
                i = t ? [t, e, "paint"] : [null, null, null],
            this.callEvent("onBeforeStoreUpdate", i) !== !1)) {
                var a = this._quick_refresh && !this._mark_recompute;
                if (this._mark_recompute = !1,
                    t) {
                    if (!n && !a) {
                        var r = this.visibleOrder;
                        this.filter(),
                        this.arraysEqual(r, this.visibleOrder) || (t = void 0)
                    }
                } else
                    a || this.filter();
                i = t ? [t, e, "paint"] : [null, null, null],
                    this.callEvent("onStoreUpdated", i)
            }
        },
        count: function() {
            return this.fullOrder.length
        },
        countVisible: function() {
            return this.visibleOrder.length
        },
        sort: function(t) {},
        serialize: function() {},
        eachItem: function(t) {
            for (var n = 0; n < this.fullOrder.length; n++) {
                var e = this.getItem(this.fullOrder[n]);
                t.call(this, e)
            }
        },
        find: function(t) {
            var n = [];
            return this.eachItem(function(e) {
                t(e) && n.push(e)
            }),
                n
        },
        filter: function(t) {
            this.isSilent() || this.callEvent("onBeforeFilter", []),
                this.callEvent("onPreFilter", []);
            var n = rt.$create()
                , e = [];
            this.eachItem(function(a) {
                this.callEvent("onFilterItem", [a.id, a]) && (jt(a.id, null, this, this._ganttConfig) ? e.push(a.id) : n.push(a.id))
            });
            for (var i = 0; i < e.length; i++)
                n.push(e[i]);
            for (this.visibleOrder = n,
                     this._searchVisibleOrder = {},
                     i = 0; i < this.visibleOrder.length; i++)
                this._searchVisibleOrder[this.visibleOrder[i]] = i;
            this.isSilent() || this.callEvent("onFilter", [])
        },
        getIndexRange: function(t, n) {
            var e = Math.min(n || 1 / 0, this.countVisible() - 1)
                , i = t || 0
                , a = i + "-" + e;
            if (this._indexRangeCache[a])
                return this._indexRangeCache[a].slice();
            for (var r = [], s = i; s <= e; s++)
                r.push(this.getItem(this.visibleOrder[s]));
            return this._indexRangeCache[a] = r.slice(),
                r
        },
        getItems: function() {
            if (this._getItemsCache)
                return this._getItemsCache.slice();
            var t = [];
            for (var n in this.pull)
                t.push(this.pull[n]);
            return this._getItemsCache = t.slice(),
                t
        },
        getIdByIndex: function(t) {
            return this.visibleOrder[t]
        },
        getIndexById: function(t) {
            var n = this._searchVisibleOrder[t];
            return n === void 0 && (n = -1),
                n
        },
        _getNullIfUndefined: function(t) {
            return t === void 0 ? null : t
        },
        getFirst: function() {
            return this._getNullIfUndefined(this.visibleOrder[0])
        },
        getLast: function() {
            return this._getNullIfUndefined(this.visibleOrder[this.visibleOrder.length - 1])
        },
        getNext: function(t) {
            return this._getNullIfUndefined(this.visibleOrder[this.getIndexById(t) + 1])
        },
        getPrev: function(t) {
            return this._getNullIfUndefined(this.visibleOrder[this.getIndexById(t) - 1])
        },
        destructor: function() {
            this.callEvent("onDestroy", []),
                this.detachAllEvents(),
                this.$destroyed = !0,
                this.pull = null,
                this.$initItem = null,
                this.visibleOrder = null,
                this.fullOrder = null,
                this._skip_refresh = null,
                this._filterRule = null,
                this._searchVisibleOrder = null,
                this._indexRangeCache = {}
        }
    };
    var Te = function(t) {
        var n;
        ht.apply(this, [t]),
            this._branches = {},
            this.pull = {},
            this.$initItem = function(o) {
                var l = o;
                t.initItem && (l = t.initItem(l));
                var d = this.getItem(o.id);
                return d && !gt(d.parent, l.parent) && this.move(l.id, l.$index || -1, l.parent || this._ganttConfig.root_id),
                    l
            }
            ,
            this.$parentProperty = t.parentProperty || "parent",
            typeof t.rootId != "function" ? this.$getRootId = (n = t.rootId || 0,
                    function() {
                        return n
                    }
            ) : this.$getRootId = t.rootId,
            this.$openInitially = t.openInitially,
            this.visibleOrder = rt.$create(),
            this.fullOrder = rt.$create(),
            this._searchVisibleOrder = {},
            this._indexRangeCache = {},
            this._eachItemMainRangeCache = null,
            this._getItemsCache = null,
            this._skip_refresh = !1,
            this._ganttConfig = null,
        t.getConfig && (this._ganttConfig = t.getConfig());
        var e = {}
            , i = {}
            , a = {}
            , r = {}
            , s = !1;
        return this._attachDataChange(function() {
            return this._indexRangeCache = {},
                this._eachItemMainRangeCache = null,
                this._getItemsCache = null,
                !0
        }),
            this.attachEvent("onPreFilter", function() {
                this._indexRangeCache = {},
                    this._eachItemMainRangeCache = null,
                    e = {},
                    i = {},
                    a = {},
                    r = {},
                    s = !1,
                    this.eachItem(function(o) {
                        var l = this.getParent(o.id);
                        o.$open && a[l] !== !1 ? a[o.id] = !0 : a[o.id] = !1,
                        this._isSplitItem(o) && (s = !0,
                            e[o.id] = !0,
                            i[o.id] = !0),
                        s && i[l] && (i[o.id] = !0),
                            a[l] || a[l] === void 0 ? r[o.id] = !0 : r[o.id] = !1
                    })
            }),
            this.attachEvent("onFilterItem", function(o, l) {
                var d = !1;
                this._ganttConfig && (d = this._ganttConfig.open_split_tasks);
                var c = r[l.id];
                return s && (c && i[l.id] && !e[l.id] && (c = !!d),
                i[l.id] && !e[l.id] && (l.$split_subtask = !0)),
                    l.$expanded_branch = !!r[l.id],
                    !!c
            }),
            this.attachEvent("onFilter", function() {
                e = {},
                    i = {},
                    a = {},
                    r = {}
            }),
            this
    };
    function gt(t, n) {
        return String(t) === String(n)
    }
    function K(t) {
        return kt.isNode || !t.$root
    }
    Te.prototype = O({
        _buildTree: function(t) {
            for (var n = null, e = this.$getRootId(), i = 0, a = t.length; i < a; i++)
                n = t[i],
                    this.setParent(n, ot(this.getParent(n), e) || e);
            for (i = 0,
                     a = t.length; i < a; i++)
                n = t[i],
                    this._add_branch(n),
                    n.$level = this.calculateItemLevel(n),
                    n.$local_index = this.getBranchIndex(n.id),
                U(n.$open) || (n.$open = U(n.open) ? n.open : this.$openInitially());
            this._updateOrder()
        },
        _isSplitItem: function(t) {
            return t.render == "split" && this.hasChild(t.id)
        },
        parse: function(t) {
            this._skip_refresh || this.callEvent("onBeforeParse", [t]);
            var n = this._parseInner(t);
            this._buildTree(n),
                this.filter(),
            this._skip_refresh || this.callEvent("onParse", [n])
        },
        _addItemInner: function(t, n) {
            var e = this.getParent(t);
            U(e) || (e = this.$getRootId(),
                this.setParent(t, e));
            var i = this.getIndexById(e) + Math.min(Math.max(n, 0), this.visibleOrder.length);
            1 * i !== i && (i = void 0),
                ht.prototype._addItemInner.call(this, t, i),
                this.setParent(t, e),
            t.hasOwnProperty("$rendered_parent") && this._move_branch(t, t.$rendered_parent),
                this._add_branch(t, n)
        },
        _changeIdInner: function(t, n) {
            var e = this.getChildren(t)
                , i = this._searchVisibleOrder[t];
            ht.prototype._changeIdInner.call(this, t, n);
            var a = this.getParent(n);
            this._replace_branch_child(a, t, n),
            this._branches[t] && (this._branches[n] = this._branches[t]);
            for (var r = 0; r < e.length; r++) {
                var s = this.getItem(e[r]);
                s[this.$parentProperty] = n,
                    s.$rendered_parent = n
            }
            this._searchVisibleOrder[n] = i,
                delete this._branches[t]
        },
        _traverseBranches: function(t, n) {
            U(n) || (n = this.$getRootId());
            var e = this._branches[n];
            if (e)
                for (var i = 0; i < e.length; i++) {
                    var a = e[i];
                    t.call(this, a),
                    this._branches[a] && this._traverseBranches(t, a)
                }
        },
        _updateOrder: function(t) {
            this.fullOrder = rt.$create(),
                this._traverseBranches(function(n) {
                    this.fullOrder.push(n)
                }),
            t && ht.prototype._updateOrder.call(this, t)
        },
        _removeItemInner: function(t) {
            var n = [];
            this.eachItem(function(i) {
                n.push(i)
            }, t),
                n.push(this.getItem(t));
            for (var e = 0; e < n.length; e++)
                this._move_branch(n[e], this.getParent(n[e]), null),
                    ht.prototype._removeItemInner.call(this, n[e].id),
                    this._move_branch(n[e], this.getParent(n[e]), null)
        },
        move: function(t, n, e) {
            var i = arguments[3]
                , a = (this._ganttConfig || {}).root_id || 0;
            if (i = ot(i, a)) {
                if (i === t)
                    return;
                e = this.getParent(i),
                    n = this.getBranchIndex(i)
            }
            if (!gt(t, e)) {
                U(e) || (e = this.$getRootId());
                var r = this.getItem(t)
                    , s = this.getParent(r.id)
                    , o = this.getChildren(e);
                if (n == -1 && (n = o.length + 1),
                gt(s, e) && this.getBranchIndex(t) == n)
                    return;
                if (this.callEvent("onBeforeItemMove", [t, e, n]) === !1)
                    return !1;
                for (var l = [], d = 0; d < o.length; d++)
                    jt(o[d], null, this, this._ganttConfig) && (l.push(o[d]),
                        o.splice(d, 1),
                        d--);
                this._replace_branch_child(s, t);
                var c = (o = this.getChildren(e))[n];
                (c = ot(c, a)) ? o = o.slice(0, n).concat([t]).concat(o.slice(n)) : o.push(t),
                l.length && (o = o.concat(l)),
                gt(r.$rendered_parent, s) || gt(s, e) || (r.$rendered_parent = s),
                    this.setParent(r, e),
                    this._branches[e] = o;
                var u = this.calculateItemLevel(r) - r.$level;
                r.$level += u,
                    this.eachItem(function(h) {
                        h.$level += u
                    }, r.id, this),
                    this._moveInner(this.getIndexById(t), this.getIndexById(e) + n),
                    this.callEvent("onAfterItemMove", [t, e, n]),
                    this.refresh()
            }
        },
        getBranchIndex: function(t) {
            var n = this.getChildren(this.getParent(t));
            let e = n.indexOf(t + "");
            return e == -1 && (e = n.indexOf(+t)),
                e
        },
        hasChild: function(t) {
            var n = this._branches[t];
            return n && n.length
        },
        getChildren: function(t) {
            var n = this._branches[t];
            return n || rt.$create()
        },
        isChildOf: function(t, n) {
            if (!this.exists(t))
                return !1;
            if (n === this.$getRootId())
                return !0;
            if (!this.hasChild(n))
                return !1;
            var e = this.getItem(t)
                , i = this.getParent(t);
            if (this.getItem(n).$level >= e.$level)
                return !1;
            for (; e && this.exists(i); ) {
                if ((e = this.getItem(i)) && gt(e.id, n))
                    return !0;
                i = this.getParent(e)
            }
            return !1
        },
        getSiblings: function(t) {
            if (!this.exists(t))
                return rt.$create();
            var n = this.getParent(t);
            return this.getChildren(n)
        },
        getNextSibling: function(t) {
            for (var n = this.getSiblings(t), e = 0, i = n.length; e < i; e++)
                if (gt(n[e], t)) {
                    var a = n[e + 1];
                    return a === 0 && e > 0 && (a = "0"),
                    a || null
                }
            return null
        },
        getPrevSibling: function(t) {
            for (var n = this.getSiblings(t), e = 0, i = n.length; e < i; e++)
                if (gt(n[e], t)) {
                    var a = n[e - 1];
                    return a === 0 && e > 0 && (a = "0"),
                    a || null
                }
            return null
        },
        getParent: function(t) {
            var n = null;
            return (n = t.id !== void 0 ? t : this.getItem(t)) ? n[this.$parentProperty] : this.$getRootId()
        },
        clearAll: function() {
            this._branches = {},
                ht.prototype.clearAll.call(this)
        },
        calculateItemLevel: function(t) {
            var n = 0;
            return this.eachParent(function() {
                n++
            }, t),
                n
        },
        _setParentInner: function(t, n, e) {
            e || (t.hasOwnProperty("$rendered_parent") ? this._move_branch(t, t.$rendered_parent, n) : this._move_branch(t, t[this.$parentProperty], n))
        },
        setParent: function(t, n, e) {
            this._setParentInner(t, n, e),
                t[this.$parentProperty] = n
        },
        _eachItemCached: function(t, n) {
            for (var e = 0, i = n.length; e < i; e++)
                t.call(this, n[e])
        },
        _eachItemIterate: function(t, n, e) {
            var i = this.getChildren(n);
            for (i.length && (i = i.slice().reverse()); i.length; ) {
                var a = i.pop()
                    , r = this.getItem(a);
                if (t.call(this, r),
                e && e.push(r),
                    this.hasChild(r.id))
                    for (var s = this.getChildren(r.id), o = s.length - 1; o >= 0; o--)
                        i.push(s[o])
            }
        },
        eachItem: function(t, n) {
            var e = this.$getRootId();
            U(n) || (n = e);
            var i = ot(n, e) || e
                , a = !1
                , r = !1
                , s = null;
            i === e && (this._eachItemMainRangeCache ? (a = !0,
                s = this._eachItemMainRangeCache) : (r = !0,
                s = this._eachItemMainRangeCache = [])),
                a ? this._eachItemCached(t, s) : this._eachItemIterate(t, i, r ? s : null)
        },
        eachParent: function(t, n) {
            for (var e = {}, i = n, a = this.getParent(i); this.exists(a); ) {
                if (e[a])
                    throw new Error("Invalid tasks tree. Cyclic reference has been detected on task " + a);
                e[a] = !0,
                    i = this.getItem(a),
                    t.call(this, i),
                    a = this.getParent(i)
            }
        },
        _add_branch: function(t, n, e) {
            var i = e === void 0 ? this.getParent(t) : e;
            this.hasChild(i) || (this._branches[i] = rt.$create());
            var a = this.getChildren(i);
            a.indexOf(t.id + "") > -1 || a.indexOf(+t.id) > -1 || (1 * n == n ? a.splice(n, 0, t.id) : a.push(t.id),
                t.$rendered_parent = i)
        },
        _move_branch: function(t, n, e) {
            this._eachItemMainRangeCache = null,
                this._replace_branch_child(n, t.id),
                this.exists(e) || gt(e, this.$getRootId()) ? this._add_branch(t, void 0, e) : delete this._branches[t.id],
                t.$level = this.calculateItemLevel(t),
                this.eachItem(function(i) {
                    i.$level = this.calculateItemLevel(i)
                }, t.id)
        },
        _replace_branch_child: function(t, n, e) {
            var i = this.getChildren(t);
            if (i && t !== void 0) {
                var a = rt.$create();
                let r = i.indexOf(n + "");
                r != -1 || isNaN(+n) || (r = i.indexOf(+n)),
                r > -1 && (e ? i.splice(r, 1, e) : i.splice(r, 1)),
                    a = i,
                    this._branches[t] = a
            }
        },
        sort: function(t, n, e) {
            this.exists(e) || (e = this.$getRootId()),
            t || (t = "order");
            var i = typeof t == "string" ? function(l, d) {
                    return l[t] == d[t] || nt(l[t]) && nt(d[t]) && l[t].valueOf() == d[t].valueOf() ? 0 : l[t] > d[t] ? 1 : -1
                }
                : t;
            if (n) {
                var a = i;
                i = function(l, d) {
                    return a(d, l)
                }
            }
            var r = this.getChildren(e);
            if (r) {
                for (var s = [], o = r.length - 1; o >= 0; o--)
                    s[o] = this.getItem(r[o]);
                for (s.sort(i),
                         o = 0; o < s.length; o++)
                    r[o] = s[o].id,
                        this.sort(t, n, r[o])
            }
        },
        filter: function(t) {
            for (let n in this.pull) {
                const e = this.pull[n].$rendered_parent
                    , i = this.getParent(this.pull[n]);
                gt(e, i) || this._move_branch(this.pull[n], e, i)
            }
            return ht.prototype.filter.apply(this, arguments)
        },
        open: function(t) {
            this.exists(t) && (this.getItem(t).$open = !0,
                this._skipTaskRecalculation = !0,
                this.callEvent("onItemOpen", [t]))
        },
        close: function(t) {
            this.exists(t) && (this.getItem(t).$open = !1,
                this._skipTaskRecalculation = !0,
                this.callEvent("onItemClose", [t]))
        },
        destructor: function() {
            ht.prototype.destructor.call(this),
                this._branches = null,
                this._indexRangeCache = {},
                this._eachItemMainRangeCache = null
        }
    }, ht.prototype);
    const Ci = function(t, n) {
        const e = n.getDatastore(t)
            , i = function(o, l) {
            const d = l.getLayers()
                , c = e.getItem(o);
            if (c && e.isVisible(o))
                for (let u = 0; u < d.length; u++)
                    d[u].render_item(c)
        }
            , a = function(o) {
            const l = o.getLayers();
            for (let _ = 0; _ < l.length; _++)
                l[_].clear();
            let d = null;
            const c = {};
            for (let _ = 0; _ < l.length; _++) {
                const f = l[_];
                let y;
                if (f.get_visible_range) {
                    var u = f.get_visible_range(e);
                    if (u.start !== void 0 && u.end !== void 0) {
                        var h = u.start + " - " + u.end;
                        c[h] ? y = c[h] : (y = e.getIndexRange(u.start, u.end),
                            c[h] = y)
                    } else {
                        if (u.ids === void 0)
                            throw new Error("Invalid range returned from 'getVisibleRange' of the layer");
                        y = u.ids.map(function(v) {
                            return e.getItem(v)
                        })
                    }
                } else
                    d || (d = e.getVisibleItems()),
                        y = d;
                f.prepare_data && f.prepare_data(y),
                    l[_].render_items(y)
            }
        }
            , r = function(o) {
            if (o.update_items) {
                let d = [];
                if (o.get_visible_range) {
                    var l = o.get_visible_range(e);
                    if (l.start !== void 0 && l.end !== void 0 && (d = e.getIndexRange(l.start, l.end)),
                    l.ids !== void 0) {
                        let c = l.ids.map(function(u) {
                            return e.getItem(u)
                        });
                        c.length > 0 && (c = c.filter(u => u !== void 0),
                            d = d.concat(c))
                    }
                    if ((l.start == null || l.end == null) && l.ids == null)
                        throw new Error("Invalid range returned from 'getVisibleRange' of the layer")
                } else
                    d = e.getVisibleItems();
                o.prepare_data && o.prepare_data(d, o),
                    o.update_items(d)
            }
        };
        function s(o) {
            return !!o.$services.getService("state").getState("batchUpdate").batch_update
        }
        e.attachEvent("onStoreUpdated", function(o, l, d) {
            if (K(n))
                return !0;
            const c = n.$services.getService("layers").getDataRender(t);
            c && (c.onUpdateRequest = function(u) {
                    r(u)
                }
            )
        }),
            e.attachEvent("onStoreUpdated", function(o, l, d) {
                s(n) || (o && d != "move" && d != "delete" ? (e.callEvent("onBeforeRefreshItem", [l.id]),
                    e.callEvent("onAfterRefreshItem", [l.id])) : (e.callEvent("onBeforeRefreshAll", []),
                    e.callEvent("onAfterRefreshAll", [])))
            }),
            e.attachEvent("onAfterRefreshAll", function() {
                if (K(n))
                    return !0;
                const o = n.$services.getService("layers").getDataRender(t);
                o && !s(n) && a(o)
            }),
            e.attachEvent("onAfterRefreshItem", function(o) {
                if (K(n))
                    return !0;
                const l = n.$services.getService("layers").getDataRender(t);
                l && i(o, l)
            }),
            e.attachEvent("onItemOpen", function() {
                if (K(n) || e.isSilent())
                    return !0;
                n.render()
            }),
            e.attachEvent("onItemClose", function() {
                if (K(n) || e.isSilent())
                    return !0;
                n.render()
            }),
            e.attachEvent("onIdChange", function(o, l) {
                if (K(n))
                    return !0;
                if (e.callEvent("onBeforeIdChange", [o, l]),
                !s(n) && !e.isSilent()) {
                    const d = n.$services.getService("layers").getDataRender(t);
                    d ? (function(c, u, h) {
                        for (let _ = 0; _ < c.length; _++)
                            c[_].change_id(u, h)
                    }(d.getLayers(), o, l, e.getItem(l)),
                        i(l, d)) : n.render()
                }
            })
    };
    function Ee() {
        for (var t = this.$services.getService("datastores"), n = [], e = 0; e < t.length; e++) {
            var i = this.getDatastore(t[e]);
            i.$destroyed || n.push(i)
        }
        return n
    }
    const Di = {
        create: function() {
            var t = O({}, {
                createDatastore: function(n) {
                    var e = (n.type || "").toLowerCase() == "treedatastore" ? Te : ht;
                    if (n) {
                        var i = this;
                        n.openInitially = function() {
                            return i.config.open_tree_initially
                        }
                            ,
                            n.copyOnParse = function() {
                                return i.config.deepcopy_on_parse
                            }
                    }
                    var a = new e(n);
                    if (this.mixin(a, function(o) {
                        var l = null
                            , d = o._removeItemInner;
                        function c(u) {
                            l = null,
                                this.callEvent("onAfterUnselect", [u])
                        }
                        return o._removeItemInner = function(u) {
                            return l == u && c.call(this, u),
                            l && this.eachItem && this.eachItem(function(h) {
                                h.id == l && c.call(this, h.id)
                            }, u),
                                d.apply(this, arguments)
                        }
                            ,
                            o.attachEvent("onIdChange", function(u, h) {
                                o.getSelectedId() == u && o.silent(function() {
                                    o.unselect(u),
                                        o.select(h)
                                })
                            }),
                            {
                                select: function(u) {
                                    if (u) {
                                        if (l == u)
                                            return l;
                                        if (!this._skip_refresh && !this.callEvent("onBeforeSelect", [u]))
                                            return !1;
                                        this.unselect(),
                                            l = u,
                                        this._skip_refresh || (this.refresh(u),
                                            this.callEvent("onAfterSelect", [u]))
                                    }
                                    return l
                                },
                                getSelectedId: function() {
                                    return l
                                },
                                isSelected: function(u) {
                                    return u == l
                                },
                                unselect: function(u) {
                                    (u = u || l) && (l = null,
                                    this._skip_refresh || (this.refresh(u),
                                        c.call(this, u)))
                                }
                            }
                    }(a)),
                        n.name) {
                        var r = "datastore:" + n.name;
                        a.attachEvent("onDestroy", (function() {
                                this.$services.dropService(r);
                                for (var o = this.$services.getService("datastores"), l = 0; l < o.length; l++)
                                    if (o[l] === n.name) {
                                        o.splice(l, 1);
                                        break
                                    }
                            }
                        ).bind(this)),
                            this.$services.dropService(r),
                            this.$services.setService(r, function() {
                                return a
                            });
                        var s = this.$services.getService("datastores");
                        s ? s.indexOf(n.name) < 0 && s.push(n.name) : (s = [],
                            this.$services.setService("datastores", function() {
                                return s
                            }),
                            s.push(n.name)),
                            Ci(n.name, this)
                    }
                    return a
                },
                getDatastore: function(n) {
                    return this.$services.getService("datastore:" + n)
                },
                _getDatastores: Ee,
                refreshData: function() {
                    var n;
                    K(this) || (n = this.getScrollState()),
                        this.callEvent("onBeforeDataRender", []);
                    for (var e = Ee.call(this), i = 0; i < e.length; i++)
                        e[i].refresh();
                    this.config.preserve_scroll && !K(this) && (n.x || n.y) && this.scrollTo(n.x, n.y),
                        this.callEvent("onDataRender", [])
                },
                isChildOf: function(n, e) {
                    return this.$data.tasksStore.isChildOf(n, e)
                },
                refreshTask: function(n, e) {
                    var i = this.getTask(n)
                        , a = this;
                    function r() {
                        if (e === void 0 || e) {
                            for (var o = 0; o < i.$source.length; o++)
                                a.refreshLink(i.$source[o]);
                            for (o = 0; o < i.$target.length; o++)
                                a.refreshLink(i.$target[o])
                        }
                    }
                    if (i && this.isTaskVisible(n))
                        this.$data.tasksStore.refresh(n, !!this.getState("tasksDnd").drag_id || e === !1),
                            r();
                    else if (this.isTaskExists(n) && this.isTaskExists(this.getParent(n)) && !this._bulk_dnd) {
                        this.refreshTask(this.getParent(n));
                        var s = !1;
                        this.eachParent(function(o) {
                            (s || this.isSplitTask(o)) && (s = !0)
                        }, n),
                        s && r()
                    }
                },
                refreshLink: function(n) {
                    this.$data.linksStore.refresh(n, !!this.getState("tasksDnd").drag_id)
                },
                silent: function(n) {
                    var e = this;
                    e.$data.tasksStore.silent(function() {
                        e.$data.linksStore.silent(function() {
                            n()
                        })
                    })
                },
                clearAll: function() {
                    for (var n = Ee.call(this), e = 0; e < n.length; e++)
                        n[e].silent(function() {
                            n[e].clearAll()
                        });
                    for (e = 0; e < n.length; e++)
                        n[e].clearAll();
                    this._update_flags(),
                        this.userdata = {},
                        this.callEvent("onClear", []),
                        this.render()
                },
                _clear_data: function() {
                    this.$data.tasksStore.clearAll(),
                        this.$data.linksStore.clearAll(),
                        this._update_flags(),
                        this.userdata = {}
                },
                selectTask: function(n) {
                    var e = this.$data.tasksStore;
                    if (!this.config.select_task)
                        return !1;
                    if (n = ot(n, this.config.root_id)) {
                        let i = this.getSelectedId();
                        e._skipResourceRepaint = !0,
                            e.select(n),
                            e._skipResourceRepaint = !1,
                        i && e.pull[i].$split_subtask && i != n && this.refreshTask(i),
                        e.pull[n].$split_subtask && i != n && this.refreshTask(n)
                    }
                    return e.getSelectedId()
                },
                unselectTask: function(n) {
                    var e = this.$data.tasksStore;
                    e.unselect(n),
                    n && e.pull[n].$split_subtask && this.refreshTask(n)
                },
                isSelectedTask: function(n) {
                    return this.$data.tasksStore.isSelected(n)
                },
                getSelectedId: function() {
                    return this.$data.tasksStore.getSelectedId()
                }
            });
            return O(t, {
                getTask: function(n) {
                    n = ot(n, this.config.root_id),
                        this.assert(n, "Invalid argument for gantt.getTask");
                    var e = this.$data.tasksStore.getItem(n);
                    return this.assert(e, "Task not found id=" + n),
                        e
                },
                getTaskByTime: function(n, e) {
                    var i = this.$data.tasksStore.getItems()
                        , a = [];
                    if (n || e) {
                        n = +n || -1 / 0,
                            e = +e || 1 / 0;
                        for (var r = 0; r < i.length; r++) {
                            var s = i[r];
                            +s.start_date < e && +s.end_date > n && a.push(s)
                        }
                    } else
                        a = i;
                    return a
                },
                isTaskExists: function(n) {
                    return !(!this.$data || !this.$data.tasksStore) && this.$data.tasksStore.exists(n)
                },
                updateTask: function(n, e) {
                    U(e) || (e = this.getTask(n)),
                        this.$data.tasksStore.updateItem(n, e),
                    this.isTaskExists(n) && this.refreshTask(n)
                },
                addTask: function(n, e, i) {
                    if (U(n.id) || (n.id = ut()),
                    this.isTaskExists(n.id) && this.getTask(n.id).$index != n.$index)
                        return n.start_date && typeof n.start_date == "string" && (n.start_date = this.date.parseDate(n.start_date, "parse_date")),
                        n.end_date && typeof n.end_date == "string" && (n.end_date = this.date.parseDate(n.end_date, "parse_date")),
                            this.$data.tasksStore.updateItem(n.id, n);
                    if (U(e) || (e = this.getParent(n) || 0),
                    this.isTaskExists(e) || (e = this.config.root_id),
                        this.setParent(n, e),
                    this.getState().lightbox && this.isTaskExists(e)) {
                        var a = this.getTask(e);
                        this.callEvent("onAfterParentExpand", [e, a])
                    }
                    return this.$data.tasksStore.addItem(n, i, e)
                },
                deleteTask: function(n) {
                    return n = ot(n, this.config.root_id),
                        this.$data.tasksStore.removeItem(n)
                },
                getTaskCount: function() {
                    return this.$data.tasksStore.count()
                },
                getVisibleTaskCount: function() {
                    return this.$data.tasksStore.countVisible()
                },
                getTaskIndex: function(n) {
                    return this.$data.tasksStore.getBranchIndex(n)
                },
                getGlobalTaskIndex: function(n) {
                    return n = ot(n, this.config.root_id),
                        this.assert(n, "Invalid argument"),
                        this.$data.tasksStore.getIndexById(n)
                },
                eachTask: function(n, e, i) {
                    return this.$data.tasksStore.eachItem(z(n, i || this), e)
                },
                eachParent: function(n, e, i) {
                    return this.$data.tasksStore.eachParent(z(n, i || this), e)
                },
                changeTaskId: function(n, e) {
                    this.$data.tasksStore.changeId(n, e);
                    var i = this.$data.tasksStore.getItem(e)
                        , a = [];
                    i.$source && (a = a.concat(i.$source)),
                    i.$target && (a = a.concat(i.$target));
                    for (var r = 0; r < a.length; r++) {
                        var s = this.getLink(a[r]);
                        s.source == n && (s.source = e),
                        s.target == n && (s.target = e)
                    }
                },
                calculateTaskLevel: function(n) {
                    return this.$data.tasksStore.calculateItemLevel(n)
                },
                getNext: function(n) {
                    return this.$data.tasksStore.getNext(n)
                },
                getPrev: function(n) {
                    return this.$data.tasksStore.getPrev(n)
                },
                getParent: function(n) {
                    return this.$data.tasksStore.getParent(n)
                },
                setParent: function(n, e, i) {
                    return this.$data.tasksStore.setParent(n, e, i)
                },
                getSiblings: function(n) {
                    return this.$data.tasksStore.getSiblings(n).slice()
                },
                getNextSibling: function(n) {
                    return this.$data.tasksStore.getNextSibling(n)
                },
                getPrevSibling: function(n) {
                    return this.$data.tasksStore.getPrevSibling(n)
                },
                getTaskByIndex: function(n) {
                    var e = this.$data.tasksStore.getIdByIndex(n);
                    return this.isTaskExists(e) ? this.getTask(e) : null
                },
                getChildren: function(n) {
                    return this.hasChild(n) ? this.$data.tasksStore.getChildren(n).slice() : []
                },
                hasChild: function(n) {
                    return this.$data.tasksStore.hasChild(n)
                },
                open: function(n) {
                    this.$data.tasksStore.open(n)
                },
                close: function(n) {
                    this.$data.tasksStore.close(n)
                },
                moveTask: function(n, e, i) {
                    return i = ot(i, this.config.root_id),
                        this.$data.tasksStore.move.apply(this.$data.tasksStore, arguments)
                },
                sort: function(n, e, i, a) {
                    var r = !a;
                    this.$data.tasksStore.sort(n, e, i),
                        this.callEvent("onAfterSort", [n, e, i]),
                    r && this.render()
                }
            }),
                O(t, {
                    getLinkCount: function() {
                        return this.$data.linksStore.count()
                    },
                    getLink: function(n) {
                        return this.$data.linksStore.getItem(n)
                    },
                    getLinks: function() {
                        return this.$data.linksStore.getItems()
                    },
                    isLinkExists: function(n) {
                        return this.$data.linksStore.exists(n)
                    },
                    addLink: function(n) {
                        return this.$data.linksStore.addItem(n)
                    },
                    updateLink: function(n, e) {
                        U(e) || (e = this.getLink(n)),
                            this.$data.linksStore.updateItem(n, e)
                    },
                    deleteLink: function(n) {
                        return this.$data.linksStore.removeItem(n)
                    },
                    changeLinkId: function(n, e) {
                        return this.$data.linksStore.changeId(n, e)
                    }
                }),
                t
        }
    };
    function Tn(t) {
        var n = t.date
            , e = t.$services;
        return {
            getSum: function(i, a, r) {
                r === void 0 && (r = i.length - 1),
                a === void 0 && (a = 0);
                for (var s = 0, o = a; o <= r; o++)
                    s += i[o];
                return s
            },
            setSumWidth: function(i, a, r, s) {
                var o = a.width;
                s === void 0 && (s = o.length - 1),
                r === void 0 && (r = 0);
                var l = s - r + 1;
                if (!(r > o.length - 1 || l <= 0 || s > o.length - 1)) {
                    var d = i - this.getSum(o, r, s);
                    this.adjustSize(d, o, r, s),
                        this.adjustSize(-d, o, s + 1),
                        a.full_width = this.getSum(o)
                }
            },
            splitSize: function(i, a) {
                for (var r = [], s = 0; s < a; s++)
                    r[s] = 0;
                return this.adjustSize(i, r),
                    r
            },
            adjustSize: function(i, a, r, s) {
                r || (r = 0),
                s === void 0 && (s = a.length - 1);
                for (var o = s - r + 1, l = this.getSum(a, r, s), d = r; d <= s; d++) {
                    var c = Math.floor(i * (l ? a[d] / l : 1 / o));
                    l -= a[d],
                        i -= c,
                        o--,
                        a[d] += c
                }
                a[a.length - 1] += i
            },
            sortScales: function(i) {
                function a(s, o) {
                    var l = new Date(1970,0,1);
                    return n.add(l, o, s) - l
                }
                i.sort(function(s, o) {
                    return a(s.unit, s.step) < a(o.unit, o.step) ? 1 : a(s.unit, s.step) > a(o.unit, o.step) ? -1 : 0
                });
                for (var r = 0; r < i.length; r++)
                    i[r].index = r
            },
            _isLegacyMode: function(i) {
                var a = i || t.config;
                return a.scale_unit || a.date_scale || a.subscales
            },
            _prepareScaleObject: function(i) {
                var a = i.format;
                return a || (a = i.template || i.date || "%d %M"),
                typeof a == "string" && (a = t.date.date_to_str(a)),
                    {
                        unit: i.unit || "day",
                        step: i.step || 1,
                        format: a,
                        css: i.css
                    }
            },
            primaryScale: function(i) {
                var a, r = e.getService("templateLoader"), s = this._isLegacyMode(i), o = i || t.config;
                if (s)
                    r.initTemplate("date_scale", void 0, void 0, o, t.config.templates),
                        a = {
                            unit: t.config.scale_unit,
                            step: t.config.step,
                            template: t.templates.date_scale,
                            date: t.config.date_scale,
                            css: t.templates.scale_cell_class
                        };
                else {
                    var l = o.scales[0];
                    a = {
                        unit: l.unit,
                        step: l.step,
                        template: l.template,
                        format: l.format,
                        date: l.date,
                        css: l.css || t.templates.scale_cell_class
                    }
                }
                return this._prepareScaleObject(a)
            },
            getSubScales: function(i) {
                var a, r = this._isLegacyMode(i), s = i || t.config;
                if (r) {
                    let o = "https://docs.dhtmlx.com/gantt/migrating.html#:~:text=%3D%20false%3B-,Time%20scale%20settings,-Configuration%20of%20time";
                    t.env.isFF && (o = "https://docs.dhtmlx.com/gantt/migrating.html#6162"),
                        console.warn(`You are using the obsolete scale configuration.
It will stop working in the future versions.
Please migrate the configuration to the newer version:
${o}`),
                        a = s.subscales || []
                } else
                    a = s.scales.slice(1);
                return a.map((function(o) {
                        return this._prepareScaleObject(o)
                    }
                ).bind(this))
            },
            prepareConfigs: function(i, a, r, s, o, l, d) {
                for (var c = this.splitSize(s, i.length), u = r, h = [], _ = i.length - 1; _ >= 0; _--) {
                    var f = _ == i.length - 1
                        , y = this.initScaleConfig(i[_], o, l);
                    f && this.processIgnores(y),
                        this.initColSizes(y, a, u, c[_]),
                        this.limitVisibleRange(y),
                    f && (u = y.full_width),
                        h.unshift(y)
                }
                for (_ = 0; _ < h.length - 1; _++)
                    this.alineScaleColumns(h[h.length - 1], h[_]);
                for (_ = 0; _ < h.length; _++)
                    d && this.reverseScale(h[_]),
                        this.setPosSettings(h[_]);
                return h
            },
            reverseScale: function(i) {
                i.width = i.width.reverse(),
                    i.trace_x = i.trace_x.reverse();
                var a = i.trace_indexes;
                i.trace_indexes = {},
                    i.trace_index_transition = {},
                    i.rtl = !0;
                for (var r = 0; r < i.trace_x.length; r++)
                    i.trace_indexes[i.trace_x[r].valueOf()] = r,
                        i.trace_index_transition[a[i.trace_x[r].valueOf()]] = r;
                return i
            },
            setPosSettings: function(i) {
                for (var a = 0, r = i.trace_x.length; a < r; a++)
                    i.left.push((i.width[a - 1] || 0) + (i.left[a - 1] || 0))
            },
            _ignore_time_config: function(i, a) {
                if (t.config.skip_off_time) {
                    for (var r = !0, s = i, o = 0; o < a.step; o++)
                        o && (s = n.add(i, o, a.unit)),
                            r = r && !this.isWorkTime(s, a.unit);
                    return r
                }
                return !1
            },
            processIgnores: function(i) {
                i.ignore_x = {},
                    i.display_count = i.count
            },
            initColSizes: function(i, a, r, s) {
                var o = r;
                i.height = s;
                var l = i.display_count === void 0 ? i.count : i.display_count;
                l || (l = 1),
                    i.col_width = Math.floor(o / l),
                a && i.col_width < a && (i.col_width = a,
                    o = i.col_width * l),
                    i.width = [];
                for (var d = i.ignore_x || {}, c = 0; c < i.trace_x.length; c++)
                    if (d[i.trace_x[c].valueOf()] || i.display_count == i.count)
                        i.width[c] = 0;
                    else {
                        var u = 1;
                        i.unit == "month" && (u = Math.round((n.add(i.trace_x[c], i.step, i.unit) - i.trace_x[c]) / 864e5)),
                            i.width[c] = u
                    }
                this.adjustSize(o - this.getSum(i.width), i.width),
                    i.full_width = this.getSum(i.width)
            },
            initScaleConfig: function(i, a, r) {
                var s = O({
                    count: 0,
                    col_width: 0,
                    full_width: 0,
                    height: 0,
                    width: [],
                    left: [],
                    trace_x: [],
                    trace_indexes: {},
                    min_date: new Date(a),
                    max_date: new Date(r)
                }, i);
                return this.eachColumn(i.unit, i.step, a, r, function(o) {
                    s.count++,
                        s.trace_x.push(new Date(o)),
                        s.trace_indexes[o.valueOf()] = s.trace_x.length - 1
                }),
                    s.trace_x_ascending = s.trace_x.slice(),
                    s
            },
            iterateScales: function(i, a, r, s, o) {
                for (var l = a.trace_x, d = i.trace_x, c = r || 0, u = s || d.length - 1, h = 0, _ = 1; _ < l.length; _++) {
                    var f = i.trace_indexes[+l[_]];
                    f !== void 0 && f <= u && (o && o.apply(this, [h, _, c, f]),
                        c = f,
                        h = _)
                }
            },
            alineScaleColumns: function(i, a, r, s) {
                this.iterateScales(i, a, r, s, function(o, l, d, c) {
                    var u = this.getSum(i.width, d, c - 1);
                    this.getSum(a.width, o, l - 1) != u && this.setSumWidth(u, a, o, l - 1)
                })
            },
            eachColumn: function(i, a, r, s, o) {
                var l = new Date(r)
                    , d = new Date(s);
                n[i + "_start"] && (l = n[i + "_start"](l));
                var c = new Date(l);
                for (+c >= +d && (d = n.add(c, a, i)); +c < +d; ) {
                    o.call(this, new Date(c));
                    var u = c.getTimezoneOffset();
                    c = n.add(c, a, i),
                        c = t._correct_dst_change(c, u, a, i),
                    n[i + "_start"] && (c = n[i + "_start"](c))
                }
            },
            limitVisibleRange: function(i) {
                var a = i.trace_x
                    , r = i.width.length - 1
                    , s = 0;
                if (+a[0] < +i.min_date && r != 0) {
                    var o = Math.floor(i.width[0] * ((a[1] - i.min_date) / (a[1] - a[0])));
                    s += i.width[0] - o,
                        i.width[0] = o,
                        a[0] = new Date(i.min_date)
                }
                var l = a.length - 1
                    , d = a[l]
                    , c = n.add(d, i.step, i.unit);
                if (+c > +i.max_date && l > 0 && (o = i.width[l] - Math.floor(i.width[l] * ((c - i.max_date) / (c - d))),
                    s += i.width[l] - o,
                    i.width[l] = o),
                    s) {
                    for (var u = this.getSum(i.width), h = 0, _ = 0; _ < i.width.length; _++) {
                        var f = Math.floor(s * (i.width[_] / u));
                        i.width[_] += f,
                            h += f
                    }
                    this.adjustSize(s - h, i.width)
                }
            }
        }
    }
    function En(t) {
        var n = new Tn(t);
        return n.processIgnores = function(e) {
            var i = e.count;
            if (e.ignore_x = {},
            t.ignore_time || t.config.skip_off_time) {
                var a = t.ignore_time || function() {
                        return !1
                    }
                ;
                i = 0;
                for (var r = 0; r < e.trace_x.length; r++)
                    a.call(t, e.trace_x[r]) || this._ignore_time_config.call(t, e.trace_x[r], e) ? (e.ignore_x[e.trace_x[r].valueOf()] = !0,
                        e.ignored_colls = !0) : i++
            }
            e.display_count = i
        }
            ,
            n
    }
    function Ai(t) {
        var n = function(c) {
            var u = new Tn(c).primaryScale()
                , h = u.unit
                , _ = u.step;
            if (c.config.scale_offset_minimal) {
                var f = new En(c)
                    , y = [f.primaryScale()].concat(f.getSubScales());
                f.sortScales(y),
                    h = y[y.length - 1].unit,
                    _ = y[y.length - 1].step || 1
            }
            return {
                unit: h,
                step: _
            }
        }(t)
            , e = n.unit
            , i = n.step
            , a = function(c, u) {
            var h = {
                start_date: null,
                end_date: null
            };
            if (u.config.start_date && u.config.end_date) {
                h.start_date = u.date[c + "_start"](new Date(u.config.start_date));
                var _ = new Date(u.config.end_date)
                    , f = u.date[c + "_start"](new Date(_));
                _ = +_ != +f ? u.date.add(f, 1, c) : f,
                    h.end_date = _
            }
            return h
        }(e, t);
        if (!a.start_date || !a.end_date) {
            for (var r = !0, s = t.getTaskByTime(), o = 0; o < s.length; o++)
                if (s[o].type !== t.config.types.project) {
                    r = !1;
                    break
                }
            if (s.length && r) {
                var l = s[0].start_date
                    , d = t.date.add(l, 1, t.config.duration_unit);
                a = {
                    start_date: new Date(l),
                    end_date: new Date(d)
                }
            } else
                a = t.getSubtaskDates();
            a.start_date && a.end_date || (a = {
                start_date: new Date,
                end_date: new Date
            }),
                t.eachTask(function(c) {
                    t.config.deadlines && c.deadline && Ce(a, c.deadline, c.deadline),
                    c.constraint_date && c.constraint_type && t.config.constraint_types && c.constraint_type !== t.config.constraint_types.ASAP && c.constraint_type !== t.config.constraint_types.ALAP && Ce(a, c.constraint_date, c.constraint_date),
                    t.config.baselines && c.baselines && c.baselines.forEach(function(u) {
                        Ce(a, u.start_date, u.end_date)
                    })
                }),
                a.start_date = t.date[e + "_start"](a.start_date),
                a.start_date = t.calculateEndDate({
                    start_date: t.date[e + "_start"](a.start_date),
                    duration: -1,
                    unit: e,
                    step: i
                }),
                a.end_date = t.date[e + "_start"](a.end_date),
                a.end_date = t.calculateEndDate({
                    start_date: a.end_date,
                    duration: 2,
                    unit: e,
                    step: i
                })
        }
        t._min_date = a.start_date,
            t._max_date = a.end_date
    }
    function Ce(t, n, e) {
        n < t.start_date && (t.start_date = new Date(n)),
        e > t.end_date && (t.end_date = new Date(e))
    }
    function De(t) {
        Ai(t),
            function(n) {
                if (n.config.fit_tasks) {
                    var e = +n._min_date
                        , i = +n._max_date;
                    if (+n._min_date != e || +n._max_date != i)
                        return n.render(),
                            n.callEvent("onScaleAdjusted", []),
                            !0
                }
            }(t)
    }
    function Cn(t, n, e) {
        for (var i = 0; i < n.length; i++)
            t.isLinkExists(n[i]) && (e[n[i]] = t.getLink(n[i]))
    }
    function Dn(t, n, e) {
        Cn(t, n.$source, e),
            Cn(t, n.$target, e)
    }
    const Ae = {
        getSubtreeLinks: function(t, n) {
            var e = {};
            return t.isTaskExists(n) && Dn(t, t.getTask(n), e),
                t.eachTask(function(i) {
                    Dn(t, i, e)
                }, n),
                e
        },
        getSubtreeTasks: function(t, n) {
            var e = {};
            return t.eachTask(function(i) {
                e[i.id] = i
            }, n),
                e
        }
    };
    class Mi {
        constructor(n, e) {
            this.$gantt = n,
                this.$dp = e,
                this._dataProcessorHandlers = []
        }
        attach() {
            const n = this.$dp
                , e = this.$gantt
                , i = {}
                , a = o => this.clientSideDelete(o, n, e);
            this._dataProcessorHandlers.push(e.attachEvent("onAfterTaskAdd", function(o, l) {
                e.isTaskExists(o) && (n.setGanttMode("tasks"),
                    n.setUpdated(o, !0, "inserted"))
            })),
                this._dataProcessorHandlers.push(e.attachEvent("onAfterTaskUpdate", function(o, l) {
                    e.isTaskExists(o) && (n.setGanttMode("tasks"),
                        n.setUpdated(o, !0),
                    e._sendTaskOrder && e._sendTaskOrder(o, l))
                })),
                this._dataProcessorHandlers.push(e.attachEvent("onBeforeTaskDelete", function(o, l) {
                    return e.config.cascade_delete && (i[o] = {
                        tasks: Ae.getSubtreeTasks(e, o),
                        links: Ae.getSubtreeLinks(e, o)
                    }),
                    !n.deleteAfterConfirmation || (n.setGanttMode("tasks"),
                        n.setUpdated(o, !0, "deleted"),
                        !1)
                })),
                this._dataProcessorHandlers.push(e.attachEvent("onAfterTaskDelete", function(o, l) {
                    n.setGanttMode("tasks");
                    const d = !a(o)
                        , c = e.config.cascade_delete && i[o];
                    if (d || c) {
                        if (c) {
                            const u = n.updateMode;
                            n.setUpdateMode("off");
                            const h = i[o];
                            for (const _ in h.tasks)
                                a(_) || (n.storeItem(h.tasks[_]),
                                    n.setUpdated(_, !0, "deleted"));
                            n.setGanttMode("links");
                            for (const _ in h.links)
                                a(_) || (n.storeItem(h.links[_]),
                                    n.setUpdated(_, !0, "deleted"));
                            i[o] = null,
                            u !== "off" && n.sendAllData(),
                                n.setGanttMode("tasks"),
                                n.setUpdateMode(u)
                        }
                        d && (n.storeItem(l),
                        n.deleteAfterConfirmation || n.setUpdated(o, !0, "deleted")),
                        n.updateMode === "off" || n._tSend || n.sendAllData()
                    }
                })),
                this._dataProcessorHandlers.push(e.attachEvent("onAfterLinkUpdate", function(o, l) {
                    e.isLinkExists(o) && (n.setGanttMode("links"),
                        n.setUpdated(o, !0))
                })),
                this._dataProcessorHandlers.push(e.attachEvent("onAfterLinkAdd", function(o, l) {
                    e.isLinkExists(o) && (n.setGanttMode("links"),
                        n.setUpdated(o, !0, "inserted"))
                })),
                this._dataProcessorHandlers.push(e.attachEvent("onAfterLinkDelete", function(o, l) {
                    n.setGanttMode("links"),
                    !a(o) && (n.storeItem(l),
                        n.setUpdated(o, !0, "deleted"))
                })),
                this._dataProcessorHandlers.push(e.attachEvent("onRowDragEnd", function(o, l) {
                    e._sendTaskOrder(o, e.getTask(o))
                }));
            let r = null
                , s = null;
            this._dataProcessorHandlers.push(e.attachEvent("onTaskIdChange", function(o, l) {
                if (!n._waitMode)
                    return;
                const d = e.getChildren(l);
                if (d.length) {
                    r = r || {};
                    for (let u = 0; u < d.length; u++) {
                        const h = this.getTask(d[u]);
                        r[h.id] = h
                    }
                }
                const c = function(u) {
                    let h = [];
                    return u.$source && (h = h.concat(u.$source)),
                    u.$target && (h = h.concat(u.$target)),
                        h
                }(this.getTask(l));
                if (c.length) {
                    s = s || {};
                    for (let u = 0; u < c.length; u++) {
                        const h = this.getLink(c[u]);
                        s[h.id] = h
                    }
                }
            })),
                n.attachEvent("onAfterUpdateFinish", function() {
                    (r || s) && (e.batchUpdate(function() {
                        for (const o in r)
                            e.updateTask(r[o].id);
                        for (const o in s)
                            e.updateLink(s[o].id);
                        r = null,
                            s = null
                    }),
                        r ? e._dp.setGanttMode("tasks") : e._dp.setGanttMode("links"))
                }),
                n.attachEvent("onBeforeDataSending", function() {
                    if (this._tMode === "CUSTOM")
                        return !0;
                    let o = this._serverProcessor;
                    if (this._tMode === "REST-JSON" || this._tMode === "REST") {
                        const l = this._ganttMode;
                        o = o.substring(0, o.indexOf("?") > -1 ? o.indexOf("?") : o.length),
                            this.serverProcessor = o + (o.slice(-1) === "/" ? "" : "/") + l
                    } else {
                        const l = this._ganttMode + "s";
                        this.serverProcessor = o + e.ajax.urlSeparator(o) + "gantt_mode=" + l
                    }
                    return !0
                }),
                n.attachEvent("insertCallback", function(o, l, d, c) {
                    const u = o.data || e.xml._xmlNodeToJSON(o.firstChild)
                        , h = {
                        add: e.addTask,
                        isExist: e.isTaskExists
                    };
                    c === "links" && (h.add = e.addLink,
                        h.isExist = e.isLinkExists),
                    h.isExist.call(e, l) || (u.id = l,
                        h.add.call(e, u))
                }),
                n.attachEvent("updateCallback", function(o, l) {
                    const d = o.data || e.xml._xmlNodeToJSON(o.firstChild);
                    if (!e.isTaskExists(l))
                        return;
                    const c = e.getTask(l);
                    for (const u in d) {
                        let h = d[u];
                        switch (u) {
                            case "id":
                                continue;
                            case "start_date":
                            case "end_date":
                                h = e.defined(e.templates.xml_date) ? e.templates.xml_date(h) : e.templates.parse_date(h);
                                break;
                            case "duration":
                                c.end_date = e.calculateEndDate({
                                    start_date: c.start_date,
                                    duration: h,
                                    task: c
                                })
                        }
                        c[u] = h
                    }
                    e.updateTask(l),
                        e.refreshData()
                }),
                n.attachEvent("deleteCallback", function(o, l, d, c) {
                    const u = {
                        delete: e.deleteTask,
                        isExist: e.isTaskExists
                    };
                    c === "links" ? (u.delete = e.deleteLink,
                        u.isExist = e.isLinkExists) : c === "assignment" && (u.delete = function(h) {
                            e.$data.assignmentsStore.remove(h)
                        }
                            ,
                            u.isExist = function(h) {
                                return e.$data.assignmentsStore.exists(h)
                            }
                    ),
                    u.isExist.call(e, l) && u.delete.call(e, l)
                }),
                this.handleResourceCRUD(n, e),
                this.handleResourceAssignmentCRUD(n, e),
                this.handleBaselineCRUD(n, e)
        }
        clientSideDelete(n, e, i) {
            const a = e.updatedRows.slice();
            let r = !1;
            i.getUserData(n, "!nativeeditor_status", e._ganttMode) === "true_deleted" && (r = !0,
                e.setUpdated(n, !1));
            for (let s = 0; s < a.length && !e._in_progress[n]; s++)
                a[s] === n && (i.getUserData(n, "!nativeeditor_status", e._ganttMode) === "inserted" && (r = !0),
                    e.setUpdated(n, !1));
            return r
        }
        handleResourceAssignmentCRUD(n, e) {
            if (!e.config.resources || e.config.resources.dataprocessor_assignments !== !0)
                return;
            const i = e.getDatastore(e.config.resource_assignment_store)
                , a = {}
                , r = {};
            function s(o) {
                const l = o.id;
                i.exists(l) && (n.setGanttMode("assignment"),
                    n.setUpdated(l, !0, "inserted")),
                    delete r[l]
            }
            e.attachEvent("onBeforeTaskAdd", function(o, l) {
                return a[o] = !0,
                    !0
            }),
                e.attachEvent("onTaskIdChange", function(o, l) {
                    delete a[o]
                }),
                i.attachEvent("onAfterAdd", (o, l) => {
                        a[l.task_id] ? function(d) {
                            r[d.id] = d,
                                a[d.task_id] = !0
                        }(l) : s(l)
                    }
                ),
                i.attachEvent("onAfterUpdate", (o, l) => {
                        i.exists(o) && (r[o] ? s(l) : (n.setGanttMode("assignment"),
                            n.setUpdated(o, !0)))
                    }
                ),
                i.attachEvent("onAfterDelete", (o, l) => {
                        n.setGanttMode("assignment"),
                        !this.clientSideDelete(o, n, e) && (n.storeItem(l),
                            n.setUpdated(o, !0, "deleted"))
                    }
                )
        }
        handleResourceCRUD(n, e) {
            if (!e.config.resources || e.config.resources.dataprocessor_resources !== !0)
                return;
            const i = e.getDatastore(e.config.resource_store);
            i.attachEvent("onAfterAdd", (a, r) => {
                    (function(s) {
                            const o = s.id;
                            i.exists(o) && (n.setGanttMode("resource"),
                                n.setUpdated(o, !0, "inserted"))
                        }
                    )(r)
                }
            ),
                i.attachEvent("onAfterUpdate", (a, r) => {
                        i.exists(a) && (n.setGanttMode("resource"),
                            n.setUpdated(a, !0))
                    }
                ),
                i.attachEvent("onAfterDelete", (a, r) => {
                        n.setGanttMode("resource"),
                        !this.clientSideDelete(a, n, e) && (n.storeItem(r),
                            n.setUpdated(a, !0, "deleted"))
                    }
                )
        }
        handleBaselineCRUD(n, e) {
            if (!e.config.baselines || e.config.baselines.dataprocessor_baselines !== !0)
                return;
            const i = e.getDatastore(e.config.baselines.datastore);
            i.attachEvent("onAfterAdd", (a, r) => {
                    (function(s) {
                            const o = s.id;
                            i.exists(o) && (n.setGanttMode("baseline"),
                                n.setUpdated(o, !0, "inserted"))
                        }
                    )(r)
                }
            ),
                i.attachEvent("onAfterUpdate", (a, r) => {
                        i.exists(a) && (n.setGanttMode("baseline"),
                            n.setUpdated(a, !0))
                    }
                ),
                i.attachEvent("onAfterDelete", (a, r) => {
                        n.setGanttMode("baseline"),
                        !this.clientSideDelete(a, n, e) && (n.storeItem(r),
                            n.setUpdated(a, !0, "deleted"))
                    }
                )
        }
        detach() {
            st(this._dataProcessorHandlers, n => {
                    this.$gantt.detachEvent(n)
                }
            ),
                this._dataProcessorHandlers = []
        }
    }
    const de = class de {
            constructor() {
                this.clear = () => {
                    this._storage = {}
                }
                    ,
                    this.storeItem = n => {
                        this._storage[n.id] = X(n)
                    }
                    ,
                    this.getStoredItem = n => this._storage[n] || null,
                    this._storage = {}
            }
        }
    ;
    de.create = () => new de;
    let te = de
        , An = class {
            constructor(t) {
                this.serverProcessor = t,
                    this.action_param = "!nativeeditor_status",
                    this.updatedRows = [],
                    this.autoUpdate = !0,
                    this.updateMode = "cell",
                    this._headers = null,
                    this._payload = null,
                    this._postDelim = "_",
                    this._routerParametersFormat = "parameters",
                    this._waitMode = 0,
                    this._in_progress = {},
                    this._storage = te.create(),
                    this._invalid = {},
                    this.messages = [],
                    this.styles = {
                        updated: "font-weight:bold;",
                        inserted: "font-weight:bold;",
                        deleted: "text-decoration : line-through;",
                        invalid: "background-color:FFE0E0;",
                        invalid_cell: "border-bottom:2px solid red;",
                        error: "color:red;",
                        clear: "font-weight:normal;text-decoration:none;"
                    },
                    this.enableUTFencoding(!0),
                    ct(this)
            }
            setTransactionMode(t, n) {
                typeof t == "object" ? (this._tMode = t.mode || this._tMode,
                U(t.headers) && (this._headers = t.headers),
                U(t.payload) && (this._payload = t.payload),
                    this._tSend = !!n) : (this._tMode = t,
                    this._tSend = n),
                this._tMode === "REST" && (this._tSend = !1),
                    this._tMode === "JSON" || this._tMode === "REST-JSON" ? (this._tSend = !1,
                        this._serializeAsJson = !0,
                        this._headers = this._headers || {},
                        this._headers["Content-Type"] = "application/json") : this._headers && !this._headers["Content-Type"] && (this._headers["Content-Type"] = "application/x-www-form-urlencoded"),
                this._tMode === "CUSTOM" && (this._tSend = !1,
                    this._router = t.router)
            }
            escape(t) {
                return this._utf ? encodeURIComponent(t) : escape(t)
            }
            enableUTFencoding(t) {
                this._utf = !!t
            }
            getSyncState() {
                return !this.updatedRows.length
            }
            setUpdateMode(t, n) {
                this.autoUpdate = t === "cell",
                    this.updateMode = t,
                    this.dnd = n
            }
            ignore(t, n) {
                this._silent_mode = !0,
                    t.call(n || J),
                    this._silent_mode = !1
            }
            setUpdated(t, n, e) {
                if (this._silent_mode)
                    return;
                const i = this.findRow(t);
                e = e || "updated";
                const a = this.$gantt.getUserData(t, this.action_param, this._ganttMode);
                a && e === "updated" && (e = a),
                    n ? (this.set_invalid(t, !1),
                        this.updatedRows[i] = t,
                        this.$gantt.setUserData(t, this.action_param, e, this._ganttMode),
                    this._in_progress[t] && (this._in_progress[t] = "wait")) : this.is_invalid(t) || (this.updatedRows.splice(i, 1),
                        this.$gantt.setUserData(t, this.action_param, "", this._ganttMode)),
                    this.markRow(t, n, e),
                n && this.autoUpdate && this.sendData(t)
            }
            markRow(t, n, e) {
                let i = "";
                const a = this.is_invalid(t);
                if (a && (i = this.styles[a],
                    n = !0),
                this.callEvent("onRowMark", [t, n, e, a]) && (i = this.styles[n ? e : "clear"] + " " + i,
                    this.$gantt[this._methods[0]](t, i),
                a && a.details)) {
                    i += this.styles[a + "_cell"];
                    for (let r = 0; r < a.details.length; r++)
                        a.details[r] && this.$gantt[this._methods[1]](t, r, i)
                }
            }
            getActionByState(t) {
                return t === "inserted" ? "create" : t === "updated" ? "update" : t === "deleted" ? "delete" : "update"
            }
            getState(t) {
                return this.$gantt.getUserData(t, this.action_param, this._ganttMode)
            }
            is_invalid(t) {
                return this._invalid[t]
            }
            set_invalid(t, n, e) {
                e && (n = {
                    value: n,
                    details: e,
                    toString: function() {
                        return this.value.toString()
                    }
                }),
                    this._invalid[t] = n
            }
            checkBeforeUpdate(t) {
                return !0
            }
            sendData(t) {
                if (this.$gantt.editStop && this.$gantt.editStop(),
                t === void 0 || this._tSend) {
                    const n = [];
                    if (this.modes && ["task", "link", "assignment", "baseline"].forEach(e => {
                            this.modes[e] && this.modes[e].updatedRows.length && n.push(e)
                        }
                    ),
                        n.length) {
                        for (let e = 0; e < n.length; e++)
                            this.setGanttMode(n[e]),
                                this.sendAllData();
                        return
                    }
                    return this.sendAllData()
                }
                return !this._in_progress[t] && (this.messages = [],
                !(!this.checkBeforeUpdate(t) && this.callEvent("onValidationError", [t, this.messages])) && void this._beforeSendData(this._getRowData(t), t))
            }
            serialize(t, n) {
                if (this._serializeAsJson)
                    return this._serializeAsJSON(t);
                if (typeof t == "string")
                    return t;
                if (n !== void 0)
                    return this.serialize_one(t, "");
                {
                    const e = []
                        , i = [];
                    for (const a in t)
                        t.hasOwnProperty(a) && (e.push(this.serialize_one(t[a], a + this._postDelim)),
                            i.push(a));
                    return e.push("ids=" + this.escape(i.join(","))),
                    this.$gantt.security_key && e.push("dhx_security=" + this.$gantt.security_key),
                        e.join("&")
                }
            }
            serialize_one(t, n) {
                if (typeof t == "string")
                    return t;
                const e = [];
                let i = "";
                for (const a in t)
                    if (t.hasOwnProperty(a)) {
                        if ((a === "id" || a == this.action_param) && this._tMode === "REST")
                            continue;
                        i = typeof t[a] == "string" || typeof t[a] == "number" ? String(t[a]) : JSON.stringify(t[a]),
                            e.push(this.escape((n || "") + a) + "=" + this.escape(i))
                    }
                return e.join("&")
            }
            sendAllData() {
                if (!this.updatedRows.length)
                    return;
                this.messages = [];
                let t = !0;
                if (this._forEachUpdatedRow(function(n) {
                    t = t && this.checkBeforeUpdate(n)
                }),
                !t && !this.callEvent("onValidationError", ["", this.messages]))
                    return !1;
                this._tSend ? this._sendData(this._getAllData()) : this._forEachUpdatedRow(function(n) {
                    if (!this._in_progress[n]) {
                        if (this.is_invalid(n))
                            return;
                        this._beforeSendData(this._getRowData(n), n)
                    }
                })
            }
            findRow(t) {
                let n = 0;
                for (n = 0; n < this.updatedRows.length && t != this.updatedRows[n]; n++)
                    ;
                return n
            }
            defineAction(t, n) {
                this._uActions || (this._uActions = {}),
                    this._uActions[t] = n
            }
            afterUpdateCallback(t, n, e, i, a) {
                if (!this.$gantt)
                    return;
                this.setGanttMode(a);
                const r = t
                    , s = e !== "error" && e !== "invalid";
                if (s || this.set_invalid(t, e),
                this._uActions && this._uActions[e] && !this._uActions[e](i))
                    return delete this._in_progress[r];
                this._in_progress[r] !== "wait" && this.setUpdated(t, !1);
                const o = t;
                switch (e) {
                    case "inserted":
                    case "insert":
                        n != t && (this.setUpdated(t, !1),
                            this.$gantt[this._methods[2]](t, n),
                            t = n);
                        break;
                    case "delete":
                    case "deleted":
                        if (this.deleteAfterConfirmation && this._ganttMode === "task") {
                            if (this._ganttMode === "task" && this.$gantt.isTaskExists(t)) {
                                this.$gantt.setUserData(t, this.action_param, "true_deleted", this._ganttMode);
                                const l = this.$gantt.getTask(t);
                                this.$gantt.silent( () => {
                                        this.$gantt.deleteTask(t)
                                    }
                                ),
                                    this.$gantt.callEvent("onAfterTaskDelete", [t, l]),
                                    this.$gantt.render(),
                                    delete this._in_progress[r]
                            }
                            return this.callEvent("onAfterUpdate", [t, e, n, i])
                        }
                        return this.$gantt.setUserData(t, this.action_param, "true_deleted", this._ganttMode),
                            this.$gantt[this._methods[3]](t),
                            delete this._in_progress[r],
                            this.callEvent("onAfterUpdate", [t, e, n, i])
                }
                this._in_progress[r] !== "wait" ? (s && this.$gantt.setUserData(t, this.action_param, "", this._ganttMode),
                    delete this._in_progress[r]) : (delete this._in_progress[r],
                    this.setUpdated(n, !0, this.$gantt.getUserData(t, this.action_param, this._ganttMode))),
                    this.callEvent("onAfterUpdate", [o, e, n, i])
            }
            afterUpdate(t, n, e) {
                let i;
                i = arguments.length === 3 ? arguments[1] : arguments[4];
                let a = this.getGanttMode();
                const r = i.filePath || i.url;
                a = this._tMode !== "REST" && this._tMode !== "REST-JSON" ? r.indexOf("gantt_mode=links") !== -1 ? "link" : r.indexOf("gantt_mode=assignments") !== -1 ? "assignment" : r.indexOf("gantt_mode=baselines") !== -1 ? "baseline" : "task" : r.indexOf("/link") >= 0 ? "link" : r.indexOf("/assignment") >= 0 ? "assignment" : r.indexOf("/baseline") >= 0 ? "baseline" : "task",
                    this.setGanttMode(a);
                const s = this.$gantt.ajax;
                let o;
                try {
                    o = JSON.parse(n.xmlDoc.responseText)
                } catch {
                    n.xmlDoc.responseText.length || (o = {})
                }
                const l = u => {
                        const h = o.action || this.getState(u) || "updated"
                            , _ = o.sid || u[0]
                            , f = o.tid || u[0];
                        t.afterUpdateCallback(_, f, h, o, a)
                    }
                ;
                if (o)
                    return Array.isArray(e) && e.length > 1 ? e.forEach(u => l(u)) : l(e),
                        t.finalizeUpdate(),
                        void this.setGanttMode(a);
                const d = s.xmltop("data", n.xmlDoc);
                if (!d)
                    return this.cleanUpdate(e);
                const c = s.xpath("//data/action", d);
                if (!c.length)
                    return this.cleanUpdate(e);
                for (let u = 0; u < c.length; u++) {
                    const h = c[u]
                        , _ = h.getAttribute("type")
                        , f = h.getAttribute("sid")
                        , y = h.getAttribute("tid");
                    t.afterUpdateCallback(f, y, _, h, a)
                }
                t.finalizeUpdate()
            }
            cleanUpdate(t) {
                if (t)
                    for (let n = 0; n < t.length; n++)
                        delete this._in_progress[t[n]]
            }
            finalizeUpdate() {
                this._waitMode && this._waitMode--,
                    this.callEvent("onAfterUpdateFinish", []),
                this.updatedRows.length || this.callEvent("onFullSync", [])
            }
            init(t) {
                if (this._initialized)
                    return;
                this.$gantt = t,
                this.$gantt._dp_init && this.$gantt._dp_init(this),
                    this._setDefaultTransactionMode(),
                    this.styles = {
                        updated: "gantt_updated",
                        order: "gantt_updated",
                        inserted: "gantt_inserted",
                        deleted: "gantt_deleted",
                        delete_confirmation: "gantt_deleted",
                        invalid: "gantt_invalid",
                        error: "gantt_error",
                        clear: ""
                    },
                    this._methods = ["_row_style", "setCellTextStyle", "_change_id", "_delete_task"],
                    function(e, i) {
                        e.getUserData = function(a, r, s) {
                            return this.userdata || (this.userdata = {}),
                                this.userdata[s] = this.userdata[s] || {},
                                this.userdata[s][a] && this.userdata[s][a][r] ? this.userdata[s][a][r] : ""
                        }
                            ,
                            e.setUserData = function(a, r, s, o) {
                                this.userdata || (this.userdata = {}),
                                    this.userdata[o] = this.userdata[o] || {},
                                    this.userdata[o][a] = this.userdata[o][a] || {},
                                    this.userdata[o][a][r] = s
                            }
                            ,
                            e._change_id = function(a, r) {
                                switch (this._dp._ganttMode) {
                                    case "task":
                                        this.changeTaskId(a, r);
                                        break;
                                    case "link":
                                        this.changeLinkId(a, r);
                                        break;
                                    case "assignment":
                                        this.$data.assignmentsStore.changeId(a, r);
                                        break;
                                    case "resource":
                                        this.$data.resourcesStore.changeId(a, r);
                                        break;
                                    case "baseline":
                                        this.$data.baselineStore.changeId(a, r);
                                        break;
                                    default:
                                        throw new Error(`Invalid mode of the dataProcessor after database id is received: ${this._dp._ganttMode}, new id: ${r}`)
                                }
                            }
                            ,
                            e._row_style = function(a, r) {
                                this._dp._ganttMode === "task" && e.isTaskExists(a) && (e.getTask(a).$dataprocessor_class = r,
                                    e.refreshTask(a))
                            }
                            ,
                            e._delete_task = function(a, r) {}
                            ,
                            e._sendTaskOrder = function(a, r) {
                                r.$drop_target && (this._dp.setGanttMode("task"),
                                    this.getTask(a).target = r.$drop_target,
                                    this._dp.setUpdated(a, !0, "order"),
                                    delete this.getTask(a).$drop_target)
                            }
                            ,
                            e.setDp = function() {
                                this._dp = i
                            }
                            ,
                            e.setDp()
                    }(this.$gantt, this);
                const n = new Mi(this.$gantt,this);
                n.attach(),
                    this.attachEvent("onDestroy", function() {
                        delete this.setGanttMode,
                            delete this._getRowData,
                            delete this.$gantt._dp,
                            delete this.$gantt._change_id,
                            delete this.$gantt._row_style,
                            delete this.$gantt._delete_task,
                            delete this.$gantt._sendTaskOrder,
                            delete this.$gantt,
                            n.detach()
                    }),
                    this.$gantt.callEvent("onDataProcessorReady", [this]),
                    this._initialized = !0
            }
            setOnAfterUpdate(t) {
                this.attachEvent("onAfterUpdate", t)
            }
            setOnBeforeUpdateHandler(t) {
                this.attachEvent("onBeforeDataSending", t)
            }
            setAutoUpdate(t, n) {
                t = t || 2e3,
                    this._user = n || new Date().valueOf(),
                    this._needUpdate = !1,
                    this._updateBusy = !1,
                    this.attachEvent("onAfterUpdate", this.afterAutoUpdate),
                    this.attachEvent("onFullSync", this.fullSync),
                    setInterval( () => {
                            this.loadUpdate()
                        }
                        , t)
            }
            afterAutoUpdate(t, n, e, i) {
                return n !== "collision" || (this._needUpdate = !0,
                    !1)
            }
            fullSync() {
                return this._needUpdate && (this._needUpdate = !1,
                    this.loadUpdate()),
                    !0
            }
            getUpdates(t, n) {
                const e = this.$gantt.ajax;
                if (this._updateBusy)
                    return !1;
                this._updateBusy = !0,
                    e.get(t, n)
            }
            loadUpdate() {
                const t = this.$gantt.ajax
                    , n = this.$gantt.getUserData(0, "version", this._ganttMode);
                let e = this.serverProcessor + t.urlSeparator(this.serverProcessor) + ["dhx_user=" + this._user, "dhx_version=" + n].join("&");
                e = e.replace("editing=true&", ""),
                    this.getUpdates(e, i => {
                            const a = t.xpath("//userdata", i);
                            this.$gantt.setUserData(0, "version", this._getXmlNodeValue(a[0]), this._ganttMode);
                            const r = t.xpath("//update", i);
                            if (r.length) {
                                this._silent_mode = !0;
                                for (let s = 0; s < r.length; s++) {
                                    const o = r[s].getAttribute("status")
                                        , l = r[s].getAttribute("id")
                                        , d = r[s].getAttribute("parent");
                                    switch (o) {
                                        case "inserted":
                                            this.callEvent("insertCallback", [r[s], l, d]);
                                            break;
                                        case "updated":
                                            this.callEvent("updateCallback", [r[s], l, d]);
                                            break;
                                        case "deleted":
                                            this.callEvent("deleteCallback", [r[s], l, d])
                                    }
                                }
                                this._silent_mode = !1
                            }
                            this._updateBusy = !1
                        }
                    )
            }
            destructor() {
                this.callEvent("onDestroy", []),
                    this.detachAllEvents(),
                    this.updatedRows = [],
                    this._in_progress = {},
                    this._invalid = {},
                    this._storage.clear(),
                    this._storage = null,
                    this._headers = null,
                    this._payload = null,
                    delete this._initialized
            }
            setGanttMode(t) {
                t === "tasks" ? t = "task" : t === "links" && (t = "link");
                const n = this.modes || {}
                    , e = this.getGanttMode();
                e && (n[e] = {
                    _in_progress: this._in_progress,
                    _invalid: this._invalid,
                    _storage: this._storage,
                    updatedRows: this.updatedRows
                });
                let i = n[t];
                i || (i = n[t] = {
                    _in_progress: {},
                    _invalid: {},
                    _storage: te.create(),
                    updatedRows: []
                }),
                    this._in_progress = i._in_progress,
                    this._invalid = i._invalid,
                    this._storage = i._storage,
                    this.updatedRows = i.updatedRows,
                    this.modes = n,
                    this._ganttMode = t
            }
            getGanttMode() {
                return this._ganttMode
            }
            storeItem(t) {
                this._storage.storeItem(t)
            }
            url(t) {
                this.serverProcessor = this._serverProcessor = t
            }
            _beforeSendData(t, n) {
                if (!this.callEvent("onBeforeUpdate", [n, this.getState(n), t]))
                    return !1;
                this._sendData(t, n)
            }
            _serializeAsJSON(t) {
                if (typeof t == "string")
                    return t;
                const n = X(t);
                return this._tMode === "REST-JSON" && (delete n.id,
                    delete n[this.action_param]),
                    JSON.stringify(n)
            }
            _applyPayload(t) {
                const n = this.$gantt.ajax;
                if (this._payload)
                    for (const e in this._payload)
                        t = t + n.urlSeparator(t) + this.escape(e) + "=" + this.escape(this._payload[e]);
                return t
            }
            _cleanupArgumentsBeforeSend(t) {
                let n;
                if (t[this.action_param] === void 0) {
                    n = {};
                    for (const e in t)
                        n[e] = this._cleanupArgumentsBeforeSend(t[e])
                } else
                    n = this._cleanupItemBeforeSend(t);
                return n
            }
            _cleanupItemBeforeSend(t) {
                let n = null;
                return t && (t[this.action_param] === "deleted" ? (n = {},
                    n.id = t.id,
                    n[this.action_param] = t[this.action_param]) : n = t),
                    n
            }
            _sendData(t, n) {
                if (!t)
                    return;
                if (!this.callEvent("onBeforeDataSending", n ? [n, this.getState(n), t] : [null, null, t]))
                    return !1;
                n && (this._in_progress[n] = new Date().valueOf());
                const e = this.$gantt.ajax;
                if (this._tMode === "CUSTOM") {
                    const l = this.getState(n)
                        , d = this.getActionByState(l);
                    delete t[this.action_param];
                    const c = this.getGanttMode()
                        , u = _ => {
                            let f = l || "updated"
                                , y = n
                                , v = n;
                            _ && (f = _.action || l,
                                y = _.sid || y,
                                v = _.id || _.tid || v),
                                this.afterUpdateCallback(y, v, f, _, c)
                        }
                    ;
                    let h;
                    if (this._router instanceof Function)
                        if (this._routerParametersFormat === "object") {
                            const _ = {
                                entity: c,
                                action: d,
                                data: t,
                                id: n
                            };
                            h = this._router(_)
                        } else
                            h = this._router(c, d, t, n);
                    else if (this._router[c]instanceof Function)
                        h = this._router[c](d, t, n);
                    else {
                        const _ = "Incorrect configuration of gantt.createDataProcessor"
                            , f = `
You need to either add missing properties to the dataProcessor router object or to use a router function.
See https://docs.dhtmlx.com/gantt/desktop__server_side.html#customrouting and https://docs.dhtmlx.com/gantt/api__gantt_createdataprocessor.html for details.`;
                        if (!this._router[c])
                            throw new Error(`${_}: router for the **${c}** entity is not defined. ${f}`);
                        switch (l) {
                            case "inserted":
                                if (!this._router[c].create)
                                    throw new Error(`${_}: **create** action for the **${c}** entity is not defined. ${f}`);
                                h = this._router[c].create(t);
                                break;
                            case "deleted":
                                if (!this._router[c].delete)
                                    throw new Error(`${_}: **delete** action for the **${c}** entity is not defined. ${f}`);
                                h = this._router[c].delete(n);
                                break;
                            default:
                                if (!this._router[c].update)
                                    throw new Error(`${_}: **update**" action for the **${c}** entity is not defined. ${f}`);
                                h = this._router[c].update(t, n)
                        }
                    }
                    if (h) {
                        if (!h.then && h.id === void 0 && h.tid === void 0 && h.action === void 0)
                            throw new Error("Incorrect router return value. A Promise or a response object is expected");
                        h.then ? h.then(u).catch(_ => {
                                _ && _.action ? u(_) : u({
                                    action: "error",
                                    value: _
                                })
                            }
                        ) : u(h)
                    } else
                        u(null);
                    return
                }
                let i;
                i = {
                    callback: l => {
                        const d = [];
                        if (n)
                            d.push(n);
                        else if (t)
                            for (const c in t)
                                d.push(c);
                        return this.afterUpdate(this, l, d)
                    }
                    ,
                    headers: this._headers
                };
                const a = "dhx_version=" + this.$gantt.getUserData(0, "version", this._ganttMode)
                    , r = this.serverProcessor + (this._user ? e.urlSeparator(this.serverProcessor) + ["dhx_user=" + this._user, a].join("&") : "");
                let s, o = this._applyPayload(r);
                switch (this._tMode) {
                    case "GET":
                        s = this._cleanupArgumentsBeforeSend(t),
                            i.url = o + e.urlSeparator(o) + this.serialize(s, n),
                            i.method = "GET";
                        break;
                    case "POST":
                        s = this._cleanupArgumentsBeforeSend(t),
                            i.url = o,
                            i.method = "POST",
                            i.data = this.serialize(s, n);
                        break;
                    case "JSON":
                        s = {};
                        const l = this._cleanupItemBeforeSend(t);
                        for (const d in l)
                            d !== this.action_param && d !== "id" && d !== "gr_id" && (s[d] = l[d]);
                        i.url = o,
                            i.method = "POST",
                            i.data = JSON.stringify({
                                id: n,
                                action: t[this.action_param],
                                data: s
                            });
                        break;
                    case "REST":
                    case "REST-JSON":
                        switch (o = r.replace(/(&|\?)editing=true/, ""),
                            s = "",
                            this.getState(n)) {
                            case "inserted":
                                i.method = "POST",
                                    i.data = this.serialize(t, n);
                                break;
                            case "deleted":
                                i.method = "DELETE",
                                    o = o + (o.slice(-1) === "/" ? "" : "/") + n;
                                break;
                            default:
                                i.method = "PUT",
                                    i.data = this.serialize(t, n),
                                    o = o + (o.slice(-1) === "/" ? "" : "/") + n
                        }
                        i.url = this._applyPayload(o)
                }
                return this._waitMode++,
                    e.query(i)
            }
            _forEachUpdatedRow(t) {
                const n = this.updatedRows.slice();
                for (let e = 0; e < n.length; e++) {
                    const i = n[e];
                    this.$gantt.getUserData(i, this.action_param, this._ganttMode) && t.call(this, i)
                }
            }
            _setDefaultTransactionMode() {
                this.serverProcessor && (this.setTransactionMode("POST", !0),
                    this.serverProcessor += (this.serverProcessor.indexOf("?") !== -1 ? "&" : "?") + "editing=true",
                    this._serverProcessor = this.serverProcessor)
            }
            _getXmlNodeValue(t) {
                return t.firstChild ? t.firstChild.nodeValue : ""
            }
            _getAllData() {
                const t = {};
                let n = !1;
                return this._forEachUpdatedRow(function(e) {
                    if (this._in_progress[e] || this.is_invalid(e))
                        return;
                    const i = this._getRowData(e);
                    this.callEvent("onBeforeUpdate", [e, this.getState(e), i]) && (t[e] = i,
                        n = !0,
                        this._in_progress[e] = new Date().valueOf())
                }),
                    n ? t : null
            }
            _prepareDate(t) {
                return this.$gantt.defined(this.$gantt.templates.xml_format) ? this.$gantt.templates.xml_format(t) : this.$gantt.templates.format_date(t)
            }
            _prepareArray(t, n) {
                return n.push(t),
                    t.map(e => nt(e) ? this._prepareDate(e) : Array.isArray(e) && !Kt(n, e) ? this._prepareArray(e, n) : e && typeof e == "object" && !Kt(n, e) ? this._prepareObject(e, n) : e)
            }
            _prepareObject(t, n) {
                const e = {};
                n.push(t);
                for (const i in t) {
                    if (i.substr(0, 1) === "$")
                        continue;
                    const a = t[i];
                    nt(a) ? e[i] = this._prepareDate(a) : a === null ? e[i] = "" : Array.isArray(a) && !Kt(n, a) ? e[i] = this._prepareArray(a, n) : a && typeof a == "object" && !Kt(n, a) ? e[i] = this._prepareObject(a, n) : e[i] = a
                }
                return e
            }
            _prepareDataItem(t) {
                const n = this._prepareObject(t, []);
                return n[this.action_param] = this.$gantt.getUserData(t.id, this.action_param, this._ganttMode),
                    n
            }
            getStoredItem(t) {
                return this._storage.getStoredItem(t)
            }
            _getRowData(t) {
                let n;
                const e = this.$gantt;
                return this.getGanttMode() === "task" ? e.isTaskExists(t) && (n = this.$gantt.getTask(t)) : this.getGanttMode() === "assignment" ? this.$gantt.$data.assignmentsStore.exists(t) && (n = this.$gantt.$data.assignmentsStore.getItem(t)) : this.getGanttMode() === "baseline" ? this.$gantt.$data.baselineStore.exists(t) && (n = this.$gantt.$data.baselineStore.getItem(t)) : e.isLinkExists(t) && (n = this.$gantt.getLink(t)),
                n || (n = this.getStoredItem(t)),
                n || (n = {
                    id: t
                }),
                    this._prepareDataItem(n)
            }
        }
    ;
    const Ii = function(t) {
        return new An(t)
    }
        , Li = function(t) {
        let n, e, i;
        t instanceof Function ? n = t : t.hasOwnProperty("router") ? n = t.router : t.hasOwnProperty("assignment") || t.hasOwnProperty("baseline") || t.hasOwnProperty("link") || t.hasOwnProperty("task") ? n = t : t.hasOwnProperty("headers") && (i = t.headers),
            e = n ? "CUSTOM" : t.mode || "REST-JSON";
        const a = new An(t.url);
        return a.init(this),
            a.setTransactionMode({
                mode: e,
                router: n,
                headers: i
            }, t.batchUpdate),
        t.deleteAfterConfirmation && (a.deleteAfterConfirmation = t.deleteAfterConfirmation),
            a
    };
    function Ni(t) {
        var n = {}
            , e = !1;
        function i(l, d) {
            d = typeof d == "function" ? d : function() {}
                ,
            n[l] || (n[l] = this[l],
                this[l] = d)
        }
        function a(l) {
            n[l] && (this[l] = n[l],
                n[l] = null)
        }
        function r(l) {
            for (var d in l)
                i.call(this, d, l[d])
        }
        function s() {
            for (var l in n)
                a.call(this, l)
        }
        function o(l) {
            try {
                l()
            } catch (d) {
                J.console.error(d)
            }
        }
        return t.$services.getService("state").registerProvider("batchUpdate", function() {
            return {
                batch_update: e
            }
        }, !1),
            function(l, d) {
                if (e)
                    o(l);
                else {
                    var c, u = this._dp && this._dp.updateMode != "off";
                    u && (c = this._dp.updateMode,
                        this._dp.setUpdateMode("off"));
                    var h = {}
                        , _ = {
                        render: !0,
                        refreshData: !0,
                        refreshTask: !0,
                        refreshLink: !0,
                        resetProjectDates: function(y) {
                            h[y.id] = y
                        }
                    };
                    for (var f in r.call(this, _),
                        e = !0,
                        this.callEvent("onBeforeBatchUpdate", []),
                        o(l),
                        this.callEvent("onAfterBatchUpdate", []),
                        s.call(this),
                        h)
                        this.resetProjectDates(h[f]);
                    e = !1,
                    d || this.render(),
                    u && (this._dp.setUpdateMode(c),
                        this._dp.setGanttMode("task"),
                        this._dp.sendData(),
                        this._dp.setGanttMode("link"),
                        this._dp.sendData())
                }
            }
    }
    function Pi(t) {
        t.batchUpdate = Ni(t)
    }
    function Ri(t) {
        const n = function(i) {
            return {
                _needRecalc: !0,
                reset: function() {
                    this._needRecalc = !0
                },
                _isRecalcNeeded: function() {
                    return !this._isGroupSort() && this._needRecalc
                },
                _isGroupSort: function() {
                    return !!i.getState().group_mode
                },
                _getWBSCode: function(a) {
                    return a ? (this._isRecalcNeeded() && this._calcWBS(),
                        a.$virtual ? "" : this._isGroupSort() ? a.$wbs || "" : (a.$wbs || (this.reset(),
                            this._calcWBS()),
                            a.$wbs)) : ""
                },
                _setWBSCode: function(a, r) {
                    a.$wbs = r
                },
                getWBSCode: function(a) {
                    return this._getWBSCode(a)
                },
                getByWBSCode: function(a) {
                    let r = a.split(".")
                        , s = i.config.root_id;
                    for (let o = 0; o < r.length; o++) {
                        const l = i.getChildren(s);
                        let d = 1 * r[o] - 1;
                        if (!i.isTaskExists(l[d]))
                            return null;
                        s = l[d]
                    }
                    return i.isTaskExists(s) ? i.getTask(s) : null
                },
                _calcWBS: function() {
                    if (!this._isRecalcNeeded())
                        return;
                    let a = !0;
                    i.eachTask(function(r) {
                        if (r.type == i.config.types.placeholder)
                            return;
                        if (a)
                            return a = !1,
                                void this._setWBSCode(r, "1");
                        const s = this._getPrevNonPlaceholderSibling(r.id);
                        if (s !== null)
                            this._increaseWBS(r, s);
                        else {
                            let o = i.getParent(r.id);
                            this._setWBSCode(r, i.getTask(o).$wbs + ".1")
                        }
                    }, i.config.root_id, this),
                        this._needRecalc = !1
                },
                _increaseWBS: function(a, r) {
                    let s = i.getTask(r).$wbs;
                    s && (s = s.split("."),
                        s[s.length - 1]++,
                        this._setWBSCode(a, s.join(".")))
                },
                _getPrevNonPlaceholderSibling: function(a) {
                    let r, s = a;
                    do
                        r = i.getPrevSibling(s),
                            s = r;
                    while (r !== null && i.getTask(r).type == i.config.types.placeholder);
                    return r
                }
            }
        }(t);
        function e() {
            return n.reset(),
                !0
        }
        t.getWBSCode = function(i) {
            return n.getWBSCode(i)
        }
            ,
            t.getTaskByWBSCode = function(i) {
                return n.getByWBSCode(i)
            }
            ,
            t.attachEvent("onAfterTaskMove", e),
            t.attachEvent("onBeforeParse", e),
            t.attachEvent("onAfterTaskDelete", e),
            t.attachEvent("onAfterTaskAdd", e),
            t.attachEvent("onAfterSort", e)
    }
    function Hi(t) {
        var n = {}
            , e = !1;
        t.$data.tasksStore.attachEvent("onStoreUpdated", function() {
            n = {},
                e = !1
        }),
            t.attachEvent("onBeforeGanttRender", function() {
                n = {}
            });
        var i = String(Math.random());
        function a(l) {
            return l === null ? i + String(l) : String(l)
        }
        function r(l, d, c) {
            return Array.isArray(l) ? l.map(function(u) {
                return a(u)
            }).join("_") + `_${d}_${c}` : a(l) + `_${d}_${c}`
        }
        function s(l, d, c) {
            var u, h = r(d, l, JSON.stringify(c)), _ = {};
            return st(d, function(f) {
                _[a(f)] = !0
            }),
                n[h] ? u = n[h] : (u = n[h] = [],
                    t.eachTask(function(f) {
                        if (c) {
                            if (!c[t.getTaskType(f)])
                                return
                        } else if (f.type == t.config.types.project)
                            return;
                        l in f && st(Lt(f[l]) ? f[l] : [f[l]], function(y) {
                            var v = y && y.resource_id ? y.resource_id : y;
                            if (_[a(v)])
                                u.push(f);
                            else if (!e) {
                                var b = r(y, l);
                                n[b] || (n[b] = []),
                                    n[b].push(f)
                            }
                        })
                    }),
                    e = !0),
                u
        }
        function o(l, d, c) {
            var u = t.config.resource_property
                , h = [];
            if (t.getDatastore("task").exists(d)) {
                var _ = t.getTask(d);
                h = _[u] || []
            }
            Array.isArray(h) || (h = [h]);
            for (var f = 0; f < h.length; f++)
                h[f].resource_id == l && c.push({
                    task_id: _.id,
                    resource_id: h[f].resource_id,
                    value: h[f].value
                })
        }
        return {
            getTaskBy: function(l, d, c) {
                return typeof l == "function" ? (u = l,
                    h = [],
                    t.eachTask(function(_) {
                        u(_) && h.push(_)
                    }),
                    h) : Lt(d) ? s(l, d, c) : s(l, [d], c);
                var u, h
            },
            getResourceAssignments: function(l, d) {
                var c = []
                    , u = t.config.resource_property;
                return d !== void 0 ? o(l, d, c) : t.getTaskBy(u, l).forEach(function(h) {
                    o(l, h.id, c)
                }),
                    c
            }
        }
    }
    function Oi(t) {
        var n = Hi(t);
        t.ext.resources = function(a) {
            const r = {
                renderEditableLabel: function(s, o, l, d, c) {
                    const u = a.config.readonly ? "" : "contenteditable";
                    if (s < l.end_date && o > l.start_date) {
                        for (let h = 0; h < c.length; h++) {
                            const _ = c[h];
                            return "<div " + u + " data-assignment-cell data-assignment-id='" + _.id + "' data-row-id='" + l.id + "' data-task='" + l.$task_id + "' data-start-date='" + a.templates.format_date(s) + "' data-end-date='" + a.templates.format_date(o) + "'>" + _.value + "</div>"
                        }
                        return "<div " + u + " data-assignment-cell data-empty  data-row-id='" + l.id + "' data-resource-id='" + l.$resource_id + "' data-task='" + l.$task_id + "' data-start-date='" + a.templates.format_date(s) + "''  data-end-date='" + a.templates.format_date(o) + "'>-</div>"
                    }
                    return ""
                },
                renderSummaryLabel: function(s, o, l, d, c) {
                    let u = c.reduce(function(h, _) {
                        return h + Number(_.value)
                    }, 0);
                    return u % 1 && (u = Math.round(10 * u) / 10),
                        u ? "<div>" + u + "</div>" : ""
                },
                editableResourceCellTemplate: function(s, o, l, d, c) {
                    return l.$role === "task" ? r.renderEditableLabel(s, o, l, d, c) : r.renderSummaryLabel(s, o, l, d, c)
                },
                editableResourceCellClass: function(s, o, l, d, c) {
                    const u = [];
                    u.push("resource_marker"),
                        l.$role === "task" ? u.push("task_cell") : u.push("resource_cell");
                    const h = c.reduce(function(f, y) {
                        return f + Number(y.value)
                    }, 0);
                    let _ = Number(l.capacity);
                    return isNaN(_) && (_ = 8),
                        h <= _ ? u.push("workday_ok") : u.push("workday_over"),
                        u.join(" ")
                },
                getSummaryResourceAssignments: function(s) {
                    let o;
                    const l = a.getDatastore(a.config.resource_store)
                        , d = l.getItem(s);
                    return d.$role === "task" ? o = a.getResourceAssignments(d.$resource_id, d.$task_id) : (o = a.getResourceAssignments(s),
                    l.eachItem && l.eachItem(function(c) {
                        c.$role !== "task" && (o = o.concat(a.getResourceAssignments(c.id)))
                    }, s)),
                        o
                },
                initEditableDiagram: function() {
                    a.config.resource_render_empty_cells = !0,
                        function() {
                            let l = null;
                            function d() {
                                return l && cancelAnimationFrame(l),
                                    l = requestAnimationFrame(function() {
                                        a.$container && Array.prototype.slice.call(a.$container.querySelectorAll(".resourceTimeline_cell [data-assignment-cell]")).forEach(function(c) {
                                            c.contentEditable = !0
                                        })
                                    }),
                                    !0
                            }
                            a.attachEvent("onGanttReady", function() {
                                a.getDatastore(a.config.resource_assignment_store).attachEvent("onStoreUpdated", d),
                                    a.getDatastore(a.config.resource_store).attachEvent("onStoreUpdated", d)
                            }, {
                                once: !0
                            }),
                                a.attachEvent("onGanttLayoutReady", function() {
                                    a.$layout.getCellsByType("viewCell").forEach(function(c) {
                                        c.$config && c.$config.view === "resourceTimeline" && c.$content && c.$content.attachEvent("onScroll", d)
                                    })
                                })
                        }();
                    let s = null;
                    function o() {
                        setTimeout(function() {
                            const l = zt(a.$container);
                            s > -1 && l[s + 1].focus()
                        }, 300)
                    }
                    a.attachEvent("onGanttReady", function() {
                        let l = !1;
                        a.event(a.$container, "keypress", function(d) {
                            var c = d.target.closest(".resourceTimeline_cell [data-assignment-cell]");
                            c && (d.keyCode !== 13 && d.keyCode !== 27 || c.blur())
                        }),
                            a.event(a.$container, "keydown", function(d) {
                                d.key === "Tab" && (s = zt(a.$container).indexOf(document.activeElement))
                            }),
                            a.event(a.$container, "focusout", function(d) {
                                if (!l) {
                                    l = !0,
                                        setTimeout(function() {
                                            l = !1
                                        }, 300);
                                    var c = d.target.closest(".resourceTimeline_cell [data-assignment-cell]");
                                    if (c) {
                                        var u = (c.innerText || "").trim();
                                        u == "-" && (u = "0");
                                        var h = Number(u)
                                            , _ = c.getAttribute("data-row-id")
                                            , f = c.getAttribute("data-assignment-id")
                                            , y = c.getAttribute("data-task")
                                            , v = c.getAttribute("data-resource-id")
                                            , b = a.templates.parse_date(c.getAttribute("data-start-date"))
                                            , g = a.templates.parse_date(c.getAttribute("data-end-date"))
                                            , m = a.getDatastore(a.config.resource_assignment_store);
                                        if (isNaN(h))
                                            a.getDatastore(a.config.resource_store).refresh(_);
                                        else {
                                            var p = a.getTask(y);
                                            if (a.plugins().undo && a.ext.undo.saveState(y, "task"),
                                                f) {
                                                if (h === (w = m.getItem(f)).value)
                                                    return;
                                                if (w.start_date.valueOf() === b.valueOf() && w.end_date.valueOf() === g.valueOf())
                                                    w.value = h,
                                                        h ? m.updateItem(w.id) : m.removeItem(w.id);
                                                else {
                                                    if (w.end_date.valueOf() > g.valueOf()) {
                                                        var k = a.copy(w);
                                                        k.id = a.uid(),
                                                            k.start_date = g,
                                                            k.duration = a.calculateDuration({
                                                                start_date: k.start_date,
                                                                end_date: k.end_date,
                                                                task: p
                                                            }),
                                                            k.delay = a.calculateDuration({
                                                                start_date: p.start_date,
                                                                end_date: k.start_date,
                                                                task: p
                                                            }),
                                                            k.mode = w.mode || "default",
                                                        k.duration !== 0 && m.addItem(k)
                                                    }
                                                    w.start_date.valueOf() < b.valueOf() ? (w.end_date = b,
                                                        w.duration = a.calculateDuration({
                                                            start_date: w.start_date,
                                                            end_date: w.end_date,
                                                            task: p
                                                        }),
                                                        w.mode = "fixedDuration",
                                                        w.duration === 0 ? m.removeItem(w.id) : m.updateItem(w.id)) : m.removeItem(w.id),
                                                    h && m.addItem({
                                                        task_id: w.task_id,
                                                        resource_id: w.resource_id,
                                                        value: h,
                                                        start_date: b,
                                                        end_date: g,
                                                        duration: a.calculateDuration({
                                                            start_date: b,
                                                            end_date: g,
                                                            task: p
                                                        }),
                                                        delay: a.calculateDuration({
                                                            start_date: p.start_date,
                                                            end_date: b,
                                                            task: p
                                                        }),
                                                        mode: "fixedDuration"
                                                    })
                                                }
                                                a.updateTaskAssignments(p.id),
                                                    a.updateTask(p.id),
                                                    o()
                                            } else if (h) {
                                                var w = {
                                                    task_id: y,
                                                    resource_id: v,
                                                    value: h,
                                                    start_date: b,
                                                    end_date: g,
                                                    duration: a.calculateDuration({
                                                        start_date: b,
                                                        end_date: g,
                                                        task: p
                                                    }),
                                                    delay: a.calculateDuration({
                                                        start_date: p.start_date,
                                                        end_date: b,
                                                        task: p
                                                    }),
                                                    mode: "fixedDuration"
                                                };
                                                m.addItem(w),
                                                    a.updateTaskAssignments(p.id),
                                                    a.updateTask(p.id),
                                                    o()
                                            }
                                        }
                                    }
                                }
                            })
                    }, {
                        once: !0
                    })
                }
            };
            return r
        }(t),
            t.config.resources = {
                dataprocessor_assignments: !1,
                dataprocessor_resources: !1,
                editable_resource_diagram: !1,
                resource_store: {
                    type: "treeDataStore",
                    fetchTasks: !1,
                    initItem: function(a) {
                        return a.parent = a.parent || t.config.root_id,
                            a[t.config.resource_property] = a.parent,
                            a.open = !0,
                            a
                    }
                },
                lightbox_resources: function(a) {
                    const r = []
                        , s = t.getDatastore(t.config.resource_store);
                    return a.forEach(function(o) {
                        if (!s.hasChild(o.id)) {
                            const l = t.copy(o);
                            l.key = o.id,
                                l.label = o.text,
                                r.push(l)
                        }
                    }),
                        r
                }
            },
            t.attachEvent("onBeforeGanttReady", function() {
                if (t.getDatastore(t.config.resource_store))
                    return;
                const a = t.config.resources ? t.config.resources.resource_store : void 0;
                let r = a ? a.fetchTasks : void 0;
                t.config.resources && t.config.resources.editable_resource_diagram && (r = !0);
                let s = function(l) {
                    return l.parent = l.parent || t.config.root_id,
                        l[t.config.resource_property] = l.parent,
                        l.open = !0,
                        l
                };
                a && a.initItem && (s = a.initItem);
                const o = a && a.type ? a.type : "treeDatastore";
                t.$resourcesStore = t.createDatastore({
                    name: t.config.resource_store,
                    type: o,
                    fetchTasks: r !== void 0 && r,
                    initItem: s
                }),
                    t.$data.resourcesStore = t.$resourcesStore,
                    t.$resourcesStore.attachEvent("onParse", function() {
                        let l, d = function(c) {
                            const u = [];
                            return c.forEach(function(h) {
                                const _ = t.copy(h);
                                _.key = h.id,
                                    _.label = h.text,
                                    u.push(_)
                            }),
                                u
                        };
                        t.config.resources && t.config.resources.lightbox_resources && (d = t.config.resources.lightbox_resources),
                            t.config.resources && t.config.resources.editable_resource_diagram ? l = d(t.$resourcesStore.getItems().filter(c => {
                                    let u = t.getResourceAssignments(c.id);
                                    if (!t.$resourcesStore.hasChild(c.id) || u && u.length)
                                        return !c.$resource_id || !c.$task_id
                                }
                            )) : l = d(t.$resourcesStore.getItems()),
                            t.updateCollection("resourceOptions", l)
                    })
            }),
            t.getTaskBy = n.getTaskBy,
            t.getResourceAssignments = n.getResourceAssignments,
            t.config.resource_property = "owner_id",
            t.config.resource_store = "resource",
            t.config.resource_render_empty_cells = !1,
            t.templates.histogram_cell_class = function(a, r, s, o, l) {}
            ,
            t.templates.histogram_cell_label = function(a, r, s, o, l) {
                return o.length + "/3"
            }
            ,
            t.templates.histogram_cell_allocated = function(a, r, s, o, l) {
                return o.length / 3
            }
            ,
            t.templates.histogram_cell_capacity = function(a, r, s, o, l) {
                return 0
            }
        ;
        const e = function(a, r, s, o, l) {
            return o.length <= 1 ? "gantt_resource_marker_ok" : "gantt_resource_marker_overtime"
        }
            , i = function(a, r, s, o, l) {
            return 8 * o.length
        };
        t.templates.resource_cell_value = i,
            t.templates.resource_cell_class = e,
            t.attachEvent("onBeforeGanttReady", function() {
                t.config.resources && t.config.resources.editable_resource_diagram && (t.config.resource_render_empty_cells = !0,
                t.templates.resource_cell_value === i && (t.templates.resource_cell_value = t.ext.resources.editableResourceCellTemplate),
                t.templates.resource_cell_class === e && (t.templates.resource_cell_class = t.ext.resources.editableResourceCellClass),
                    t.ext.resources.initEditableDiagram(t))
            })
    }
    function Bi(t) {
        var n = "$resourceAssignments";
        t.config.resource_assignment_store = "resourceAssignments",
            t.config.process_resource_assignments = !0;
        var e = "auto"
            , i = "singleValue"
            , a = "valueArray"
            , r = "resourceValueArray"
            , s = "assignmentsArray"
            , o = e
            , l = "fixedDates"
            , d = "fixedDuration"
            , c = "default";
        function u(p, k) {
            p.start_date ? p.start_date = t.date.parseDate(p.start_date, "parse_date") : p.start_date = null,
                p.end_date ? p.end_date = t.date.parseDate(p.end_date, "parse_date") : p.end_date = null;
            var w = Number(p.delay)
                , x = !1;
            if (isNaN(w) ? (p.delay = 0,
                x = !0) : p.delay = w,
            t.defined(p.value) || (p.value = null),
            !p.task_id || !p.resource_id)
                return !1;
            if (p.mode = p.mode || c,
            p.mode === d && (isNaN(Number(p.duration)) && (k = k || t.getTask(p.task_id),
                p.duration = t.calculateDuration({
                    start_date: p.start_date,
                    end_date: p.end_date,
                    id: k
                })),
            x && (k = k || t.getTask(p.task_id),
                p.delay = t.calculateDuration({
                    start_date: k.start_date,
                    end_date: p.start_date,
                    id: k
                }))),
            p.mode !== l && (k || t.isTaskExists(p.task_id))) {
                var $ = _(p, k = k || t.getTask(p.task_id));
                p.start_date = $.start_date,
                    p.end_date = $.end_date,
                    p.duration = $.duration
            }
        }
        var h = t.createDatastore({
            name: t.config.resource_assignment_store,
            initItem: function(p) {
                return p.id || (p.id = t.uid()),
                    u(p),
                    p
            }
        });
        function _(p, k) {
            if (p.mode === l)
                return {
                    start_date: p.start_date,
                    end_date: p.end_date,
                    duration: p.duration
                };
            var w, x, $ = p.delay ? t.calculateEndDate({
                start_date: k.start_date,
                duration: p.delay,
                task: k
            }) : new Date(k.start_date);
            return p.mode === d ? (w = t.calculateEndDate({
                start_date: $,
                duration: p.duration,
                task: k
            }),
                x = p.duration) : (w = new Date(k.end_date),
                x = k.duration - p.delay),
                {
                    start_date: $,
                    end_date: w,
                    duration: x
                }
        }
        function f(p) {
            const k = t.config.resource_property;
            let w = p[k];
            const x = [];
            let $ = o === e;
            if (t.defined(w) && w) {
                Array.isArray(w) || (w = [w],
                $ && (o = i,
                    $ = !1));
                const S = {};
                w.forEach(function(T) {
                    T.resource_id || (T = {
                        resource_id: T
                    },
                    $ && (o = a,
                        $ = !1)),
                    $ && (T.id && T.resource_id ? (o = s,
                        $ = !1) : (o = r,
                        $ = !1));
                    let E, C = c;
                    T.mode || (T.start_date && T.end_date || T.start_date && T.duration) && (C = d),
                        E = T.id || !T.$id || S[T.$id] ? T.id && !S[T.id] ? T.id : t.uid() : T.$id,
                        S[E] = !0;
                    const D = {
                        id: E,
                        start_date: T.start_date,
                        duration: T.duration,
                        end_date: T.end_date,
                        delay: T.delay,
                        task_id: p.id,
                        resource_id: T.resource_id,
                        value: T.value,
                        mode: T.mode || C
                    };
                    Object.keys(T).forEach(A => {
                            A != "$id" && (D[A] = T[A])
                        }
                    ),
                    D.start_date && D.start_date.getMonth && D.end_date && D.end_date.getMonth && typeof D.duration == "number" || u(D, p),
                        x.push(D)
                })
            }
            return x
        }
        function y(p) {
            if (t.isTaskExists(p)) {
                var k = t.getTask(p);
                v(k, t.getTaskAssignments(k.id))
            }
        }
        function v(p, k) {
            k.sort(function(w, x) {
                return w.start_date && x.start_date && w.start_date.valueOf() != x.start_date.valueOf() ? w.start_date - x.start_date : 0
            }),
                o == s ? p[t.config.resource_property] = k : o == r && (p[t.config.resource_property] = k.map(function(w) {
                    return {
                        $id: w.id,
                        start_date: w.start_date,
                        duration: w.duration,
                        end_date: w.end_date,
                        delay: w.delay,
                        resource_id: w.resource_id,
                        value: w.value,
                        mode: w.mode
                    }
                })),
                p[n] = k
        }
        function b(p) {
            var k = f(p);
            return k.forEach(function(w) {
                w.id = w.id || t.uid()
            }),
                k
        }
        function g(p, k) {
            var w = function(x, $) {
                var S = {
                    inBoth: [],
                    inTaskNotInStore: [],
                    inStoreNotInTask: []
                };
                if (o == i) {
                    var T = x[0]
                        , E = T ? T.resource_id : null
                        , C = !1;
                    $.forEach(function(M) {
                        M.resource_id != E ? S.inStoreNotInTask.push(M) : M.resource_id == E && (S.inBoth.push({
                            store: M,
                            task: T
                        }),
                            C = !0)
                    }),
                    !C && T && S.inTaskNotInStore.push(T)
                } else if (o == a) {
                    var D = {}
                        , A = {}
                        , I = {};
                    x.forEach(function(M) {
                        D[M.resource_id] = M
                    }),
                        $.forEach(function(M) {
                            A[M.resource_id] = M
                        }),
                        x.concat($).forEach(function(M) {
                            if (!I[M.resource_id]) {
                                I[M.resource_id] = !0;
                                var L = D[M.resource_id]
                                    , N = A[M.resource_id];
                                L && N ? S.inBoth.push({
                                    store: N,
                                    task: L
                                }) : L && !N ? S.inTaskNotInStore.push(L) : !L && N && S.inStoreNotInTask.push(N)
                            }
                        })
                } else
                    o != s && o != r || (D = {},
                        A = {},
                        I = {},
                        x.forEach(function(M) {
                            D[M.id || M.$id] = M
                        }),
                        $.forEach(function(M) {
                            A[M.id] = M
                        }),
                        x.concat($).forEach(function(M) {
                            var L = M.id || M.$id;
                            if (!I[L]) {
                                I[L] = !0;
                                var N = D[L]
                                    , P = A[L];
                                N && P ? S.inBoth.push({
                                    store: P,
                                    task: N
                                }) : N && !P ? S.inTaskNotInStore.push(N) : !N && P && S.inStoreNotInTask.push(P)
                            }
                        }));
                return S
            }(f(p), k);
            w.inStoreNotInTask.forEach(function(x) {
                h.removeItem(x.id)
            }),
                w.inTaskNotInStore.forEach(function(x) {
                    h.addItem(x)
                }),
                w.inBoth.forEach(function(x) {
                    if (function(S, T) {
                        var E = {
                            id: !0
                        };
                        for (var C in S)
                            if (!E[C] && String(S[C]) !== String(T[C]))
                                return !0;
                        return !1
                    }(x.task, x.store))
                        (function(S, T) {
                                var E = {
                                    id: !0
                                };
                                for (var C in S)
                                    E[C] || (T[C] = S[C])
                            }
                        )(x.task, x.store),
                            h.updateItem(x.store.id);
                    else if (x.task.start_date && x.task.end_date && x.task.mode !== l) {
                        var $ = _(x.store, p);
                        x.store.start_date.valueOf() == $.start_date.valueOf() && x.store.end_date.valueOf() == $.end_date.valueOf() || (x.store.start_date = $.start_date,
                            x.store.end_date = $.end_date,
                            x.store.duration = $.duration,
                            h.updateItem(x.store.id))
                    }
                }),
                y(p.id)
        }
        function m(p) {
            var k = p[n] || h.find(function(w) {
                return w.task_id == p.id
            });
            g(p, k)
        }
        t.$data.assignmentsStore = h,
            t.attachEvent("onGanttReady", function() {
                if (t.config.process_resource_assignments) {
                    t.attachEvent("onParse", function() {
                        t.silent(function() {
                            h.clearAll();
                            var E = [];
                            t.eachTask(function(C) {
                                if (C.type !== t.config.types.project) {
                                    var D = b(C);
                                    v(C, D),
                                        D.forEach(function(A) {
                                            E.push(A)
                                        })
                                }
                            }),
                                h.parse(E)
                        })
                    });
                    var p = !1
                        , k = !1
                        , w = {}
                        , x = !1;
                    t.attachEvent("onBeforeBatchUpdate", function() {
                        p = !0
                    }),
                        t.attachEvent("onAfterBatchUpdate", function() {
                            if (k) {
                                var E = {};
                                for (var C in w)
                                    E[C] = t.getTaskAssignments(w[C].id);
                                for (var C in t.config.process_resource_assignments && o === "resourceValueArray" && (T = null),
                                    w)
                                    g(w[C], E[C])
                            }
                            k = !1,
                                p = !1,
                                w = {}
                        }),
                        t.attachEvent("onTaskCreated", function(E) {
                            var C = b(E);
                            return h.parse(C),
                                v(E, C),
                                !0
                        }),
                        t.attachEvent("onAfterTaskUpdate", function(E, C) {
                            p ? (k = !0,
                                w[E] = C) : C.unscheduled || m(C)
                        }),
                        t.attachEvent("onAfterTaskAdd", function(E, C) {
                            p ? (k = !0,
                                w[E] = C) : m(C)
                        }),
                        t.attachEvent("onRowDragEnd", function(E) {
                            m(t.getTask(E))
                        }),
                        t.$data.tasksStore.attachEvent("onAfterDeleteConfirmed", function(E, C) {
                            var D, A = [E];
                            t.eachTask(function(I) {
                                A.push(I.id)
                            }, E),
                                D = {},
                                A.forEach(function(I) {
                                    D[I] = !0
                                }),
                                h.find(function(I) {
                                    return D[I.task_id]
                                }).forEach(function(I) {
                                    h.removeItem(I.id)
                                })
                        }),
                        t.$data.tasksStore.attachEvent("onClearAll", function() {
                            return $ = null,
                                S = null,
                                T = null,
                                h.clearAll(),
                                !0
                        }),
                        t.attachEvent("onTaskIdChange", function(E, C) {
                            h.find(function(D) {
                                return D.task_id == E
                            }).forEach(function(D) {
                                D.task_id = C,
                                    h.updateItem(D.id)
                            }),
                                y(C)
                        }),
                        t.attachEvent("onBeforeUndo", function(E) {
                            return x = !0,
                                !0
                        }),
                        t.attachEvent("onAfterUndo", function(E) {
                            x = !0
                        });
                    var $ = null
                        , S = null
                        , T = null;
                    h.attachEvent("onStoreUpdated", function() {
                        return p && !x || ($ = null,
                            S = null,
                            T = null),
                            !0
                    }),
                        t.getResourceAssignments = function(E, C) {
                            var D = t.defined(C) && C !== null;
                            return $ === null && ($ = {},
                                S = {},
                                h.eachItem(function(A) {
                                    $[A.resource_id] || ($[A.resource_id] = []),
                                        $[A.resource_id].push(A);
                                    var I = A.resource_id + "-" + A.task_id;
                                    S[I] || (S[I] = []),
                                        S[I].push(A)
                                })),
                                D ? (S[E + "-" + C] || []).slice() : ($[E] || []).slice()
                        }
                        ,
                        t.getTaskAssignments = function(E) {
                            if (T === null) {
                                var C = [];
                                T = {},
                                    h.eachItem(function(D) {
                                        T[D.task_id] || (T[D.task_id] = []),
                                            T[D.task_id].push(D),
                                        D.task_id == E && C.push(D)
                                    })
                            }
                            return (T[E] || []).slice()
                        }
                        ,
                        t.getTaskResources = function(E) {
                            const C = t.getDatastore("resource")
                                , D = t.getTaskAssignments(E)
                                , A = {};
                            D.forEach(function(M) {
                                A[M.resource_id] || (A[M.resource_id] = M.resource_id)
                            });
                            const I = [];
                            for (const M in A) {
                                const L = C.getItem(A[M]);
                                L && I.push(L)
                            }
                            return I
                        }
                        ,
                        t.updateTaskAssignments = y
                }
            }, {
                once: !0
            })
    }
    function zi(t) {
        function n(o) {
            return function() {
                return !t.config.placeholder_task || o.apply(this, arguments)
            }
        }
        function e() {
            var o = t.getTaskBy("type", t.config.types.placeholder);
            if (!o.length || !t.isTaskExists(o[0].id)) {
                var l = {
                    unscheduled: !0,
                    type: t.config.types.placeholder,
                    duration: 0,
                    text: t.locale.labels.new_task
                };
                if (t.callEvent("onTaskCreated", [l]) === !1)
                    return;
                t.addTask(l)
            }
        }
        function i(o) {
            var l = t.getTask(o);
            l.type == t.config.types.placeholder && (l.start_date && l.end_date && l.unscheduled && (l.unscheduled = !1),
                t.batchUpdate(function() {
                    var d = t.copy(l);
                    t.silent(function() {
                        t.deleteTask(l.id)
                    }),
                        delete d["!nativeeditor_status"],
                        d.type = t.config.types.task,
                        d.id = t.uid(),
                        t.addTask(d)
                }))
        }
        t.config.types.placeholder = "placeholder",
            t.attachEvent("onDataProcessorReady", n(function(o) {
                o && !o._silencedPlaceholder && (o._silencedPlaceholder = !0,
                    o.attachEvent("onBeforeUpdate", n(function(l, d, c) {
                        return c.type != t.config.types.placeholder || (o.setUpdated(l, !1),
                            !1)
                    })))
            }));
        var a = !1;
        function r(o) {
            return !!(t.config.types.placeholder && t.isTaskExists(o) && t.getTask(o).type == t.config.types.placeholder)
        }
        function s(o) {
            return !(!r(o.source) && !r(o.target))
        }
        t.attachEvent("onGanttReady", function() {
            a || (a = !0,
                t.attachEvent("onAfterTaskUpdate", n(i)),
                t.attachEvent("onAfterTaskAdd", n(function(o, l) {
                    l.type != t.config.types.placeholder && (t.getTaskBy("type", t.config.types.placeholder).forEach(function(d) {
                        t.silent(function() {
                            t.isTaskExists(d.id) && t.deleteTask(d.id)
                        })
                    }),
                        e())
                })),
                t.attachEvent("onParse", n(e)))
        }),
            t.attachEvent("onLinkValidation", function(o) {
                return !s(o)
            }),
            t.attachEvent("onBeforeLinkAdd", function(o, l) {
                return !s(l)
            }),
            t.attachEvent("onBeforeUndoStack", function(o) {
                for (var l = 0; l < o.commands.length; l++) {
                    var d = o.commands[l];
                    d.entity === "task" && d.value.type === t.config.types.placeholder && (o.commands.splice(l, 1),
                        l--)
                }
                return !0
            })
    }
    function ji(t) {
        function n(c) {
            return function() {
                return !t.config.auto_types || t.getTaskType(t.config.types.project) != t.config.types.project || c.apply(this, arguments)
            }
        }
        function e(c, u) {
            var h = t.getTask(c)
                , _ = r(h);
            _ !== !1 && t.getTaskType(h) !== _ && (u.$needsUpdate = !0,
                u[h.id] = {
                    task: h,
                    type: _
                })
        }
        function i(c) {
            if (!t.getState().group_mode) {
                var u = function(h, _) {
                    return e(h, _ = _ || {}),
                        t.eachParent(function(f) {
                            e(f.id, _)
                        }, h),
                        _
                }(c);
                u.$needsUpdate && t.batchUpdate(function() {
                    (function(h) {
                            for (var _ in h)
                                if (h[_] && h[_].task) {
                                    var f = h[_].task;
                                    f.type = h[_].type,
                                        t.updateTask(f.id)
                                }
                        }
                    )(u)
                })
            }
        }
        var a;
        function r(c) {
            var u = t.config.types
                , h = t.hasChild(c.id)
                , _ = t.getTaskType(c.type);
            return h && _ === u.task ? u.project : !h && _ === u.project && u.task
        }
        var s, o, l = !0;
        function d(c) {
            c != t.config.root_id && t.isTaskExists(c) && i(c)
        }
        t.attachEvent("onParse", n(function() {
            l = !1,
            t.getState().group_mode || (t.batchUpdate(function() {
                t.eachTask(function(c) {
                    var u = r(c);
                    u !== !1 && function(h, _) {
                        t.getState().group_mode || (h.type = _,
                            t.updateTask(h.id))
                    }(c, u)
                })
            }),
                l = !0)
        })),
            t.attachEvent("onAfterTaskAdd", n(function(c) {
                l && i(c)
            })),
            t.attachEvent("onAfterTaskUpdate", n(function(c) {
                l && i(c)
            })),
            t.attachEvent("onBeforeTaskDelete", n(function(c, u) {
                return a = t.getParent(c),
                    !0
            })),
            t.attachEvent("onAfterTaskDelete", n(function(c, u) {
                d(a)
            })),
            t.attachEvent("onRowDragStart", n(function(c, u, h) {
                return s = t.getParent(c),
                    !0
            })),
            t.attachEvent("onRowDragEnd", n(function(c, u) {
                d(s),
                    i(c)
            })),
            t.attachEvent("onBeforeTaskMove", n(function(c, u, h) {
                return o = t.getParent(c),
                    !0
            })),
            t.attachEvent("onAfterTaskMove", n(function(c, u, h) {
                document.querySelector(".gantt_drag_marker") || (d(o),
                    i(c))
            }))
    }
    const ce = class ce {
            constructor(n=null) {
                this.canParse = e => {
                    let i = "";
                    const a = this._config.labels;
                    for (const r in a) {
                        const s = a[r];
                        i += `${s.full}|${s.plural}|${s.short}|`
                    }
                    return new RegExp(`^([+-]? *[0-9.]{1,}\\s*(${i})\\s*)*$`).test((e || "").trim())
                }
                    ,
                    this.format = e => {
                        const i = this._config.store
                            , a = this._config.format
                            , r = this._config.short;
                        let s = this.transferUnits[i].toMinutes(e)
                            , o = a;
                        if (o && o === "auto" && (o = this._selectFormatForValue(s)),
                        o || (o = "day"),
                        a === "auto" && !e)
                            return "";
                        o = Array.isArray(o) ? o : [o];
                        let l = "";
                        const d = o.length - 1;
                        for (let c = 0; c < o.length; c++) {
                            const u = o[c]
                                , h = this._getValueFromMinutes(s, u, c === d);
                            s -= this._getValueInMinutes(h, u),
                                l += `${this._getLabelForConvert(h, u, r)}${c === d ? "" : " "}`
                        }
                        return l
                    }
                    ,
                    this.parse = e => {
                        if (this.canParse(e)) {
                            let i = ""
                                , a = !1
                                , r = !1
                                , s = 0;
                            const o = (e = (e || "").trim()).length - 1
                                , l = /^[+\-0-9\. ]$/;
                            for (let d = 0; d < e.length; d++) {
                                const c = e[d];
                                l.test(c) ? r = a : a = !0,
                                (r || o === d) && (r || (i += c),
                                    s += this._getNumericValue(i),
                                    a = r = !1,
                                    i = ""),
                                    i += c
                            }
                            if (s) {
                                const d = this._config.store;
                                return Math.round(this.transferUnits[d].fromMinutes(Math.ceil(s)))
                            }
                        }
                        return null
                    }
                    ,
                    this._getValueInMinutes = (e, i) => this.transferUnits[i] && this.transferUnits[i].toMinutes ? this.transferUnits[i].toMinutes(e) : 0,
                    this._getLabelForConvert = (e, i, a) => {
                        const r = this._config.labels[i];
                        return a ? `${e}${r.short}` : `${e} ${e !== 1 && e !== -1 ? r.plural : r.full}`
                    }
                    ,
                    this._getValueFromMinutes = (e, i, a) => {
                        if (this.transferUnits[i] && this.transferUnits[i].fromMinutes) {
                            const r = this.transferUnits[i].fromMinutes(e);
                            return a ? parseFloat(r.toFixed(2)) : parseInt(r.toString(), 10)
                        }
                        return null
                    }
                    ,
                    this._isUnitName = (e, i) => (i = i.toLowerCase(),
                    e.full.toLowerCase() === i || e.plural.toLowerCase() === i || e.short.toLowerCase() === i),
                    this._getUnitName = e => {
                        const i = this._config.labels;
                        let a, r = !1;
                        for (a in i)
                            if (this._isUnitName(i[a], e)) {
                                r = !0;
                                break
                            }
                        return r ? a : this._config.enter
                    }
                    ,
                    this._config = this._defaultSettings(n),
                    this.transferUnits = {
                        minute: {
                            toMinutes: e => e,
                            fromMinutes: e => e
                        },
                        hour: {
                            toMinutes: e => e * this._config.minutesPerHour,
                            fromMinutes: e => e / this._config.minutesPerHour
                        },
                        day: {
                            toMinutes: e => e * this._config.minutesPerHour * this._config.hoursPerDay,
                            fromMinutes: e => e / (this._config.minutesPerHour * this._config.hoursPerDay)
                        },
                        week: {
                            toMinutes: e => e * this._config.minutesPerHour * this._config.hoursPerWeek,
                            fromMinutes: e => e / (this._config.minutesPerHour * this._config.hoursPerWeek)
                        },
                        month: {
                            toMinutes: e => e * this._config.minutesPerHour * this._config.hoursPerDay * this._config.daysPerMonth,
                            fromMinutes: e => e / (this._config.minutesPerHour * this._config.hoursPerDay * this._config.daysPerMonth)
                        },
                        year: {
                            toMinutes: e => e * this._config.minutesPerHour * this._config.hoursPerDay * this._config.daysPerYear,
                            fromMinutes: e => e / (this._config.minutesPerHour * this._config.hoursPerDay * this._config.daysPerYear)
                        }
                    }
            }
            _defaultSettings(n=null) {
                const e = {
                    enter: "day",
                    store: "hour",
                    format: "auto",
                    short: !1,
                    minutesPerHour: 60,
                    hoursPerDay: 8,
                    hoursPerWeek: 40,
                    daysPerMonth: 30,
                    daysPerYear: 365,
                    labels: {
                        minute: {
                            full: "minute",
                            plural: "minutes",
                            short: "min"
                        },
                        hour: {
                            full: "hour",
                            plural: "hours",
                            short: "h"
                        },
                        day: {
                            full: "day",
                            plural: "days",
                            short: "d"
                        },
                        week: {
                            full: "week",
                            plural: "weeks",
                            short: "wk"
                        },
                        month: {
                            full: "month",
                            plural: "months",
                            short: "mon"
                        },
                        year: {
                            full: "year",
                            plural: "years",
                            short: "y"
                        }
                    }
                };
                if (n) {
                    for (const i in n)
                        n[i] !== void 0 && i !== "labels" && (e[i] = n[i]);
                    if (n.labels)
                        for (const i in n.labels)
                            e.labels[i] = n.labels[i]
                }
                return e
            }
            _selectFormatForValue(n) {
                const e = ["year", "month", "day", "hour", "minute"]
                    , i = [];
                for (let a = 0; a < e.length; a++)
                    i[a] = Math.abs(this.transferUnits[e[a]].fromMinutes(n));
                for (let a = 0; a < i.length; a++)
                    if (!(i[a] < 1 && a < i.length - 1))
                        return e[a];
                return "day"
            }
            _getNumericValue(n) {
                const e = parseFloat(n.replace(/ /g, "")) || 0
                    , i = n.match(new RegExp("\\p{L}","gu")) ? n.match(new RegExp("\\p{L}","gu")).join("") : ""
                    , a = this._getUnitName(i);
                return e && a ? this._getValueInMinutes(e, a) : 0
            }
        }
    ;
    ce.create = (n=null) => new ce(n);
    let Me = ce;
    const ue = class ue {
            constructor(n) {
                this.format = e => this._getWBSCode(e.source),
                    this.canParse = e => this._linkReg.test(e),
                    this.parse = e => {
                        if (!this.canParse(e))
                            return null;
                        const i = this._linkReg.exec(e)[0].trim();
                        return {
                            id: void 0,
                            source: this._findSource(i) || null,
                            target: null,
                            type: this._gantt.config.links.finish_to_start,
                            lag: 0
                        }
                    }
                    ,
                    this._getWBSCode = e => {
                        const i = this._gantt.getTask(e);
                        return this._gantt.getWBSCode(i)
                    }
                    ,
                    this._findSource = e => {
                        const i = new RegExp("^[0-9.]+","i");
                        if (i.exec(e)) {
                            const a = i.exec(e)[0]
                                , r = this._gantt.getTaskByWBSCode(a);
                            if (r)
                                return r.id
                        }
                        return null
                    }
                    ,
                    this._linkReg = /^[0-9\.]+/,
                    this._gantt = n
            }
        }
    ;
    ue.create = (n=null, e) => new ue(e);
    let Ie = ue;
    const he = class he extends Ie {
            constructor(n, e) {
                super(e),
                    this.format = i => {
                        const a = this._getFormattedLinkType(this._getLinkTypeName(i.type))
                            , r = this._getWBSCode(i.source)
                            , s = this._getLagString(i.lag);
                        return i.type !== this._gantt.config.links.finish_to_start || i.lag ? `${r}${a}${s}` : r
                    }
                    ,
                    this.parse = i => {
                        if (!this.canParse(i))
                            return null;
                        const a = this._linkReg.exec(i)[0].trim()
                            , r = i.replace(a, "").trim()
                            , s = this._findTypeFormat(a)
                            , o = this._getLinkTypeNumber(s);
                        return {
                            id: void 0,
                            source: this._findSource(a) || null,
                            target: null,
                            type: o,
                            lag: this._parseLag(r)
                        }
                    }
                    ,
                    this._getLinkTypeName = i => {
                        let a = "";
                        for (a in this._config.labels)
                            if (String(this._gantt.config.links[a]).toLowerCase() === String(i).toLowerCase())
                                break;
                        return a
                    }
                    ,
                    this._getLinkTypeNumber = i => {
                        let a = "";
                        for (a in this._gantt.config.links)
                            if (a.toLowerCase() === i.toLowerCase())
                                break;
                        return this._gantt.config.links[a]
                    }
                    ,
                    this._getFormattedLinkType = i => this._config.labels[i] || "",
                    this._getLagString = i => {
                        if (!i)
                            return "";
                        const a = this._config.durationFormatter.format(i);
                        return i < 0 ? a : `+${a}`
                    }
                    ,
                    this._findTypeFormat = i => {
                        const a = i.replace(/[^a-zA-Z]/gi, "");
                        let r = "finish_to_start";
                        for (const s in this._config.labels)
                            this._config.labels[s].toLowerCase() === a.toLowerCase() && (r = s);
                        return r
                    }
                    ,
                    this._parseLag = i => i ? this._config.durationFormatter.parse(i) : 0,
                    this._config = this._defaultSettings(n),
                    this._linkReg = /^[0-9\.]+[a-zA-Z]*/
            }
            _defaultSettings(n=null) {
                const e = {
                    durationFormatter: this._gantt.ext.formatters.durationFormatter(),
                    labels: {
                        finish_to_finish: "FF",
                        finish_to_start: "FS",
                        start_to_start: "SS",
                        start_to_finish: "SF"
                    }
                };
                if (n && n.durationFormatter && (e.durationFormatter = n.durationFormatter),
                n && n.labels)
                    for (const i in n.labels)
                        e.labels[i] = n.labels[i];
                return e
            }
        }
    ;
    he.create = (n=null, e) => new he(n,e);
    let Le = he;
    function Fi(t) {
        t.ext.formatters = {
            durationFormatter: function(n) {
                return n || (n = {}),
                n.store || (n.store = t.config.duration_unit),
                n.enter || (n.enter = t.config.duration_unit),
                    Me.create(n, t)
            },
            linkFormatter: function(n) {
                return Le.create(n, t)
            }
        }
    }
    function Wi(t) {
        t.ext = t.ext || {},
            t.config.show_empty_state = !1,
            t.ext.emptyStateElement = t.ext.emptyStateElement || {
                isEnabled: () => t.config.show_empty_state === !0,
                isGanttEmpty: () => !t.getTaskByTime().length,
                renderContent(n) {
                    const e = `<div class='gantt_empty_state'><div class='gantt_empty_state_image'></div>${`<div class='gantt_empty_state_text'>
    <div class='gantt_empty_state_text_link' data-empty-state-create-task>${t.locale.labels.empty_state_text_link}</div>
    <div class='gantt_empty_state_text_description'>${t.locale.labels.empty_state_text_description}</div>
    </div>`}</div>`;
                    n.innerHTML = e
                },
                clickEvents: [],
                attachAddTaskEvent() {
                    const n = t.attachEvent("onEmptyClick", function(e) {
                        t.utils.dom.closest(e.target, "[data-empty-state-create-task]") && t.createTask({
                            id: t.uid(),
                            text: "New Task"
                        })
                    });
                    this.clickEvents.push(n)
                },
                detachAddTaskEvents() {
                    this.clickEvents.forEach(function(n) {
                        t.detachEvent(n)
                    }),
                        this.clickEvents = []
                },
                getContainer() {
                    if (t.$container) {
                        const n = t.utils.dom;
                        if (t.$container.contains(t.$grid_data))
                            return n.closest(t.$grid_data, ".gantt_layout_content");
                        if (t.$container.contains(t.$task_data))
                            return n.closest(t.$task_data, ".gantt_layout_content")
                    }
                    return null
                },
                getNode() {
                    const n = this.getContainer();
                    return n ? n.querySelector(".gantt_empty_state_wrapper") : null
                },
                show() {
                    const n = this.getContainer();
                    if (!n && this.isGanttEmpty())
                        return null;
                    const e = document.createElement("div");
                    e.className = "gantt_empty_state_wrapper",
                        e.style.marginTop = t.config.scale_height - n.offsetHeight + "px";
                    const i = t.$container.querySelectorAll(".gantt_empty_state_wrapper");
                    Array.prototype.forEach.call(i, function(a) {
                        a.parentNode.removeChild(a)
                    }),
                        this.detachAddTaskEvents(),
                        this.attachAddTaskEvent(),
                        n.appendChild(e),
                        this.renderContent(e)
                },
                hide() {
                    const n = this.getNode();
                    if (!n)
                        return !1;
                    n.parentNode.removeChild(n)
                },
                init() {}
            },
            t.attachEvent("onDataRender", function() {
                const n = t.ext.emptyStateElement;
                n.isEnabled() && n.isGanttEmpty() ? n.show() : n.hide()
            })
    }
    const Ne = function(t, n) {
        const e = n.baselines && n.baselines.length
            , i = t.config.baselines.render_mode == "separateRow" || t.config.baselines.render_mode == "individualRow";
        if (e && i)
            return !0
    }
        , Ft = function(t, n) {
        let e = !1;
        return t.eachTask(function(i) {
            e || (e = Ne(t, i))
        }, n),
            e
    }
        , ft = function(t) {
        return t.render && t.render == "split" && !t.$open
    }
        , ee = function(t, n, e, i) {
        let a = i || n.$task_data.scrollHeight
            , r = !1
            , s = !1;
        return t.eachParent(function(o) {
            if (ft(o)) {
                s = !0;
                const l = n.getItemPosition(o).rowHeight;
                l < a && (a = l,
                    r = !0)
            }
        }, e.id),
            {
                maxHeight: a,
                shrinkHeight: r,
                splitChild: s
            }
    }
        , Mn = function(t) {
        return Math.sqrt(2 * t * t)
    }
        , In = function(t) {
        return Math.round(t / Math.sqrt(2))
    }
        , Ln = function(t, n, e, i, a, r) {
        const s = Ne(t, a)
            , o = ee(t, n, a);
        let l = o.maxHeight
            , d = e.height
            , c = d > i
            , u = e.rowHeight >= i && !o.splitChild && !s;
        (c || u) && (d = i),
        l < d && (d = l);
        let h = Math.floor((e.rowHeight - d) / 2);
        if (o.splitChild && (h = Math.floor((l - d) / 2)),
        r || s) {
            let _ = Math.min(e.height, l) - d
                , f = 2
                , y = s && a.bar_height >= a.row_height
                , v = o.splitChild && e.height >= l;
            (y || v) && (f = 0),
                h = Math.floor(_ / 2) + f,
                e.rowHeight
        }
        return {
            height: d,
            marginTop: h
        }
    };
    function Vi(t) {
        t.config.baselines = {
            datastore: "baselines",
            render_mode: !1,
            dataprocessor_baselines: !1,
            row_height: 16,
            bar_height: 8
        };
        const n = t.createDatastore({
            name: t.config.baselines.datastore,
            initItem: function(a) {
                return a.id || (a.id = t.uid()),
                    function(r) {
                        if (!r.task_id || !r.start_date && !r.end_date)
                            return !1;
                        r.start_date ? r.start_date = t.date.parseDate(r.start_date, "parse_date") : r.start_date = null,
                            r.end_date ? r.end_date = t.date.parseDate(r.end_date, "parse_date") : r.end_date = null,
                            r.duration = r.duration || 1,
                            r.start_date && !r.end_date ? r.end_date = t.calculateEndDate(r.start_date, r.duration) : r.end_date && !r.start_date && (r.start_date = t.calculateEndDate(r.end_date, -r.duration))
                    }(a),
                    a
            }
        });
        function e(a) {
            let r = 0;
            t.adjustTaskHeightForBaselines(a),
                t.eachTask(function(s) {
                    let o = s.row_height || t.config.row_height;
                    r = r || o,
                    o > r && (r = o)
                }, a.id),
            a.row_height < r && (a.row_height = r)
        }
        function i(a) {
            t.eachParent(function(r) {
                if (ft(r)) {
                    const s = r.row_height || t.getLayoutView("timeline").getBarHeight(r.id);
                    let o = a.row_height;
                    t.getChildren(r.id).forEach(function(l) {
                        const d = t.getTask(l);
                        if (d.id == a.id)
                            return;
                        const c = d.row_height || t.getLayoutView("timeline").getBarHeight(d.id);
                        o = o || c,
                        c > o && (o = c)
                    }),
                        r.row_height = o,
                        r.bar_height = r.bar_height || s
                }
            }, a.id)
        }
        t.$data.baselineStore = n,
            t.adjustTaskHeightForBaselines = function(a) {
                let r, s, o = a.baselines && a.baselines.length || 0;
                const l = t.config.baselines.row_height
                    , d = t.getLayoutView("timeline");
                if (d && t.config.show_chart)
                    switch (t.config.baselines.render_mode) {
                        case "taskRow":
                        default:
                            a.row_height = a.bar_height + 8;
                            break;
                        case "separateRow":
                            r = d.getBarHeight(a.id),
                                o ? (a.bar_height = a.bar_height || r,
                                a.bar_height > r && (r = a.bar_height),
                                    a.row_height = r + l) : a.bar_height && (a.row_height = a.bar_height + 4),
                                i(a);
                            break;
                        case "individualRow":
                            r = d.getBarHeight(a.id),
                                o ? (a.bar_height = a.bar_height || r,
                                a.bar_height > r && (r = a.bar_height),
                                    s = l * o,
                                    a.row_height = r + s + 2) : a.bar_height && (a.row_height = a.bar_height + 4),
                                i(a)
                    }
            }
            ,
            t.attachEvent("onGanttReady", function() {
                t.config.baselines && (t.attachEvent("onParse", function() {
                    n.eachItem(function(a) {
                        const r = a.task_id;
                        if (t.isTaskExists(r)) {
                            const s = t.getTask(r);
                            s.baselines = s.baselines || [];
                            let o = !0;
                            for (let l = 0; l < s.baselines.length; l++) {
                                let d = s.baselines[l];
                                if (d.id == a.id) {
                                    o = !1,
                                        t.mixin(d, a, !0);
                                    break
                                }
                            }
                            o && s.baselines.push(a),
                            K(t) || (ft(s) ? e(s) : t.adjustTaskHeightForBaselines(s))
                        }
                    })
                }),
                    t.attachEvent("onBeforeTaskUpdate", function(a, r) {
                        return function(s) {
                            let o = !1;
                            const l = {}
                                , d = s.baselines || []
                                , c = t.getTaskBaselines(s.id);
                            d.length != c.length && (o = !0),
                                d.forEach(function(u) {
                                    l[u.id] = !0;
                                    const h = n.getItem(u.id);
                                    if (h) {
                                        const _ = +h.start_date != +u.start_date
                                            , f = +h.end_date != +u.end_date;
                                        (_ || f) && n.updateItem(u.id, u)
                                    } else
                                        n.addItem(u)
                                }),
                                c.forEach(function(u) {
                                    l[u.id] || n.removeItem(u.id)
                                }),
                            o && (ft(s) ? e(s) : t.adjustTaskHeightForBaselines(s),
                                t.render())
                        }(r),
                            !0
                    }),
                    t.attachEvent("onAfterUndo", function(a) {
                        if ((t.config.baselines.render_mode == "separateRow" || t.config.baselines.render_mode == "individualRow") && a) {
                            let r = !1;
                            a.commands.forEach(function(s) {
                                if (s.entity == "task") {
                                    const o = s.value.id;
                                    if (t.isTaskExists(o)) {
                                        const l = t.getTask(o);
                                        if (l.parent && t.isTaskExists(l.parent)) {
                                            const d = t.getTask(l.parent);
                                            ft(d) && (e(d),
                                                r = !0)
                                        }
                                    }
                                }
                            }),
                            r && t.render()
                        }
                    }),
                    t.attachEvent("onAfterTaskDelete", function(a, r) {
                        if (Ne && r.parent && t.isTaskExists(r.parent)) {
                            const s = t.getTask(r.parent);
                            ft(s) && e(s)
                        }
                        n.eachItem(function(s) {
                            t.isTaskExists(s.task_id) || n.removeItem(s.id)
                        })
                    }),
                    t.getTaskBaselines = function(a) {
                        const r = [];
                        return n.eachItem(function(s) {
                            s.task_id == a && r.push(s)
                        }),
                            r
                    }
                    ,
                    t.$data.baselineStore.attachEvent("onClearAll", function() {
                        return t.eachTask(function(a) {
                            a.baselines && delete a.baselines
                        }),
                            !0
                    }),
                    t.$data.tasksStore.attachEvent("onClearAll", function() {
                        return n.clearAll(),
                            !0
                    }),
                    t.attachEvent("onTaskIdChange", function(a, r) {
                        n.find(function(s) {
                            return s.task_id == a
                        }).forEach(function(s) {
                            s.task_id = r,
                                n.updateItem(s.id)
                        })
                    }))
            }, {
                once: !0
            })
    }
    function Nn(t) {
        var n = {}
            , e = {}
            , i = null
            , a = -1
            , r = null
            , s = function(o) {
            var l = -1
                , d = -1;
            return {
                resetCache: function() {
                    l = -1,
                        d = -1
                },
                _getRowHeight: function() {
                    return l === -1 && (l = o.$getConfig().row_height),
                        l
                },
                _refreshState: function() {
                    this.resetCache(),
                        d = !0;
                    var c = o.$config.rowStore;
                    if (c)
                        for (var u = this._getRowHeight(), h = 0; h < c.fullOrder.length; h++) {
                            var _ = c.getItem(c.fullOrder[h]);
                            if (_ && _.row_height && _.row_height !== u) {
                                d = !1;
                                break
                            }
                        }
                },
                canUseSimpleCalculation: function() {
                    return d === -1 && this._refreshState(),
                        d
                },
                getRowTop: function(c) {
                    return o.$config.rowStore ? c * this._getRowHeight() : 0
                },
                getItemHeight: function(c) {
                    return this._getRowHeight()
                },
                getTotalHeight: function() {
                    return o.$config.rowStore ? o.$config.rowStore.countVisible() * this._getRowHeight() : 0
                },
                getItemIndexByTopPosition: function(c) {
                    return o.$config.rowStore ? Math.floor(c / this._getRowHeight()) : 0
                }
            }
        }(t);
        return {
            _resetTopPositionHeight: function() {
                n = {},
                    e = {},
                    s.resetCache()
            },
            _resetHeight: function() {
                var o = this.$config.rowStore
                    , l = this.getCacheStateTotalHeight(o);
                r ? this.shouldClearHeightCache(r, l) && (r = l,
                    i = null) : r = l,
                    a = -1,
                    s.resetCache()
            },
            getRowTop: function(o) {
                if (s.canUseSimpleCalculation())
                    return s.getRowTop(o);
                var l = this.$config.rowStore;
                if (!l)
                    return 0;
                if (e[o] !== void 0)
                    return e[o];
                for (var d = l.getIndexRange(), c = 0, u = 0, h = 0; h < d.length; h++)
                    e[h] = c,
                        c += this.getItemHeight(d[h].id),
                    h < o && (u = c);
                return u
            },
            getItemTop: function(o) {
                if (this.$config.rowStore) {
                    if (n[o] !== void 0)
                        return n[o];
                    var l = this.$config.rowStore;
                    if (!l)
                        return 0;
                    var d = l.getIndexById(o);
                    if (d === -1 && l.getParent && l.exists(o)) {
                        var c = l.getParent(o);
                        if (l.exists(c)) {
                            var u = l.getItem(c);
                            if (this.$gantt.isSplitTask(u))
                                return this.getItemTop(c)
                        }
                    }
                    return n[o] = this.getRowTop(d),
                        n[o]
                }
                return 0
            },
            getItemHeight: function(o) {
                if (s.canUseSimpleCalculation())
                    return s.getItemHeight(o);
                if (!i && this.$config.rowStore && this._fillHeightCache(this.$config.rowStore),
                i[o] !== void 0)
                    return i[o];
                var l = this.$getConfig().row_height;
                if (this.$config.rowStore) {
                    var d = this.$config.rowStore;
                    if (!d)
                        return l;
                    var c = d.getItem(o);
                    return i[o] = c && c.row_height || l
                }
                return l
            },
            _fillHeightCache: function(o) {
                if (o) {
                    i = {};
                    var l = this.$getConfig().row_height;
                    o.eachItem(function(d) {
                        return i[d.id] = d && d.row_height || l
                    })
                }
            },
            getCacheStateTotalHeight: function(o) {
                var l = this.$getConfig().row_height
                    , d = {}
                    , c = []
                    , u = 0;
                return o && o.eachItem(function(h) {
                    c.push(h),
                        d[h.id] = h.row_height,
                        u += h.row_height || l
                }),
                    {
                        globalHeight: l,
                        items: c,
                        count: c.length,
                        sumHeight: u
                    }
            },
            shouldClearHeightCache: function(o, l) {
                if (o.count != l.count || o.globalHeight != l.globalHeight || o.sumHeight != l.sumHeight)
                    return !0;
                for (var d in o.items) {
                    var c = l.items[d];
                    if (c !== void 0 && c != o.items[d])
                        return !0
                }
                return !1
            },
            getTotalHeight: function() {
                if (s.canUseSimpleCalculation())
                    return s.getTotalHeight();
                if (a != -1)
                    return a;
                if (this.$config.rowStore) {
                    var o = this.$config.rowStore;
                    this._fillHeightCache(o);
                    var l = this.getItemHeight.bind(this)
                        , d = o.getVisibleItems()
                        , c = 0;
                    return d.forEach(function(u) {
                        c += l(u.id)
                    }),
                        a = c,
                        c
                }
                return 0
            },
            getItemIndexByTopPosition: function(o) {
                if (this.$config.rowStore) {
                    if (s.canUseSimpleCalculation())
                        return s.getItemIndexByTopPosition(o);
                    for (var l = this.$config.rowStore, d = 0; d < l.countVisible(); d++) {
                        var c = this.getRowTop(d)
                            , u = this.getRowTop(d + 1);
                        if (!u) {
                            var h = l.getIdByIndex(d);
                            u = c + this.getItemHeight(h)
                        }
                        if (o >= c && o < u)
                            return d
                    }
                    return l.countVisible() + 2
                }
                return 0
            }
        }
    }
    class Ui {
        constructor(n) {
            this._scrollOrder = 0;
            const {gantt: e, grid: i, dnd: a, getCurrentX: r} = n;
            this.$gantt = e,
                this.$grid = i,
                this._dnd = a,
                this.getCurrentX = r,
                this._scrollView = this.$gantt.$ui.getView(this.$grid.$config.scrollX),
                this.attachEvents()
        }
        attachEvents() {
            this.isScrollable() && (this._dnd.attachEvent("onDragMove", (n, e) => {
                    const i = this.$grid.$grid.getBoundingClientRect()
                        , a = i.right
                        , r = i.left
                        , s = this.getCurrentX(e.clientX);
                    return s >= a - 20 && (this.autoscrollRight(),
                        this.autoscrollStart()),
                    s <= r + 20 && (this.autoscrollLeft(),
                        this.autoscrollStart()),
                    s < a - 20 && s > r + 20 && this.autoscrollStop(),
                        !0
                }
            ),
                this._dnd.attachEvent("onDragEnd", () => {
                        this.autoscrollStop()
                    }
                ))
        }
        autoscrollStart() {
            if (this._scrollOrder === 0)
                return;
            const n = 10 * this._scrollOrder
                , e = this._scrollView.getScrollState();
            this._scrollView.scrollTo(e.position + n),
                setTimeout( () => {
                        this.autoscrollStart()
                    }
                    , 50)
        }
        autoscrollRight() {
            this._scrollOrder = 1
        }
        autoscrollLeft() {
            this._scrollOrder = -1
        }
        autoscrollStop() {
            this._scrollOrder = 0
        }
        getCorrection() {
            return this.isScrollable() ? this._scrollView.getScrollState().position : 0
        }
        isScrollable() {
            return !!this.$grid.$config.scrollable
        }
    }
    const Pn = "data-column-id";
    class Gi {
        constructor(n, e) {
            this._targetMarker = null,
                this.calculateCurrentPosition = i => {
                    const a = this.$grid.$grid.getBoundingClientRect()
                        , r = a.right
                        , s = a.left;
                    let o = i;
                    return o > r && (o = r),
                    o < s && (o = s),
                        o
                }
                ,
                this.$gantt = n,
                this.$grid = e
        }
        init() {
            const n = this.$gantt.$services.getService("dnd");
            this._dnd = new n(this.$grid.$grid_scale,{
                updates_per_second: 60
            }),
                this._scrollableGrid = new Ui({
                    gantt: this.$gantt,
                    grid: this.$grid,
                    dnd: this._dnd,
                    getCurrentX: this.calculateCurrentPosition
                }),
                this.attachEvents()
        }
        attachEvents() {
            this._dnd.attachEvent("onBeforeDragStart", (n, e) => {
                    if (this._draggedCell = this.$gantt.utils.dom.closest(e.target, ".gantt_grid_head_cell"),
                        !this._draggedCell)
                        return;
                    const i = this.$grid.$getConfig().columns
                        , a = this._draggedCell.getAttribute(Pn);
                    let r, s;
                    return i.map(function(o, l) {
                        o.name === a && (r = o,
                            s = l)
                    }),
                    this.$grid.callEvent("onBeforeColumnDragStart", [{
                        draggedColumn: r,
                        draggedIndex: s
                    }]) !== !1 && !(!this._draggedCell || !r) && (this._gridConfig = this.$grid.$getConfig(),
                        this._originAutoscroll = this.$gantt.config.autoscroll,
                        this.$gantt.config.autoscroll = !1,
                        !0)
                }
            ),
                this._dnd.attachEvent("onAfterDragStart", (n, e) => {
                        this._draggedCell && (this._dnd.config.column = this._draggedCell.getAttribute(Pn),
                            this._dnd.config.marker.innerHTML = this._draggedCell.outerHTML,
                            this._dnd.config.marker.classList.add("gantt_column_drag_marker"),
                            this._dnd.config.marker.style.height = this._gridConfig.scale_height + "px",
                            this._dnd.config.marker.style.lineHeight = this._gridConfig.scale_height + "px",
                            this._draggedCell.classList.add("gantt_grid_head_cell_dragged"))
                    }
                ),
                this._dnd.attachEvent("onDragMove", (n, e) => {
                        if (!this._draggedCell)
                            return;
                        this._dragX = e.clientX;
                        const i = this.calculateCurrentPosition(e.clientX)
                            , a = this.findColumnsIndexes();
                        return this.setMarkerPosition(i),
                            this.drawTargetMarker(a),
                            !0
                    }
                ),
                this._dnd.attachEvent("onDragEnd", () => {
                        if (!this._draggedCell)
                            return;
                        const n = this.findColumnsIndexes()
                            , e = n.targetIndex
                            , i = n.draggedIndex
                            , a = this.$grid.$getConfig().columns
                            , r = a[i]
                            , s = a[e];
                        if (this.$grid.callEvent("onColumnDragMove", [{
                            draggedColumn: r,
                            targetColumn: s,
                            draggedIndex: i,
                            targetIndex: e
                        }]) === !1)
                            return this.cleanTargetMarker(),
                                void this.$gantt.render();
                        this.$gantt.config.autoscroll = this._originAutoscroll,
                            this._draggedCell.classList.remove("gantt_grid_head_cell_dragged"),
                            this.cleanTargetMarker(),
                            this.reorderColumns()
                    }
                )
        }
        reorderColumns() {
            const {targetIndex: n, draggedIndex: e} = this.findColumnsIndexes()
                , i = this.$grid.$getConfig().columns
                , a = i[e]
                , r = i[n];
            this.$grid.callEvent("onBeforeColumnReorder", [{
                draggedColumn: a,
                targetColumn: r,
                draggedIndex: e,
                targetIndex: n
            }]) !== !1 && n !== e && (i.splice(e, 1),
                i.splice(n, 0, a),
                this.$gantt.render(),
                this.$grid.callEvent("onAfterColumnReorder", [{
                    draggedColumn: a,
                    targetColumn: r,
                    draggedIndex: e,
                    targetIndex: n
                }]))
        }
        findColumnsIndexes() {
            const n = this._dnd.config.column
                , e = this.$grid.$getConfig().columns;
            let i, a, r, s;
            const o = {
                startX: 0,
                endX: 0
            };
            let l, d = 0, c = e.length - 1, u = (f, y) => f <= y, h = f => ++f;
            this.$gantt.config.rtl && (d = e.length - 1,
                c = 0,
                u = (f, y) => f >= y,
                h = f => --f);
            const _ = this._dragX - this.$grid.$grid.getBoundingClientRect().left + this._scrollableGrid.getCorrection();
            for (let f = d; u(f, c) && (i === void 0 || a === void 0); f = h(f))
                e[f].hide || (o.startX = o.endX,
                    o.endX += e[f].width,
                _ >= o.startX && (_ <= o.endX || !u(h(f), c)) && (i = f,
                    r = o.startX,
                    s = o.endX,
                    l = (_ - o.startX) / (o.endX - o.startX)),
                n === e[f].name && (a = f));
            return {
                targetIndex: i,
                draggedIndex: a,
                xBefore: r,
                xAfter: s,
                columnRelativePos: l
            }
        }
        setMarkerPosition(n, e=10) {
            const {marker: i} = this._dnd.config
                , a = this._dnd._obj.getBoundingClientRect();
            i.style.top = `${a.y + e}px`,
                i.style.left = `${n}px`
        }
        drawTargetMarker({targetIndex: n, draggedIndex: e, xBefore: i, xAfter: a, columnRelativePos: r}) {
            let s;
            this._targetMarker || (this._targetMarker = document.createElement("div"),
                $t(this._targetMarker, "gantt_grid_target_marker"),
                this._targetMarker.style.display = "none",
                this._targetMarker.style.height = `${this._gridConfig.scale_height}px`),
            this._targetMarker.parentNode || this.$grid.$grid_scale.appendChild(this._targetMarker),
                s = n > e ? a : n < e ? i : r > .5 ? a : i,
                this._targetMarker.style.left = `${s}px`,
                this._targetMarker.style.display = "block"
        }
        cleanTargetMarker() {
            this._targetMarker && this._targetMarker.parentNode && this.$grid.$grid_scale.removeChild(this._targetMarker),
                this._targetMarker = null
        }
    }
    function Pe(t) {
        var n = [];
        return {
            delegate: function(e, i, a, r) {
                n.push([e, i, a, r]),
                    t.$services.getService("mouseEvents").delegate(e, i, a, r)
            },
            destructor: function() {
                for (var e = t.$services.getService("mouseEvents"), i = 0; i < n.length; i++) {
                    var a = n[i];
                    e.detach(a[0], a[1], a[2], a[3])
                }
                n = []
            }
        }
    }
    var ne = function(t, n, e, i) {
        this.$config = O({}, n || {}),
            this.$gantt = i,
            this.$parent = t,
            ct(this),
            this.$state = {},
            O(this, Nn(this))
    };
    function qi(t) {
        function n(e) {
            throw t.assert(!1, "Can't parse data: incorrect value of gantt.parse or gantt.load method. Actual argument value: " + JSON.stringify(e)),
                new Error("Invalid argument for gantt.parse or gantt.load. An object or a JSON string of format https://docs.dhtmlx.com/gantt/desktop__supported_data_formats.html#json is expected. Actual argument value: " + JSON.stringify(e))
        }
        t.load = function() {
            throw new Error("gantt.load() method is not available in the node.js, use gantt.parse() instead")
        }
            ,
            t.parse = function(e, i) {
                this.on_load({
                    xmlDoc: {
                        responseText: e
                    }
                }, i)
            }
            ,
            t.serialize = function(e) {
                return this[e = e || "json"].serialize()
            }
            ,
            t.on_load = function(e, i) {
                if (e.xmlDoc && e.xmlDoc.status === 404)
                    this.assert(!1, "Failed to load the data from <a href='" + e.xmlDoc.responseURL + "' target='_blank'>" + e.xmlDoc.responseURL + "</a>, server returns 404");
                else if (!t.$destroyed) {
                    this.callEvent("onBeforeParse", []),
                    i || (i = "json"),
                        this.assert(this[i], "Invalid data type:'" + i + "'");
                    var a = e.xmlDoc.responseText
                        , r = this[i].parse(a, e);
                    this._process_loading(r)
                }
            }
            ,
            t._process_loading = function(e) {
                e.collections && this._load_collections(e.collections),
                e.resources && this.$data.resourcesStore && this.$data.resourcesStore.parse(e.resources),
                t.config.baselines && e.baselines && this.$data.baselineStore && this.$data.baselineStore.parse(e.baselines);
                const i = e.data || e.tasks;
                e.assignments && function(r, s) {
                    const o = {};
                    s.forEach(l => {
                            o[l.task_id] || (o[l.task_id] = []),
                                o[l.task_id].push(l)
                        }
                    ),
                        r.forEach(l => {
                                l[t.config.resource_property] = o[l.id] || []
                            }
                        )
                }(i, e.assignments),
                    this.$data.tasksStore.parse(i);
                var a = e.links || (e.collections && e.collections.links ? e.collections.links : []);
                this.$data.linksStore.parse(a),
                    this.callEvent("onParse", []),
                    this.render()
            }
            ,
            t._load_collections = function(e) {
                var i = !1;
                for (var a in e)
                    if (e.hasOwnProperty(a)) {
                        i = !0;
                        var r = e[a];
                        this.serverList[a] = this.serverList[a] || [];
                        var s = this.serverList[a];
                        if (!s)
                            continue;
                        s.splice(0, s.length);
                        for (var o = 0; o < r.length; o++) {
                            var l = r[o]
                                , d = this.copy(l);
                            for (var c in d.key = d.value,
                                l)
                                if (l.hasOwnProperty(c)) {
                                    if (c == "value" || c == "label")
                                        continue;
                                    d[c] = l[c]
                                }
                            s.push(d)
                        }
                    }
                i && this.callEvent("onOptionsLoad", [])
            }
            ,
            t.attachEvent("onBeforeTaskDisplay", function(e, i) {
                return !i.$ignore
            }),
            t.json = {
                parse: function(e) {
                    if (e || n(e),
                    typeof e == "string")
                        if (typeof JSON != null)
                            try {
                                e = JSON.parse(e)
                            } catch {
                                n(e)
                            }
                        else
                            t.assert(!1, "JSON is not supported");
                    return e.data || e.tasks || n(e),
                    e.dhx_security && (t.security_key = e.dhx_security),
                        e
                },
                serializeTask: function(e) {
                    return this._copyObject(e)
                },
                serializeLink: function(e) {
                    return this._copyLink(e)
                },
                _copyLink: function(e) {
                    var i = {};
                    for (var a in e)
                        i[a] = e[a];
                    return i
                },
                _copyObject: function(e) {
                    var i = {};
                    for (var a in e)
                        a.charAt(0) != "$" && (i[a] = e[a],
                        nt(i[a]) && (i[a] = t.defined(t.templates.xml_format) ? t.templates.xml_format(i[a]) : t.templates.format_date(i[a])));
                    return i
                },
                serialize: function() {
                    var e = []
                        , i = [];
                    let a = [];
                    t.eachTask(function(o) {
                        t.resetProjectDates(o),
                            e.push(this.serializeTask(o))
                    }, t.config.root_id, this);
                    for (var r = t.getLinks(), s = 0; s < r.length; s++)
                        i.push(this.serializeLink(r[s]));
                    return t.getDatastore("baselines").eachItem(function(o) {
                        const l = t.json.serializeTask(o);
                        a.push(l)
                    }),
                        {
                            data: e,
                            links: i,
                            baselines: a
                        }
                }
            },
            t.xml = {
                _xmlNodeToJSON: function(e, i) {
                    for (var a = {}, r = 0; r < e.attributes.length; r++)
                        a[e.attributes[r].name] = e.attributes[r].value;
                    if (!i) {
                        for (r = 0; r < e.childNodes.length; r++) {
                            var s = e.childNodes[r];
                            s.nodeType == 1 && (a[s.tagName] = s.firstChild ? s.firstChild.nodeValue : "")
                        }
                        a.text || (a.text = e.firstChild ? e.firstChild.nodeValue : "")
                    }
                    return a
                },
                _getCollections: function(e) {
                    for (var i = {}, a = t.ajax.xpath("//coll_options", e), r = 0; r < a.length; r++)
                        for (var s = i[a[r].getAttribute("for")] = [], o = t.ajax.xpath(".//item", a[r]), l = 0; l < o.length; l++) {
                            for (var d = o[l].attributes, c = {
                                key: o[l].getAttribute("value"),
                                label: o[l].getAttribute("label")
                            }, u = 0; u < d.length; u++) {
                                var h = d[u];
                                h.nodeName != "value" && h.nodeName != "label" && (c[h.nodeName] = h.nodeValue)
                            }
                            s.push(c)
                        }
                    return i
                },
                _getXML: function(e, i, a) {
                    a = a || "data",
                    i.getXMLTopNode || (i = t.ajax.parse(i));
                    var r = t.ajax.xmltop(a, i.xmlDoc);
                    r && r.tagName == a || function(o) {
                        throw t.assert(!1, "Can't parse data: incorrect value of gantt.parse or gantt.load method. Actual argument value: " + JSON.stringify(o)),
                            new Error("Invalid argument for gantt.parse or gantt.load. An XML of format https://docs.dhtmlx.com/gantt/desktop__supported_data_formats.html#xmldhtmlxgantt20 is expected. Actual argument value: " + JSON.stringify(o))
                    }(e);
                    var s = r.getAttribute("dhx_security");
                    return s && (t.security_key = s),
                        r
                },
                parse: function(e, i) {
                    i = this._getXML(e, i);
                    for (var a = {}, r = a.data = [], s = t.ajax.xpath("//task", i), o = 0; o < s.length; o++)
                        r[o] = this._xmlNodeToJSON(s[o]);
                    return a.collections = this._getCollections(i),
                        a
                },
                _copyLink: function(e) {
                    return "<item id='" + e.id + "' source='" + e.source + "' target='" + e.target + "' type='" + e.type + "' />"
                },
                _copyObject: function(e) {
                    return "<task id='" + e.id + "' parent='" + (e.parent || "") + "' start_date='" + e.start_date + "' duration='" + e.duration + "' open='" + !!e.open + "' progress='" + e.progress + "' end_date='" + e.end_date + "'><![CDATA[" + e.text + "]]></task>"
                },
                serialize: function() {
                    for (var e = [], i = [], a = t.json.serialize(), r = 0, s = a.data.length; r < s; r++)
                        e.push(this._copyObject(a.data[r]));
                    for (r = 0,
                             s = a.links.length; r < s; r++)
                        i.push(this._copyLink(a.links[r]));
                    return "<data>" + e.join("") + "<coll_options for='links'>" + i.join("") + "</coll_options></data>"
                }
            },
            t.oldxml = {
                parse: function(e, i) {
                    i = t.xml._getXML(e, i, "projects");
                    for (var a = {
                        collections: {
                            links: []
                        }
                    }, r = a.data = [], s = t.ajax.xpath("//task", i), o = 0; o < s.length; o++) {
                        r[o] = t.xml._xmlNodeToJSON(s[o]);
                        var l = s[o].parentNode;
                        l.tagName == "project" ? r[o].parent = "project-" + l.getAttribute("id") : r[o].parent = l.parentNode.getAttribute("id")
                    }
                    for (s = t.ajax.xpath("//project", i),
                             o = 0; o < s.length; o++)
                        (d = t.xml._xmlNodeToJSON(s[o], !0)).id = "project-" + d.id,
                            r.push(d);
                    for (o = 0; o < r.length; o++) {
                        var d;
                        (d = r[o]).start_date = d.startdate || d.est,
                            d.end_date = d.enddate,
                            d.text = d.name,
                            d.duration = d.duration / 8,
                            d.open = 1,
                        d.duration || d.end_date || (d.duration = 1),
                        d.predecessortasks && a.collections.links.push({
                            target: d.id,
                            source: d.predecessortasks,
                            type: t.config.links.finish_to_start
                        })
                    }
                    return a
                },
                serialize: function() {
                    t.message("Serialization to 'old XML' is not implemented")
                }
            },
            t.serverList = function(e, i) {
                return i ? this.serverList[e] = i.slice(0) : this.serverList[e] || (this.serverList[e] = []),
                    this.serverList[e]
            }
    }
    function Re(t, n, e, i, a) {
        return this.date = t,
            this.unit = n,
            this.task = e,
            this.id = i,
            this.calendar = a,
            this
    }
    function He(t, n, e, i, a, r) {
        return this.date = t,
            this.dir = n,
            this.unit = e,
            this.task = i,
            this.id = a,
            this.calendar = r,
            this
    }
    function Oe(t, n, e, i, a, r, s) {
        return this.start_date = t,
            this.duration = n,
            this.unit = e,
            this.step = i,
            this.task = a,
            this.id = r,
            this.calendar = s,
            this
    }
    function Yi(t, n, e, i) {
        return this.start_date = t,
            this.end_date = n,
            this.task = e,
            this.calendar = i,
            this.unit = null,
            this.step = null,
            this
    }
    ne.prototype = {
        init: function(t) {
            var n = this.$gantt
                , e = n._waiAria.gridAttrString()
                , i = n._waiAria.gridDataAttrString()
                , a = this.$getConfig()
                , r = a.reorder_grid_columns || !1;
            this.$config.reorder_grid_columns !== void 0 && (r = this.$config.reorder_grid_columns),
                t.innerHTML = "<div class='gantt_grid' style='height:inherit;width:inherit;' " + e + "></div>",
                this.$grid = t.childNodes[0],
                this.$grid.innerHTML = "<div class='gantt_grid_scale' " + n._waiAria.gridScaleRowAttrString() + "></div><div class='gantt_grid_data' " + i + "></div>",
                this.$grid_scale = this.$grid.childNodes[0],
                this.$grid_data = this.$grid.childNodes[1];
            var s = a[this.$config.bind + "_attribute"];
            if (!s && this.$config.bind && (s = "data-" + this.$config.bind + "-id"),
                this.$config.item_attribute = s || null,
                !this.$config.layers) {
                var o = this._createLayerConfig();
                this.$config.layers = o
            }
            var l = function(c, u) {
                var h = {
                    column_before_start: c.bind(function(_, f, y) {
                        var v = u.$getConfig()
                            , b = Q(y, v.grid_resizer_column_attribute);
                        if (!b || !dt(b, ".gantt_grid_column_resize_wrap"))
                            return !1;
                        var g = this.locate(y, v.grid_resizer_column_attribute)
                            , m = u.getGridColumns()[g];
                        return u.callEvent("onColumnResizeStart", [g, m]) !== !1 && void 0
                    }, c),
                    column_after_start: c.bind(function(_, f, y) {
                        var v = u.$getConfig()
                            , b = this.locate(y, v.grid_resizer_column_attribute);
                        _.config.marker.innerHTML = "",
                            _.config.marker.className += " gantt_grid_resize_area",
                            _.config.marker.style.height = u.$grid.offsetHeight + "px",
                            _.config.marker.style.top = "0px",
                            _.config.drag_index = b
                    }, c),
                    column_drag_move: c.bind(function(_, f, y) {
                        var v = u.$getConfig()
                            , b = _.config
                            , g = u.getGridColumns()
                            , m = parseInt(b.drag_index, 10)
                            , p = g[m]
                            , k = Y(u.$grid_scale)
                            , w = parseInt(b.marker.style.left, 10)
                            , x = p.min_width ? p.min_width : v.min_grid_column_width
                            , $ = u.$grid_data.offsetWidth
                            , S = 0
                            , T = 0;
                        v.rtl ? w = k.x + k.width - 1 - w : w -= k.x - 1;
                        for (var E = 0; E < m; E++)
                            x += g[E].width,
                                S += g[E].width;
                        if (w < x && (w = x),
                            v.keep_grid_width) {
                            var C = 0;
                            for (E = m + 1; E < g.length; E++)
                                g[E].min_width ? $ -= g[E].min_width : v.min_grid_column_width && ($ -= v.min_grid_column_width),
                                    g[E].max_width && C !== !1 ? C += g[E].max_width : C = !1;
                            C && (x = u.$grid_data.offsetWidth - C),
                            w < x && (w = x),
                            w > $ && (w = $)
                        } else if (!u.$config.scrollable) {
                            var D = w
                                , A = c.$container.offsetWidth
                                , I = 0;
                            if (u.$grid_data.offsetWidth <= A - 25)
                                for (E = m + 1; E < g.length; E++)
                                    I += g[E].width;
                            else {
                                for (E = m + 1; E >= 0; E--)
                                    I += g[E].width;
                                I = A - I
                            }
                            I > A && (I -= A);
                            var M = u.$parent.$parent;
                            if (M && M.$config.mode == "y") {
                                var L = M.$lastSize.x;
                                A = Math.min(A, L - (M.$cells.length - 1))
                            }
                            D + I > A && (w = A - I)
                        }
                        return b.left = w - 1,
                            T = Math.abs(w - S),
                        p.max_width && T > p.max_width && (T = p.max_width),
                        v.rtl && (S = k.width - S + 2 - T),
                            b.marker.style.top = k.y + "px",
                            b.marker.style.left = k.x - 1 + S + "px",
                            b.marker.style.width = T + "px",
                            u.callEvent("onColumnResize", [m, g[m], T - 1]),
                            !0
                    }, c),
                    column_drag_end: c.bind(function(_, f, y) {
                        for (var v = u.$getConfig(), b = u.getGridColumns(), g = 0, m = parseInt(_.config.drag_index, 10), p = b[m], k = 0; k < m; k++)
                            g += b[k].width;
                        var w = p.min_width && _.config.left - g < p.min_width ? p.min_width : _.config.left - g;
                        if (p.max_width && p.max_width < w && (w = p.max_width),
                        u.callEvent("onColumnResizeEnd", [m, p, w]) !== !1 && p.width != w) {
                            if (p.width = w,
                                v.keep_grid_width)
                                g = v.grid_width;
                            else {
                                k = m;
                                for (var x = b.length; k < x; k++)
                                    g += b[k].width
                            }
                            u.callEvent("onColumnResizeComplete", [b, u._setColumnsWidth(g, m)]),
                            u.$config.scrollable || c.$layout._syncCellSizes(u.$config.group, {
                                value: v.grid_width,
                                isGravity: !1
                            }),
                                this.render()
                        }
                    }, c)
                };
                return {
                    init: function() {
                        var _ = c.$services.getService("dnd")
                            , f = u.$getConfig()
                            , y = new _(u.$grid_scale,{
                            updates_per_second: 60
                        });
                        c.defined(f.dnd_sensitivity) && (y.config.sensitivity = f.dnd_sensitivity),
                            y.attachEvent("onBeforeDragStart", function(v, b) {
                                return h.column_before_start(y, v, b)
                            }),
                            y.attachEvent("onAfterDragStart", function(v, b) {
                                return h.column_after_start(y, v, b)
                            }),
                            y.attachEvent("onDragMove", function(v, b) {
                                return h.column_drag_move(y, v, b)
                            }),
                            y.attachEvent("onDragEnd", function(v, b) {
                                return h.column_drag_end(y, v, b)
                            })
                    },
                    doOnRender: function() {
                        for (var _ = u.getGridColumns(), f = u.$getConfig(), y = 0, v = u.$config.width, b = f.scale_height, g = 0; g < _.length; g++) {
                            var m, p = _[g];
                            if (y += p.width,
                                m = f.rtl ? v - y : y,
                            p.resize && g != _.length - 1) {
                                var k = document.createElement("div");
                                k.className = "gantt_grid_column_resize_wrap",
                                    k.style.top = "0px",
                                    k.style.height = b + "px",
                                    k.innerHTML = "<div class='gantt_grid_column_resize'></div>",
                                    k.setAttribute(f.grid_resizer_column_attribute, g),
                                    k.setAttribute("column_index", g),
                                    c._waiAria.gridSeparatorAttr(k),
                                    u.$grid_scale.appendChild(k),
                                    k.style.left = Math.max(0, m) + "px"
                            }
                        }
                    }
                }
            }(n, this);
            l.init(),
                this._renderHeaderResizers = l.doOnRender,
                this._mouseDelegates = Pe(n);
            var d = function(c, u) {
                var h = {
                    row_before_start: c.bind(function(_, f, y) {
                        var v = u.$getConfig()
                            , b = u.$config.rowStore;
                        if (!Q(y, v.task_grid_row_resizer_attribute))
                            return !1;
                        var g = this.locate(y, v.task_grid_row_resizer_attribute)
                            , m = b.getItem(g);
                        return u.callEvent("onBeforeRowResize", [m]) !== !1 && void 0
                    }, c),
                    row_after_start: c.bind(function(_, f, y) {
                        var v = u.$getConfig()
                            , b = this.locate(y, v.task_grid_row_resizer_attribute);
                        _.config.marker.innerHTML = "",
                            _.config.marker.className += " gantt_row_grid_resize_area",
                            _.config.marker.style.width = u.$grid.offsetWidth + "px",
                            _.config.drag_id = b
                    }, c),
                    row_drag_move: c.bind(function(_, f, y) {
                        var v = u.$config.rowStore
                            , b = u.$getConfig()
                            , g = _.config
                            , m = g.drag_id
                            , p = u.getItemHeight(m)
                            , k = u.getItemTop(m) - f.scrollTop
                            , w = Y(u.$grid_data)
                            , x = parseInt(g.marker.style.top, 10)
                            , $ = k + w.y
                            , S = 0
                            , T = b.min_task_grid_row_height;
                        return (S = x - $) < T && (S = T),
                            g.marker.style.left = w.x + "px",
                            g.marker.style.top = $ - 1 + "px",
                            g.marker.style.height = Math.abs(S) + 1 + "px",
                            g.marker_height = S,
                            u.callEvent("onRowResize", [m, v.getItem(m), S + p]),
                            !0
                    }, c),
                    row_drag_end: c.bind(function(_, f, y) {
                        var v = u.$config.rowStore
                            , b = _.config
                            , g = b.drag_id
                            , m = v.getItem(g)
                            , p = u.getItemHeight(g)
                            , k = b.marker_height;
                        u.callEvent("onBeforeRowResizeEnd", [g, m, k]) !== !1 && m.row_height != k && (m.row_height = k,
                            v.updateItem(g),
                            u.callEvent("onAfterRowResize", [g, m, p, k]),
                            this.render())
                    }, c)
                };
                return {
                    init: function() {
                        var _ = c.$services.getService("dnd")
                            , f = u.$getConfig()
                            , y = new _(u.$grid_data,{
                            updates_per_second: 60
                        });
                        c.defined(f.dnd_sensitivity) && (y.config.sensitivity = f.dnd_sensitivity),
                            y.attachEvent("onBeforeDragStart", function(v, b) {
                                return h.row_before_start(y, v, b)
                            }),
                            y.attachEvent("onAfterDragStart", function(v, b) {
                                return h.row_after_start(y, v, b)
                            }),
                            y.attachEvent("onDragMove", function(v, b) {
                                return h.row_drag_move(y, v, b)
                            }),
                            y.attachEvent("onDragEnd", function(v, b) {
                                return h.row_drag_end(y, v, b)
                            })
                    }
                }
            }(n, this);
            d.init(),
                this._addLayers(this.$gantt),
                this._initEvents(),
            r && (this._columnDND = new Gi(n,this),
                this._columnDND.init()),
                this.callEvent("onReady", [])
        },
        _validateColumnWidth: function(t, n) {
            var e = t[n];
            if (e && e != "*") {
                var i = this.$gantt
                    , a = 1 * e;
                isNaN(a) ? i.assert(!1, "Wrong " + n + " value of column " + t.name) : t[n] = a
            }
        },
        setSize: function(t, n) {
            this.$config.width = this.$state.width = t,
                this.$config.height = this.$state.height = n;
            for (var e, i = this.getGridColumns(), a = 0, r = (d = this.$getConfig()).grid_elastic_columns, s = 0, o = i.length; s < o; s++)
                this._validateColumnWidth(i[s], "min_width"),
                    this._validateColumnWidth(i[s], "max_width"),
                    this._validateColumnWidth(i[s], "width"),
                    a += 1 * i[s].width;
            if (!isNaN(a) && this.$config.scrollable || (a = e = this._setColumnsWidth(t + 1)),
            this.$config.scrollable && r && !isNaN(a)) {
                let u = "width";
                r == "min_width" && (u = "min_width");
                let h = 0;
                i.forEach(function(_) {
                    h += _[u] || d.min_grid_column_width
                });
                var l = Math.max(h, t);
                a = this._setColumnsWidth(l),
                    e = t
            }
            this.$config.scrollable ? (this.$grid_scale.style.width = a + "px",
                this.$grid_data.style.width = a + "px") : (this.$grid_scale.style.width = "inherit",
                this.$grid_data.style.width = "inherit"),
                this.$config.width -= 1;
            var d = this.$getConfig();
            e !== t && (e !== void 0 ? (d.grid_width = e,
                this.$config.width = e - 1) : isNaN(a) || (this._setColumnsWidth(a),
                d.grid_width = a,
                this.$config.width = a - 1));
            var c = Math.max(this.$state.height - d.scale_height, 0);
            this.$grid_data.style.height = c + "px",
                this.refresh()
        },
        getSize: function() {
            var t = this.$getConfig()
                , n = this.$config.rowStore ? this.getTotalHeight() : 0
                , e = this._getGridWidth();
            return {
                x: this.$state.width,
                y: this.$state.height,
                contentX: this.isVisible() ? e : 0,
                contentY: this.isVisible() ? t.scale_height + n : 0,
                scrollHeight: this.isVisible() ? n : 0,
                scrollWidth: this.isVisible() ? e : 0
            }
        },
        _bindStore: function() {
            if (this.$config.bind) {
                var t = this.$gantt.getDatastore(this.$config.bind);
                if (this.$config.rowStore = t,
                t && !t._gridCacheAttached) {
                    var n = this;
                    t._gridCacheAttached = t.attachEvent("onBeforeFilter", function() {
                        n._resetTopPositionHeight()
                    })
                }
            }
        },
        _unbindStore: function() {
            if (this.$config.bind) {
                var t = this.$gantt.getDatastore(this.$config.bind);
                t && t._gridCacheAttached && (t.detachEvent(t._gridCacheAttached),
                    t._gridCacheAttached = !1)
            }
        },
        refresh: function() {
            this._bindStore(),
                this._resetTopPositionHeight(),
                this._resetHeight(),
                this._initSmartRenderingPlaceholder(),
                this._calculateGridWidth(),
                this._renderGridHeader()
        },
        getViewPort: function() {
            var t = this.$config.scrollLeft || 0
                , n = this.$config.scrollTop || 0
                , e = this.$config.height || 0
                , i = this.$config.width || 0;
            return {
                y: n,
                y_end: n + e,
                x: t,
                x_end: t + i,
                height: e,
                width: i
            }
        },
        scrollTo: function(t, n) {
            if (this.isVisible()) {
                var e = !1;
                this.$config.scrollTop = this.$config.scrollTop || 0,
                    this.$config.scrollLeft = this.$config.scrollLeft || 0,
                1 * t == t && (this.$config.scrollLeft = this.$state.scrollLeft = this.$grid.scrollLeft = t,
                    e = !0),
                1 * n == n && (this.$config.scrollTop = this.$state.scrollTop = this.$grid_data.scrollTop = n,
                    e = !0),
                e && this.callEvent("onScroll", [this.$config.scrollLeft, this.$config.scrollTop])
            }
        },
        getColumnIndex: function(t, n) {
            for (var e = this.$getConfig().columns, i = 0, a = 0; a < e.length; a++)
                if (n && e[a].hide && i++,
                e[a].name == t)
                    return a - i;
            return null
        },
        getColumn: function(t) {
            var n = this.getColumnIndex(t);
            return n === null ? null : this.$getConfig().columns[n]
        },
        getGridColumns: function() {
            return this.$getConfig().columns.slice()
        },
        isVisible: function() {
            return this.$parent && this.$parent.$config ? !this.$parent.$config.hidden : this.$grid.offsetWidth
        },
        _createLayerConfig: function() {
            var t = this.$gantt
                , n = this;
            return [{
                renderer: t.$ui.layers.gridLine(),
                container: this.$grid_data,
                filter: [function() {
                    return n.isVisible()
                }
                ]
            }, {
                renderer: t.$ui.layers.gridTaskRowResizer(),
                container: this.$grid_data,
                append: !0,
                filter: [function() {
                    return t.config.resize_rows
                }
                ]
            }]
        },
        _addLayers: function(t) {
            if (this.$config.bind) {
                this._taskLayers = [];
                var n = this
                    , e = this.$gantt.$services.getService("layers")
                    , i = e.getDataRender(this.$config.bind);
                i || (i = e.createDataRender({
                    name: this.$config.bind,
                    defaultContainer: function() {
                        return n.$grid_data
                    }
                }));
                for (var a = this.$config.layers, r = 0; a && r < a.length; r++) {
                    var s = a[r];
                    s.view = this;
                    var o = i.addLayer(s);
                    this._taskLayers.push(o)
                }
                this._bindStore(),
                    this._initSmartRenderingPlaceholder()
            }
        },
        _refreshPlaceholderOnStoreUpdate: function(t) {
            var n = this.$getConfig()
                , e = this.$config.rowStore;
            if (e && t === null && this.isVisible() && n.smart_rendering) {
                var i;
                if (this.$config.scrollY) {
                    var a = this.$gantt.$ui.getView(this.$config.scrollY);
                    a && (i = a.getScrollState().scrollSize)
                }
                if (i || (i = e ? this.getTotalHeight() : 0),
                    i) {
                    this.$rowsPlaceholder && this.$rowsPlaceholder.parentNode && this.$rowsPlaceholder.parentNode.removeChild(this.$rowsPlaceholder);
                    var r = this.$rowsPlaceholder = document.createElement("div");
                    r.style.visibility = "hidden",
                        r.style.height = i + "px",
                        r.style.width = "1px",
                        this.$grid_data.appendChild(r)
                }
            }
        },
        _initSmartRenderingPlaceholder: function() {
            var t = this.$config.rowStore;
            t && (this._initSmartRenderingPlaceholder = function() {}
                ,
                this._staticBgHandler = t.attachEvent("onStoreUpdated", z(this._refreshPlaceholderOnStoreUpdate, this)))
        },
        _initEvents: function() {
            var t = this.$gantt;
            this._mouseDelegates.delegate("click", "gantt_close", t.bind(function(n, e, i) {
                var a = this.$config.rowStore;
                if (!a)
                    return !0;
                var r = Q(n, this.$config.item_attribute);
                return r && a.close(r.getAttribute(this.$config.item_attribute)),
                    !1
            }, this), this.$grid),
                this._mouseDelegates.delegate("click", "gantt_open", t.bind(function(n, e, i) {
                    var a = this.$config.rowStore;
                    if (!a)
                        return !0;
                    var r = Q(n, this.$config.item_attribute);
                    return r && a.open(r.getAttribute(this.$config.item_attribute)),
                        !1
                }, this), this.$grid)
        },
        _clearLayers: function(t) {
            var n = this.$gantt.$services.getService("layers").getDataRender(this.$config.bind);
            if (this._taskLayers)
                for (var e = 0; e < this._taskLayers.length; e++)
                    n.removeLayer(this._taskLayers[e]);
            this._taskLayers = []
        },
        _getColumnWidth: function(t, n, e) {
            var i = t.min_width || n.min_grid_column_width
                , a = Math.max(e, i || 10);
            return t.max_width && (a = Math.min(a, t.max_width)),
                a
        },
        _checkGridColumnMinWidthLimits: function(t, n) {
            for (var e = 0, i = t.length; e < i; e++) {
                var a = 1 * t[e].width;
                !t[e].min_width && a < n.min_grid_column_width && (t[e].min_width = a)
            }
        },
        _getGridWidthLimits: function() {
            for (var t = this.$getConfig(), n = this.getGridColumns(), e = 0, i = 0, a = 0; a < n.length; a++)
                e += n[a].min_width ? n[a].min_width : t.min_grid_column_width,
                i !== void 0 && (i = n[a].max_width ? i + n[a].max_width : void 0);
            return this._checkGridColumnMinWidthLimits(n, t),
                [e, i]
        },
        _setColumnsWidth: function(t, n) {
            var e = this.$getConfig()
                , i = this.getGridColumns()
                , a = 0
                , r = t;
            n = window.isNaN(n) ? -1 : n;
            for (var s = 0, o = i.length; s < o; s++)
                a += 1 * i[s].width;
            if (window.isNaN(a))
                for (this._calculateGridWidth(),
                         a = 0,
                         s = 0,
                         o = i.length; s < o; s++)
                    a += 1 * i[s].width;
            var l = r - a
                , d = 0;
            for (s = 0; s < n + 1; s++)
                d += i[s].width;
            for (a -= d,
                     s = n + 1; s < i.length; s++) {
                var c = i[s]
                    , u = Math.round(l * (c.width / a));
                l < 0 ? c.min_width && c.width + u < c.min_width ? u = c.min_width - c.width : !c.min_width && e.min_grid_column_width && c.width + u < e.min_grid_column_width && (u = e.min_grid_column_width - c.width) : c.max_width && c.width + u > c.max_width && (u = c.max_width - c.width),
                    a -= c.width,
                    c.width += u,
                    l -= u
            }
            for (var h = l > 0 ? 1 : -1; l > 0 && h === 1 || l < 0 && h === -1; ) {
                var _ = l;
                for (s = n + 1; s < i.length; s++) {
                    var f;
                    if ((f = i[s].width + h) == this._getColumnWidth(i[s], e, f) && (l -= h,
                        i[s].width = f),
                        !l)
                        break
                }
                if (_ == l)
                    break
            }
            return l && n > -1 && (f = i[n].width + l) == this._getColumnWidth(i[n], e, f) && (i[n].width = f),
                this._getColsTotalWidth()
        },
        _getColsTotalWidth: function() {
            for (var t = this.getGridColumns(), n = 0, e = 0; e < t.length; e++) {
                var i = parseFloat(t[e].width);
                if (window.isNaN(i))
                    return !1;
                n += i
            }
            return n
        },
        _calculateGridWidth: function() {
            for (var t = this.$getConfig(), n = this.getGridColumns(), e = 0, i = [], a = [], r = 0; r < n.length; r++) {
                var s = parseFloat(n[r].width);
                window.isNaN(s) && (s = t.min_grid_column_width || 10,
                    i.push(r)),
                    a[r] = s,
                    e += s
            }
            var o = this._getGridWidth() + 1;
            if (t.autofit || i.length) {
                var l = o - e;
                if (t.autofit && !t.grid_elastic_columns)
                    for (r = 0; r < a.length; r++) {
                        var d = Math.round(l / (a.length - r));
                        a[r] += d,
                        (c = this._getColumnWidth(n[r], t, a[r])) != a[r] && (d = c - a[r],
                            a[r] = c),
                            l -= d
                    }
                else if (i.length)
                    for (r = 0; r < i.length; r++) {
                        d = Math.round(l / (i.length - r));
                        var c, u = i[r];
                        a[u] += d,
                        (c = this._getColumnWidth(n[u], t, a[u])) != a[u] && (d = c - a[u],
                            a[u] = c),
                            l -= d
                    }
                for (r = 0; r < a.length; r++)
                    n[r].width = a[r]
            } else {
                var h = o != e;
                this.$config.width = e - 1,
                    t.grid_width = e,
                h && this.$parent._setContentSize(this.$config.width, null)
            }
        },
        _renderGridHeader: function() {
            var t = this.$gantt
                , n = this.$getConfig()
                , e = this.$gantt.locale
                , i = this.$gantt.templates
                , a = this.getGridColumns();
            n.rtl && (a = a.reverse());
            var r = []
                , s = 0
                , o = e.labels
                , l = n.scale_height - 1;
            const d = {};
            for (var c = 0; c < a.length; c++) {
                var u = c == a.length - 1
                    , h = a[c];
                h.name || (h.name = t.uid() + "");
                var _ = 1 * h.width
                    , f = this._getGridWidth();
                u && f > s + _ && (h.width = _ = f - s),
                    s += _;
                var y = t._sort && h.name == t._sort.name ? `<div data-column-id="${h.name}" class="gantt_sort gantt_${t._sort.direction}"></div>` : ""
                    , v = ["gantt_grid_head_cell", "gantt_grid_head_" + h.name, u ? "gantt_last_cell" : "", i.grid_header_class(h.name, h)].join(" ")
                    , b = "width:" + (_ - (u ? 1 : 0)) + "px;"
                    , g = h.label || o["column_" + h.name] || o[h.name];
                typeof g == "function" && (g = g.call(t, h.name, h)),
                    g = g || "";
                let p = !1;
                t.config.external_render && t.config.external_render.isElement(g) && (p = !0,
                    d[h.name] = g);
                var m = "<div class='" + v + "' style='" + b + "' " + t._waiAria.gridScaleCellAttrString(h, g) + " data-column-id='" + h.name + "' column_id='" + h.name + "' data-column-name='" + h.name + "' data-column-index='" + c + "'>" + (p ? "<div data-component-container></div>" : g) + y + "</div>";
                r.push(m)
            }
            this.$grid_scale.style.height = n.scale_height + "px",
                this.$grid_scale.style.lineHeight = l + "px",
                this.$grid_scale.innerHTML = r.join("");
            for (let p in d)
                t.config.external_render.renderElement(d[p], this.$grid_scale.querySelector("[data-column-id='" + p + "'] [data-component-container]"));
            this._renderHeaderResizers && this._renderHeaderResizers()
        },
        _getGridWidth: function() {
            return this.$config.width
        },
        destructor: function() {
            this._clearLayers(this.$gantt),
            this._mouseDelegates && (this._mouseDelegates.destructor(),
                this._mouseDelegates = null),
                this._unbindStore(),
                this.$grid = null,
                this.$grid_scale = null,
                this.$grid_data = null,
                this.$gantt = null,
            this.$config.rowStore && (this.$config.rowStore.detachEvent(this._staticBgHandler),
                this.$config.rowStore = null),
                this.callEvent("onDestroy", []),
                this.detachAllEvents()
        }
    };
    var Rn = function(t) {
        return {
            getWorkHoursArguments: function() {
                var n = arguments[0];
                if (!Tt((n = nt(n) ? {
                    date: n
                } : O({}, n)).date))
                    throw t.assert(!1, "Invalid date argument for getWorkHours method"),
                        new Error("Invalid date argument for getWorkHours method");
                return n
            },
            setWorkTimeArguments: function() {
                return arguments[0]
            },
            unsetWorkTimeArguments: function() {
                return arguments[0]
            },
            isWorkTimeArguments: function() {
                var n, e = arguments[0];
                if (e instanceof Re)
                    return e;
                if ((n = e.date ? new Re(e.date,e.unit,e.task,null,e.calendar) : new Re(arguments[0],arguments[1],arguments[2],null,arguments[3])).unit = n.unit || t.config.duration_unit,
                    !Tt(n.date))
                    throw t.assert(!1, "Invalid date argument for isWorkTime method"),
                        new Error("Invalid date argument for isWorkTime method");
                return n
            },
            getClosestWorkTimeArguments: function(n) {
                var e, i = arguments[0];
                if (i instanceof He)
                    return i;
                if (e = nt(i) ? new He(i) : new He(i.date,i.dir,i.unit,i.task,null,i.calendar),
                i.id && (e.task = i),
                    e.dir = i.dir || "any",
                    e.unit = i.unit || t.config.duration_unit,
                    !Tt(e.date))
                    throw t.assert(!1, "Invalid date argument for getClosestWorkTime method"),
                        new Error("Invalid date argument for getClosestWorkTime method");
                return e
            },
            _getStartEndConfig: function(n) {
                var e, i = Yi;
                if (n instanceof i)
                    return n;
                if (nt(n) ? e = new i(arguments[0],arguments[1],arguments[2],arguments[3]) : (e = new i(n.start_date,n.end_date,n.task),
                n.id !== null && n.id !== void 0 && (e.task = n)),
                    e.unit = e.unit || t.config.duration_unit,
                    e.step = e.step || t.config.duration_step,
                    e.start_date = e.start_date || e.start || e.date,
                    !Tt(e.start_date))
                    throw t.assert(!1, "Invalid start_date argument for getDuration method"),
                        new Error("Invalid start_date argument for getDuration method");
                if (!Tt(e.end_date))
                    throw t.assert(!1, "Invalid end_date argument for getDuration method"),
                        new Error("Invalid end_date argument for getDuration method");
                return e
            },
            getDurationArguments: function(n, e, i, a) {
                return this._getStartEndConfig.apply(this, arguments)
            },
            hasDurationArguments: function(n, e, i, a) {
                return this._getStartEndConfig.apply(this, arguments)
            },
            calculateEndDateArguments: function(n, e, i, a) {
                var r, s = arguments[0];
                if (s instanceof Oe)
                    return s;
                if (r = nt(s) ? new Oe(arguments[0],arguments[1],arguments[2],void 0,arguments[3],void 0,arguments[4]) : new Oe(s.start_date,s.duration,s.unit,s.step,s.task,null,s.calendar),
                s.id !== null && s.id !== void 0 && (r.task = s,
                    r.unit = null,
                    r.step = null),
                    r.unit = r.unit || t.config.duration_unit,
                    r.step = r.step || t.config.duration_step,
                    !Tt(r.start_date))
                    throw t.assert(!1, "Invalid start_date argument for calculateEndDate method"),
                        new Error("Invalid start_date argument for calculateEndDate method");
                return r
            }
        }
    };
    function Hn() {}
    Hn.prototype = {
        _getIntervals: function(t) {
            for (var n = [], e = 0; e < t.length; e += 2)
                n.push({
                    start: t[e],
                    end: t[e + 1]
                });
            return n
        },
        _toHoursArray: function(t) {
            var n = [];
            function e(a) {
                var r, s = Math.floor(a / 3600), o = a - 60 * s * 60, l = Math.floor(o / 60);
                return s + ":" + ((r = String(l)).length < 2 && (r = "0" + r),
                    r)
            }
            for (var i = 0; i < t.length; i++)
                n.push(e(t[i].start) + "-" + e(t[i].end));
            return n
        },
        _intersectHourRanges: function(t, n) {
            var e = []
                , i = t.length > n.length ? t : n
                , a = t === i ? n : t;
            i = i.slice(),
                a = a.slice(),
                e = [];
            for (var r = 0; r < i.length; r++)
                for (var s = i[r], o = 0; o < a.length; o++) {
                    var l = a[o];
                    l.start < s.end && l.end > s.start && (e.push({
                        start: Math.max(s.start, l.start),
                        end: Math.min(s.end, l.end)
                    }),
                    s.end > l.end && (a.splice(o, 1),
                        o--,
                        r--))
                }
            return e
        },
        _mergeAdjacentIntervals: function(t) {
            var n = t.slice();
            n.sort(function(r, s) {
                return r.start - s.start
            });
            for (var e = n[0], i = 1; i < n.length; i++) {
                var a = n[i];
                a.start <= e.end ? (a.end > e.end && (e.end = a.end),
                    n.splice(i, 1),
                    i--) : e = a
            }
            return n
        },
        _mergeHoursConfig: function(t, n) {
            return this._mergeAdjacentIntervals(this._intersectHourRanges(t, n))
        },
        merge: function(t, n) {
            const e = X(t.getConfig())
                , i = X(n.getConfig())
                , a = e.parsed
                , r = i.parsed;
            a.customWeeks = e.customWeeks,
                r.customWeeks = i.customWeeks;
            var s = {
                hours: this._toHoursArray(this._mergeHoursConfig(a.hours, r.hours)),
                dates: {},
                customWeeks: {}
            };
            const o = (d, c) => {
                    for (let u in d.dates) {
                        const h = d.dates[u];
                        +u > 1e3 && (s.dates[u] = !1);
                        for (const _ in c.dates) {
                            const f = c.dates[_];
                            if (_ == u && (s.dates[u] = !(!h || !f)),
                                Array.isArray(h)) {
                                const y = Array.isArray(f) ? f : c.hours;
                                s.dates[u] = this._toHoursArray(this._mergeHoursConfig(h, y))
                            }
                        }
                    }
                }
            ;
            if (o(a, r),
                o(r, a),
                a.customWeeks)
                for (var l in a.customWeeks)
                    s.customWeeks[l] = a.customWeeks[l];
            if (r.customWeeks)
                for (var l in r.customWeeks)
                    s.customWeeks[l] ? s.customWeeks[l + "_second"] = r.customWeeks[l] : s.customWeeks[l] = r.customWeeks[l];
            return s
        }
    };
    class Ji {
        constructor() {
            this.clear()
        }
        getItem(n, e, i) {
            if (this._cache.has(n)) {
                const a = this._cache.get(n)[i.getFullYear()];
                if (a && a.has(e))
                    return a.get(e)
            }
            return -1
        }
        setItem(n, e, i, a) {
            if (!n || !e)
                return;
            const r = this._cache
                , s = a.getFullYear();
            let o;
            r.has(n) ? o = r.get(n) : (o = [],
                r.set(n, o));
            let l = o[s];
            l || (l = o[s] = new Map),
                l.set(e, i)
        }
        clear() {
            this._cache = new Map
        }
    }
    class Ki {
        constructor() {
            this.clear()
        }
        getItem(n, e, i) {
            const a = this._cache;
            if (a && a[n]) {
                const r = a[n];
                if (r === void 0)
                    return -1;
                const s = r[i.getFullYear()];
                if (s && s[e] !== void 0)
                    return s[e]
            }
            return -1
        }
        setItem(n, e, i, a) {
            if (!n || !e)
                return;
            const r = this._cache;
            if (!r)
                return;
            r[n] || (r[n] = []);
            const s = r[n]
                , o = a.getFullYear();
            let l = s[o];
            l || (l = s[o] = {}),
                l[e] = i
        }
        clear() {
            this._cache = {}
        }
    }
    class Xi {
        constructor(n) {
            this.getMinutesPerWeek = e => {
                const i = e.valueOf();
                if (this._weekCache.has(i))
                    return this._weekCache.get(i);
                const a = this._calendar
                    , r = this._calendar.$gantt;
                let s = 0
                    , o = r.date.week_start(new Date(e));
                for (let l = 0; l < 7; l++)
                    s += 60 * a.getHoursPerDay(o),
                        o = r.date.add(o, 1, "day");
                return this._weekCache.set(i, s),
                    s
            }
                ,
                this.getMinutesPerMonth = e => {
                    const i = e.valueOf();
                    if (this._monthCache.has(i))
                        return this._monthCache.get(i);
                    const a = this._calendar
                        , r = this._calendar.$gantt;
                    let s = 0
                        , o = r.date.week_start(new Date(e));
                    const l = r.date.add(o, 1, "month").valueOf();
                    for (; o.valueOf() < l; )
                        s += 60 * a.getHoursPerDay(o),
                            o = r.date.add(o, 1, "day");
                    return this._monthCache.set(i, s),
                        s
                }
                ,
                this.clear = () => {
                    this._weekCache = new Map,
                        this._monthCache = new Map
                }
                ,
                this.clear(),
                this._calendar = n
        }
    }
    class Zi {
        constructor() {
            this.clear()
        }
        _getCacheObject(n, e, i) {
            const a = this._cache;
            a[e] || (a[e] = []);
            let r = a[e];
            r || (r = a[e] = {});
            let s = r[i];
            s || (s = r[i] = {});
            const o = n.getFullYear();
            let l = s[o];
            return l || (l = s[o] = {
                durations: {},
                endDates: {}
            }),
                l
        }
        _endDateCacheKey(n, e) {
            return String(n) + "-" + String(e)
        }
        _durationCacheKey(n, e) {
            return String(n) + "-" + String(e)
        }
        getEndDate(n, e, i, a, r) {
            const s = this._getCacheObject(n, i, a)
                , o = n.valueOf()
                , l = this._endDateCacheKey(o, e);
            let d;
            if (s.endDates[l] === void 0) {
                const c = r()
                    , u = c.valueOf();
                s.endDates[l] = u,
                    s.durations[this._durationCacheKey(o, u)] = e,
                    d = c
            } else
                d = new Date(s.endDates[l]);
            return d
        }
        getDuration(n, e, i, a, r) {
            const s = this._getCacheObject(n, i, a)
                , o = n.valueOf()
                , l = e.valueOf()
                , d = this._durationCacheKey(o, l);
            let c;
            if (s.durations[d] === void 0) {
                const u = r();
                s.durations[d] = u.valueOf(),
                    c = u
            } else
                c = s.durations[d];
            return c
        }
        clear() {
            this._cache = {}
        }
    }
    function Be(t, n) {
        this.argumentsHelper = n,
            this.$gantt = t,
            this._workingUnitsCache = typeof Map < "u" ? new Ji : new Ki,
            this._largeUnitsCache = new Xi(this),
            this._dateDurationCache = new Zi,
            this._worktime = null,
            this._cached_timestamps = {},
            this._cached_timestamps_count = 0
    }
    Be.prototype = {
        units: ["year", "month", "week", "day", "hour", "minute"],
        _clearCaches: function() {
            this._workingUnitsCache.clear(),
                this._largeUnitsCache.clear(),
                this._dateDurationCache.clear()
        },
        _getUnitOrder: function(t) {
            for (var n = 0, e = this.units.length; n < e; n++)
                if (this.units[n] == t)
                    return n
        },
        _resetTimestampCache: function() {
            this._cached_timestamps = {},
                this._cached_timestamps_count = 0
        },
        _timestamp: function(t) {
            this._cached_timestamps_count > 1e6 && this._resetTimestampCache();
            var n = null;
            if (t.day || t.day === 0)
                n = t.day;
            else if (t.date) {
                var e = String(t.date.valueOf());
                this._cached_timestamps[e] ? n = this._cached_timestamps[e] : (n = Date.UTC(t.date.getFullYear(), t.date.getMonth(), t.date.getDate()),
                    this._cached_timestamps[e] = n,
                    this._cached_timestamps_count++)
            }
            return n
        },
        _checkIfWorkingUnit: function(t, n) {
            if (!this["_is_work_" + n]) {
                const e = this.$gantt.date[`${n}_start`](new Date(t))
                    , i = this.$gantt.date.add(e, 1, n);
                return this.hasDuration(e, i)
            }
            return this["_is_work_" + n](t)
        },
        _is_work_day: function(t) {
            var n = this._getWorkHours(t);
            return !!Array.isArray(n) && n.length > 0
        },
        _is_work_hour: function(t) {
            for (var n = this._getWorkHours(t), e = t.getHours(), i = 0; i < n.length; i++)
                if (e >= n[i].startHour && e < n[i].endHour)
                    return !0;
            return !1
        },
        _getTimeOfDayStamp: function(t, n) {
            var e = t.getHours();
            return t.getHours() || t.getMinutes() || !n || (e = 24),
            60 * e * 60 + 60 * t.getMinutes()
        },
        _is_work_minute: function(t) {
            for (var n = this._getWorkHours(t), e = this._getTimeOfDayStamp(t), i = 0; i < n.length; i++)
                if (e >= n[i].start && e < n[i].end)
                    return !0;
            return !1
        },
        _nextDate: function(t, n, e) {
            return this.$gantt.date.add(t, e, n)
        },
        _getWorkUnitsBetweenGeneric: function(t, n, e, i) {
            var a = this.$gantt.date
                , r = new Date(t)
                , s = new Date(n);
            i = i || 1;
            var o, l, d = 0, c = null, u = !1;
            (o = a[e + "_start"](new Date(r))).valueOf() != r.valueOf() && (u = !0);
            var h = !1;
            (l = a[e + "_start"](new Date(n))).valueOf() != n.valueOf() && (h = !0);
            for (var _ = !1; r.valueOf() < s.valueOf(); ) {
                if (_ = (c = this._nextDate(r, e, i)).valueOf() > s.valueOf(),
                    this._isWorkTime(r, e))
                    (u || h && _) && (o = a[e + "_start"](new Date(r)),
                        l = a.add(o, i, e)),
                        u ? (u = !1,
                            c = this._nextDate(o, e, i),
                            d += (l.valueOf() - r.valueOf()) / (l.valueOf() - o.valueOf())) : h && _ ? (h = !1,
                            d += (s.valueOf() - r.valueOf()) / (l.valueOf() - o.valueOf())) : d++;
                else {
                    var f = this._getUnitOrder(e)
                        , y = this.units[f - 1];
                    y && !this._isWorkTime(r, y) && (c = this._getClosestWorkTimeFuture(r, y))
                }
                r = c
            }
            return d
        },
        _getMinutesPerHour: function(t) {
            var n = this._getTimeOfDayStamp(t)
                , e = this._getTimeOfDayStamp(this._nextDate(t, "hour", 1));
            e === 0 && (e = 86400);
            for (var i = this._getWorkHours(t), a = 0; a < i.length; a++) {
                var r = i[a];
                if (n >= r.start && e <= r.end)
                    return 60;
                if (n < r.end && e > r.start)
                    return (Math.min(e, r.end) - Math.max(n, r.start)) / 60
            }
            return 0
        },
        _getMinutesPerDay: function(t) {
            var n = this._getWorkHours(t)
                , e = 0;
            return n.forEach(function(i) {
                e += i.durationMinutes
            }),
                e
        },
        getHoursPerDay: function(t) {
            var n = this._getWorkHours(t)
                , e = 0;
            return n.forEach(function(i) {
                e += i.durationHours
            }),
                e
        },
        _getWorkUnitsForRange: function(t, n, e, i) {
            var a, r = 0, s = new Date(t), o = new Date(n);
            for (a = z(e == "minute" ? this._getMinutesPerDay : this.getHoursPerDay, this); s.valueOf() < o.valueOf(); )
                if (o - s > 27648e5 && s.getDate() === 0) {
                    var l = this._largeUnitsCache.getMinutesPerMonth(s);
                    e == "hour" && (l /= 60),
                        r += l,
                        s = this.$gantt.date.add(s, 1, "month")
                } else {
                    if (o - s > 13824e5) {
                        var d = this.$gantt.date.week_start(new Date(s));
                        if (s.valueOf() === d.valueOf()) {
                            l = this._largeUnitsCache.getMinutesPerWeek(s),
                            e == "hour" && (l /= 60),
                                r += l,
                                s = this.$gantt.date.add(s, 7, "day");
                            continue
                        }
                    }
                    r += a(s),
                        s = this._nextDate(s, "day", 1)
                }
            return r / i
        },
        _getMinutesBetweenSingleDay: function(t, n) {
            for (var e = this._getIntervalTimestamp(t, n), i = this._getWorkHours(t), a = 0, r = 0; r < i.length; r++) {
                var s = i[r];
                if (e.end >= s.start && e.start <= s.end) {
                    var o = Math.max(s.start, e.start)
                        , l = Math.min(s.end, e.end);
                    a += (l - o) / 60,
                        e.start = l
                }
            }
            return Math.floor(a)
        },
        _getMinutesBetween: function(t, n, e, i) {
            var a = new Date(t)
                , r = new Date(n);
            i = i || 1;
            var s = new Date(a)
                , o = this.$gantt.date.add(this.$gantt.date.day_start(new Date(a)), 1, "day");
            if (r.valueOf() <= o.valueOf())
                return this._getMinutesBetweenSingleDay(t, n);
            var l = this.$gantt.date.day_start(new Date(r))
                , d = r
                , c = this._getMinutesBetweenSingleDay(s, o)
                , u = this._getMinutesBetweenSingleDay(l, d);
            return c + this._getWorkUnitsForRange(o, l, e, i) + u
        },
        _getHoursBetween: function(t, n, e, i) {
            var a = new Date(t)
                , r = new Date(n);
            i = i || 1;
            var s = new Date(a)
                , o = this.$gantt.date.add(this.$gantt.date.day_start(new Date(a)), 1, "day");
            if (r.valueOf() <= o.valueOf())
                return Math.round(this._getMinutesBetweenSingleDay(t, n) / 60);
            var l = this.$gantt.date.day_start(new Date(r))
                , d = r
                , c = this._getMinutesBetweenSingleDay(s, o, e, i) / 60
                , u = this._getMinutesBetweenSingleDay(l, d, e, i) / 60
                , h = c + this._getWorkUnitsForRange(o, l, e, i) + u;
            return Math.round(h)
        },
        getConfig: function() {
            return this._worktime
        },
        _setConfig: function(t) {
            this._worktime = t,
                this._parseSettings(),
                this._clearCaches()
        },
        _parseSettings: function() {
            var t = this.getConfig();
            for (var n in t.parsed = {
                dates: {},
                hours: null,
                haveCustomWeeks: !1,
                customWeeks: {},
                customWeeksRangeStart: null,
                customWeeksRangeEnd: null,
                customWeeksBoundaries: []
            },
                t.parsed.hours = this._parseHours(t.hours),
                t.dates)
                t.parsed.dates[n] = this._parseHours(t.dates[n]);
            if (t.customWeeks) {
                var e = null
                    , i = null;
                for (var n in t.customWeeks) {
                    var a = t.customWeeks[n];
                    if (a.from && a.to) {
                        var r = a.from
                            , s = a.to;
                        (!e || e > r.valueOf()) && (e = r.valueOf()),
                        (!i || i < s.valueOf()) && (i = s.valueOf()),
                            t.parsed.customWeeksBoundaries.push({
                                from: r.valueOf(),
                                fromReadable: new Date(r),
                                to: s.valueOf(),
                                toReadable: new Date(s),
                                name: n
                            }),
                            t.parsed.haveCustomWeeks = !0;
                        var o = t.parsed.customWeeks[n] = {
                            from: a.from,
                            to: a.to,
                            hours: this._parseHours(a.hours),
                            dates: {}
                        };
                        if (a.days && !a.dates) {
                            for (a.dates = a.dates || {},
                                     n = 0; n < a.days.length; n++)
                                a.dates[n] = a.days[n],
                                a.days[n]instanceof Array || (a.dates[n] = !!a.days[n]);
                            delete a.days
                        }
                        for (var l in a.dates)
                            o.dates[l] = this._parseHours(a.dates[l])
                    }
                }
                t.parsed.customWeeksRangeStart = e,
                    t.parsed.customWeeksRangeEnd = i
            }
        },
        _tryChangeCalendarSettings: function(t) {
            var n = JSON.stringify(this.getConfig());
            return t(),
            !!this.hasWorkTime() || (this._setConfig(JSON.parse(n)),
                this._clearCaches(),
                !1)
        },
        _arraysEqual: function(t, n) {
            if (t === n)
                return !0;
            if (!t || !n || t.length != n.length)
                return !1;
            for (var e = 0; e < t.length; ++e)
                if (t[e] !== n[e])
                    return !1;
            return !0
        },
        _compareSettings: function(t, n) {
            if (!this._arraysEqual(t.hours, n.hours))
                return !1;
            var e = Object.keys(t.dates)
                , i = Object.keys(n.dates);
            if (e.sort(),
                i.sort(),
                !this._arraysEqual(e, i))
                return !1;
            for (var a = 0; a < e.length; a++) {
                var r = e[a]
                    , s = t.dates[r]
                    , o = t.dates[r];
                if (s !== o && !(Array.isArray(s) && Array.isArray(o) && this._arraysEqual(s, o)))
                    return !1
            }
            return !0
        },
        equals: function(t) {
            if (!(t instanceof Be))
                return !1;
            var n = this.getConfig()
                , e = t.getConfig();
            if (!this._compareSettings(n, e))
                return !1;
            if (n.parsed.haveCustomWeeks && e.parsed.haveCustomWeeks) {
                if (n.parsed.customWeeksBoundaries.length != e.parsed.customWeeksBoundaries.length)
                    return !1;
                for (var i in n.parsed.customWeeks) {
                    var a = n.parsed.customWeeks[i]
                        , r = e.parsed.customWeeks[i];
                    if (!r || !this._compareSettings(a, r))
                        return !1
                }
            } else if (n.parse.haveCustomWeeks !== e.parsed.haveCustomWeeks)
                return !1;
            return !0
        },
        getWorkHours: function() {
            var t = this.argumentsHelper.getWorkHoursArguments.apply(this.argumentsHelper, arguments);
            return this._getWorkHours(t.date, !1)
        },
        _getWorkHours: function(t, n) {
            var e = this.getConfig();
            if (n !== !1 && (e = e.parsed),
                !t)
                return e.hours;
            var i = this._timestamp({
                date: t
            });
            if (e.haveCustomWeeks && e.customWeeksRangeStart <= i && e.customWeeksRangeEnd > i) {
                for (var a = 0; a < e.customWeeksBoundaries.length; a++)
                    if (e.customWeeksBoundaries[a].from <= i && e.customWeeksBoundaries[a].to > i) {
                        e = e.customWeeks[e.customWeeksBoundaries[a].name];
                        break
                    }
            }
            var r = !0;
            return e.dates[i] !== void 0 ? r = e.dates[i] : e.dates[t.getDay()] !== void 0 && (r = e.dates[t.getDay()]),
                r === !0 ? e.hours : r || []
        },
        _getIntervalTimestamp: function(t, n) {
            var e = {
                start: 0,
                end: 0
            };
            e.start = 60 * t.getHours() * 60 + 60 * t.getMinutes() + t.getSeconds();
            var i = n.getHours();
            return !i && !n.getMinutes() && !n.getSeconds() && t.valueOf() < n.valueOf() && (i = 24),
                e.end = 60 * i * 60 + 60 * n.getMinutes() + n.getSeconds(),
                e
        },
        _parseHours: function(t) {
            if (Array.isArray(t)) {
                var n = [];
                t.forEach(function(o) {
                    typeof o == "number" ? n.push(60 * o * 60) : typeof o == "string" && o.split("-").map(function(l) {
                        return l.trim()
                    }).forEach(function(l) {
                        var d = l.split(":").map(function(u) {
                            return u.trim()
                        })
                            , c = parseInt(60 * d[0] * 60);
                        d[1] && (c += parseInt(60 * d[1])),
                        d[2] && (c += parseInt(d[2])),
                            n.push(c)
                    })
                });
                for (var e = [], i = 0; i < n.length; i += 2) {
                    var a = n[i]
                        , r = n[i + 1]
                        , s = r - a;
                    e.push({
                        start: a,
                        end: r,
                        startHour: Math.floor(a / 3600),
                        startMinute: Math.floor(a / 60),
                        endHour: Math.ceil(r / 3600),
                        endMinute: Math.ceil(r / 60),
                        durationSeconds: s,
                        durationMinutes: s / 60,
                        durationHours: s / 3600
                    })
                }
                return e
            }
            return t
        },
        setWorkTime: function(t) {
            return this._tryChangeCalendarSettings(z(function() {
                var n = t.hours === void 0 || t.hours
                    , e = this._timestamp(t)
                    , i = this.getConfig();
                if (e !== null ? i.dates[e] = n : t.customWeeks || (i.hours = n),
                    t.customWeeks) {
                    if (i.customWeeks || (i.customWeeks = {}),
                    typeof t.customWeeks == "string")
                        e !== null ? i.customWeeks[t.customWeeks].dates[e] = n : t.customWeeks || (i.customWeeks[t.customWeeks].hours = n);
                    else if (typeof t.customWeeks == "object" && t.customWeeks.constructor === Object)
                        for (var a in t.customWeeks)
                            i.customWeeks[a] = t.customWeeks[a]
                }
                this._parseSettings(),
                    this._clearCaches()
            }, this))
        },
        unsetWorkTime: function(t) {
            return this._tryChangeCalendarSettings(z(function() {
                if (t) {
                    var n = this._timestamp(t);
                    n !== null && delete this.getConfig().dates[n]
                } else
                    this.reset_calendar();
                this._parseSettings(),
                    this._clearCaches()
            }, this))
        },
        _isWorkTime: function(t, n) {
            var e, i = -1;
            return e = String(t.valueOf()),
            (i = this._workingUnitsCache.getItem(n, e, t)) == -1 && (i = this._checkIfWorkingUnit(t, n),
                this._workingUnitsCache.setItem(n, e, i, t)),
                i
        },
        isWorkTime: function() {
            var t = this.argumentsHelper.isWorkTimeArguments.apply(this.argumentsHelper, arguments);
            return this._isWorkTime(t.date, t.unit)
        },
        calculateDuration: function() {
            var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments);
            if (!t.unit)
                return !1;
            var n = this;
            return this._dateDurationCache.getDuration(t.start_date, t.end_date, t.unit, t.step, function() {
                return n._calculateDuration(t.start_date, t.end_date, t.unit, t.step)
            })
        },
        _calculateDuration: function(t, n, e, i) {
            var a = 0
                , r = 1;
            if (t.valueOf() > n.valueOf()) {
                var s = n;
                n = t,
                    t = s,
                    r = -1
            }
            return a = e == "hour" && i == 1 ? this._getHoursBetween(t, n, e, i) : e == "minute" && i == 1 ? this._getMinutesBetween(t, n, e, i) : this._getWorkUnitsBetweenGeneric(t, n, e, i),
            r * Math.round(a)
        },
        hasDuration: function() {
            var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments)
                , n = t.start_date
                , e = t.end_date
                , i = t.unit
                , a = t.step;
            if (!i)
                return !1;
            var r = new Date(n)
                , s = new Date(e);
            for (a = a || 1; r.valueOf() < s.valueOf(); ) {
                if (this._isWorkTime(r, i))
                    return !0;
                r = this._nextDate(r, i, a)
            }
            return !1
        },
        calculateEndDate: function() {
            var t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments)
                , n = t.start_date
                , e = t.duration
                , i = t.unit
                , a = t.step;
            if (!i)
                return !1;
            var r = t.duration >= 0 ? 1 : -1;
            e = Math.abs(1 * e);
            var s = this;
            return this._dateDurationCache.getEndDate(n, e, i, a * r, function() {
                return s._calculateEndDate(n, e, i, a * r)
            })
        },
        _calculateEndDate: function(t, n, e, i) {
            return !!e && (i == 1 && e == "minute" ? this._calculateMinuteEndDate(t, n, i) : i == -1 && e == "minute" ? this._subtractMinuteDate(t, n, i) : i == 1 && e == "hour" ? this._calculateHourEndDate(t, n, i) : this._addInterval(t, n, e, i, null).end)
        },
        _addInterval: function(t, n, e, i, a) {
            for (var r = 0, s = t, o = !1; r < n && (!a || !a(s)); ) {
                var l = this._nextDate(s, e, i);
                e == "day" && (o = o || !s.getHours() && l.getHours()) && (l.setHours(0),
                l.getHours() || (o = !1));
                var d = new Date(l.valueOf() + 1);
                i > 0 && (d = new Date(l.valueOf() - 1)),
                this._isWorkTime(d, e) && !o && r++,
                    s = l
            }
            return {
                end: s,
                start: t,
                added: r
            }
        },
        _addHoursUntilDayEnd: function(t, n) {
            for (var e = this.$gantt.date.add(this.$gantt.date.day_start(new Date(t)), 1, "day"), i = 0, a = n, r = this._getIntervalTimestamp(t, e), s = this._getWorkHours(t), o = 0; o < s.length && i < n; o++) {
                var l = s[o];
                if (r.end >= l.start && r.start <= l.end) {
                    var d = Math.max(l.start, r.start)
                        , c = Math.min(l.end, r.end)
                        , u = (c - d) / 3600;
                    u > a && (u = a,
                        c = d + 60 * a * 60);
                    var h = Math.round((c - d) / 3600);
                    i += h,
                        a -= h,
                        r.start = c
                }
            }
            var _ = e;
            return i === n && (_ = new Date(t.getFullYear(),t.getMonth(),t.getDate(),0,0,r.start)),
                {
                    added: i,
                    end: _
                }
        },
        _calculateHourEndDate: function(t, n, e) {
            var i = new Date(t)
                , a = 0;
            e = e || 1,
                n = Math.abs(1 * n);
            var r = this._addHoursUntilDayEnd(i, n);
            if (a = r.added,
                i = r.end,
                d = n - a) {
                for (var s = i; a < n; ) {
                    var o = this._nextDate(s, "day", e);
                    o.setHours(0),
                        o.setMinutes(0),
                        o.setSeconds(0);
                    var l = 0;
                    if (a + (l = e > 0 ? this.getHoursPerDay(new Date(o.valueOf() - 1)) : this.getHoursPerDay(new Date(o.valueOf() + 1))) >= n)
                        break;
                    a += l,
                        s = o
                }
                i = s
            }
            if (a < n) {
                var d = n - a;
                i = (r = this._addHoursUntilDayEnd(i, d)).end
            }
            return i
        },
        _addMinutesUntilHourEnd: function(t, n) {
            if (t.getMinutes() === 0)
                return {
                    added: 0,
                    end: new Date(t)
                };
            for (var e = this.$gantt.date.add(this.$gantt.date.hour_start(new Date(t)), 1, "hour"), i = 0, a = n, r = this._getIntervalTimestamp(t, e), s = this._getWorkHours(t), o = 0; o < s.length && i < n; o++) {
                var l = s[o];
                if (r.end >= l.start && r.start <= l.end) {
                    var d = Math.max(l.start, r.start)
                        , c = Math.min(l.end, r.end)
                        , u = (c - d) / 60;
                    u > a && (u = a,
                        c = d + 60 * a);
                    var h = Math.round((c - d) / 60);
                    a -= h,
                        i += h,
                        r.start = c
                }
            }
            var _ = e;
            return i === n && (_ = new Date(t.getFullYear(),t.getMonth(),t.getDate(),0,0,r.start)),
                {
                    added: i,
                    end: _
                }
        },
        _subtractMinutesUntilHourStart: function(t, n) {
            for (var e = this.$gantt.date.hour_start(new Date(t)), i = 0, a = n, r = 60 * e.getHours() * 60 + 60 * e.getMinutes() + e.getSeconds(), s = 60 * t.getHours() * 60 + 60 * t.getMinutes() + t.getSeconds(), o = this._getWorkHours(t), l = o.length - 1; l >= 0 && i < n; l--) {
                var d = o[l];
                if (s > d.start && r <= d.end) {
                    var c = Math.min(s, d.end)
                        , u = Math.max(r, d.start)
                        , h = (c - u) / 60;
                    h > a && (h = a,
                        u = c - 60 * a);
                    var _ = Math.abs(Math.round((c - u) / 60));
                    a -= _,
                        i += _,
                        s = u
                }
            }
            var f = e;
            return i === n && (f = new Date(t.getFullYear(),t.getMonth(),t.getDate(),0,0,s)),
                {
                    added: i,
                    end: f
                }
        },
        _subtractMinuteDate: function(t, n, e) {
            var i = this.getClosestWorkTime({
                date: t,
                dir: "past",
                unit: "minute"
            })
                , a = 0;
            e = e || -1,
                n = Math.abs(1 * n),
                n = Math.round(n);
            const r = this._isMinutePrecision(i);
            let s = this._subtractMinutesUntilHourStart(i, n);
            a += s.added,
                i = s.end;
            for (var o = 0, l = [], d = 0; a < n; ) {
                var c = this.$gantt.date.day_start(new Date(i))
                    , u = !1;
                i.valueOf() === c.valueOf() && (c = this.$gantt.date.add(c, -1, "day"),
                    u = !0);
                var h = new Date(c.getFullYear(),c.getMonth(),c.getDate(),23,59,59,999).valueOf();
                h !== o && (l = this._getWorkHours(c),
                    d = this._getMinutesPerDay(c),
                    o = h);
                var _ = n - a
                    , f = this._getTimeOfDayStamp(i, u);
                if (l.length && d)
                    if (l[l.length - 1].end <= f && _ > d)
                        a += d,
                            i = this.$gantt.date.add(i, -1, "day");
                    else {
                        for (var y = !1, v = null, b = null, g = l.length - 1; g >= 0; g--)
                            if (l[g].start < f - 1 && l[g].end >= f - 1) {
                                y = !0,
                                    v = l[g],
                                    b = l[g - 1];
                                break
                            }
                        if (y)
                            if (f === v.end && _ >= v.durationMinutes)
                                a += v.durationMinutes,
                                    i = this.$gantt.date.add(i, -v.durationMinutes, "minute");
                            else if (!r && _ <= f / 60 - v.startMinute)
                                a += _,
                                    i = this.$gantt.date.add(i, -_, "minute");
                            else if (r)
                                _ <= f / 60 - v.startMinute ? (a += _,
                                    i = this.$gantt.date.add(i, -_, "minute")) : (a += f / 60 - v.startMinute,
                                    i = b ? new Date(i.getFullYear(),i.getMonth(),i.getDate(),0,0,b.end) : this.$gantt.date.day_start(i));
                            else {
                                var m = this._getMinutesPerHour(i);
                                m <= _ ? (a += m,
                                    i = this._nextDate(i, "hour", e)) : (s = this._subtractMinutesUntilHourStart(i, _),
                                    a += s.added,
                                    i = s.end)
                            }
                        else if (i.getHours() === 0 && i.getMinutes() === 0 && i.getSeconds() === 0) {
                            if ((p = this._getClosestWorkTimePast(i, "hour")).valueOf() === i.valueOf()) {
                                var p = this.$gantt.date.add(i, -1, "day")
                                    , k = this._getWorkHours(p);
                                if (k.length) {
                                    var w = k[k.length - 1];
                                    p.setSeconds(w.durationSeconds)
                                }
                            }
                            i = p
                        } else
                            i = this._getClosestWorkTimePast(new Date(i - 1), "hour")
                    }
                else
                    i = this.$gantt.date.add(i, -1, "day")
            }
            if (a < n) {
                var x = n - a;
                s = this._subtractMinutesUntilHourStart(i, x),
                    a += s.added,
                    i = s.end
            }
            return i
        },
        _calculateMinuteEndDate: function(t, n, e) {
            var i = new Date(t)
                , a = 0;
            e = e || 1,
                n = Math.abs(1 * n),
                n = Math.round(n);
            var r = this._addMinutesUntilHourEnd(i, n);
            a += r.added,
                i = r.end;
            for (var s = 0, o = [], l = 0, d = this._isMinutePrecision(i); a < n; ) {
                var c = this.$gantt.date.day_start(new Date(i)).valueOf();
                c !== s && (o = this._getWorkHours(i),
                    l = this._getMinutesPerDay(i),
                    s = c);
                var u = n - a
                    , h = this._getTimeOfDayStamp(i);
                if (o.length && l)
                    if (o[0].start >= h && u >= l) {
                        if (a += l,
                        u == l) {
                            i = new Date(i.getFullYear(),i.getMonth(),i.getDate(),0,0,o[o.length - 1].end);
                            break
                        }
                        i = this.$gantt.date.add(i, 1, "day"),
                            i = this.$gantt.date.day_start(i)
                    } else {
                        for (var _ = !1, f = null, y = 0; y < o.length; y++)
                            if (o[y].start <= h && o[y].end > h) {
                                _ = !0,
                                    f = o[y];
                                break
                            }
                        if (_)
                            if (h === f.start && u >= f.durationMinutes)
                                a += f.durationMinutes,
                                    i = this.$gantt.date.add(i, f.durationMinutes, "minute");
                            else if (u <= f.endMinute - h / 60)
                                a += u,
                                    i = this.$gantt.date.add(i, u, "minute");
                            else {
                                var v = this._getMinutesPerHour(i);
                                v <= u ? (a += v,
                                    i = d ? this.$gantt.date.add(i, v, "minute") : this._nextDate(i, "hour", e)) : (a += (r = this._addMinutesUntilHourEnd(i, u)).added,
                                    i = r.end)
                            }
                        else
                            i = this._getClosestWorkTimeFuture(i, "hour")
                    }
                else
                    i = this.$gantt.date.add(this.$gantt.date.day_start(i), 1, "day")
            }
            if (a < n) {
                var b = n - a;
                a += (r = this._addMinutesUntilHourEnd(i, b)).added,
                    i = r.end
            }
            return i
        },
        getClosestWorkTime: function() {
            var t = this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments);
            return this._getClosestWorkTime(t.date, t.unit, t.dir)
        },
        _getClosestWorkTime: function(t, n, e) {
            var i = new Date(t);
            if (this._isWorkTime(i, n))
                return i;
            if (i = this.$gantt.date[n + "_start"](i),
            e != "any" && e)
                i = e == "past" ? this._getClosestWorkTimePast(i, n) : this._getClosestWorkTimeFuture(i, n);
            else {
                var a = this._getClosestWorkTimeFuture(i, n)
                    , r = this._getClosestWorkTimePast(i, n);
                i = Math.abs(a - t) <= Math.abs(t - r) ? a : r
            }
            return i
        },
        _getClosestWorkTimeFuture: function(t, n) {
            return this._getClosestWorkTimeGeneric(t, n, 1)
        },
        _getClosestWorkTimePast: function(t, n) {
            var e = this._getClosestWorkTimeGeneric(t, n, -1);
            return this.$gantt.date.add(e, 1, n)
        },
        _findClosestTimeInDay: function(t, n, e) {
            var i = new Date(t)
                , a = null
                , r = !1;
            this._getWorkHours(i).length || (i = this._getClosestWorkTime(i, "day", n < 0 ? "past" : "future"),
            n < 0 && (i = new Date(i.valueOf() - 1),
                r = !0),
                e = this._getWorkHours(i));
            var s = this._getTimeOfDayStamp(i);
            if (r && (s = this._getTimeOfDayStamp(new Date(i.valueOf() + 1), r)),
            n > 0) {
                for (var o = 0; o < e.length; o++)
                    if (e[o].start >= s) {
                        a = new Date(i.getFullYear(),i.getMonth(),i.getDate(),0,0,e[o].start);
                        break
                    }
            } else
                for (o = e.length - 1; o >= 0; o--) {
                    if (e[o].end <= s) {
                        a = new Date(i.getFullYear(),i.getMonth(),i.getDate(),0,0,e[o].end);
                        break
                    }
                    if (e[o].end > s && e[o].start <= s) {
                        a = new Date(i.getFullYear(),i.getMonth(),i.getDate(),0,0,s);
                        break
                    }
                }
            return a
        },
        _getClosestWorkMinute: function(t, n, e) {
            var i = new Date(t)
                , a = this._getWorkHours(i)
                , r = this._findClosestTimeInDay(i, e, a);
            return r || (e > 0 ? (i = this.calculateEndDate(i, e, n),
                i = this.$gantt.date.day_start(i)) : (i = this.calculateEndDate(i, e, "day"),
                i = this.$gantt.date.day_start(i),
                i = this.$gantt.date.add(i, 1, "day"),
                i = new Date(i.valueOf() - 1)),
                a = this._getWorkHours(i),
                r = this._findClosestTimeInDay(i, e, a)),
            e < 0 && (r = this.$gantt.date.add(r, -1, n)),
                r
        },
        _getClosestWorkTimeGeneric: function(t, n, e) {
            if (n === "hour" || n === "minute")
                return this._getClosestWorkMinute(t, n, e);
            for (var i = this._getUnitOrder(n), a = this.units[i - 1], r = t, s = 0; !this._isWorkTime(r, n) && (!a || this._isWorkTime(r, a) || (r = e > 0 ? this._getClosestWorkTimeFuture(r, a) : this._getClosestWorkTimePast(r, a),
                !this._isWorkTime(r, n))); ) {
                if (++s > 3e3)
                    return this.$gantt.assert(!1, "Invalid working time check"),
                        !1;
                var o = r.getTimezoneOffset();
                r = this.$gantt.date.add(r, e, n),
                    r = this.$gantt._correct_dst_change(r, o, e, n),
                this.$gantt.date[n + "_start"] && (r = this.$gantt.date[n + "_start"](r))
            }
            return r
        },
        hasWorkTime: function() {
            var t = this.getConfig()
                , n = t.dates;
            for (var e in t.dates)
                ;
            var i = this._checkWorkHours(t.hours)
                , a = !1;
            return [0, 1, 2, 3, 4, 5, 6].forEach((function(r) {
                    if (!a) {
                        var s = n[r];
                        s === !0 ? a = i : Array.isArray(s) && (a = this._checkWorkHours(s))
                    }
                }
            ).bind(this)),
                a
        },
        _checkWorkHours: function(t) {
            if (t.length === 0)
                return !1;
            for (var n = !1, e = 0; e < t.length; e += 2)
                t[e] !== t[e + 1] && (n = !0);
            return n
        },
        _isMinutePrecision: function(t) {
            let n = !1;
            return this._getWorkHours(t).forEach(function(e) {
                (e.startMinute % 60 || e.endMinute % 60) && (n = !0)
            }),
                n
        }
    };
    const Wt = {
        isLegacyResourceCalendarFormat: function(t) {
            if (!t)
                return !1;
            for (var n in t)
                if (t[n] && typeof t[n] == "object")
                    return !0;
            return !1
        },
        getResourceProperty: function(t) {
            var n = t.resource_calendars
                , e = t.resource_property;
            if (this.isLegacyResourceCalendarFormat(n))
                for (var i in t) {
                    e = i;
                    break
                }
            return e
        },
        getCalendarIdFromLegacyConfig: function(t, n) {
            if (n)
                for (var e in n) {
                    var i = n[e];
                    if (t[e]) {
                        var a = i[t[e]];
                        if (a)
                            return a
                    }
                }
            return null
        }
    }
        , Qi = (ie = {},
        {
            getCalendarIdFromMultipleResources: function(t, n) {
                var e = function(a) {
                    return a.map(function(r) {
                        return r && r.resource_id ? r.resource_id : r
                    }).sort().join("-")
                }(t);
                if (t.length) {
                    if (t.length === 1)
                        return n.getResourceCalendar(e).id;
                    if (ie[e])
                        return ie[e].id;
                    var i = function(a, r) {
                        return r.mergeCalendars(a.map(function(s) {
                            var o = s && s.resource_id ? s.resource_id : s;
                            return r.getResourceCalendar(o)
                        }))
                    }(t, n);
                    return ie[e] = i,
                        n.addCalendar(i)
                }
                return null
            }
        });
    var ie;
    function On(t) {
        this.$gantt = t,
            this._calendars = {},
            this._legacyConfig = void 0,
            this.$gantt.attachEvent("onGanttReady", (function() {
                    this.$gantt.config.resource_calendars && (this._isLegacyConfig = Wt.isLegacyResourceCalendarFormat(this.$gantt.config.resource_calendars))
                }
            ).bind(this)),
            this.$gantt.attachEvent("onBeforeGanttReady", (function() {
                    this.createDefaultCalendars()
                }
            ).bind(this)),
            this.$gantt.attachEvent("onBeforeGanttRender", (function() {
                    this.createDefaultCalendars()
                }
            ).bind(this))
    }
    function ze(t, n) {
        this.argumentsHelper = n,
            this.$gantt = t
    }
    function Bn(t) {
        this.$gantt = t.$gantt,
            this.argumentsHelper = Rn(this.$gantt),
            this.calendarManager = t,
            this.$disabledCalendar = new ze(this.$gantt,this.argumentsHelper)
    }
    On.prototype = {
        _calendars: {},
        _convertWorkTimeSettings: function(t) {
            var n = t.days;
            if (n && !t.dates) {
                t.dates = t.dates || {};
                for (var e = 0; e < n.length; e++)
                    t.dates[e] = n[e],
                    n[e]instanceof Array || (t.dates[e] = !!n[e])
            }
            return delete t.days,
                t
        },
        mergeCalendars: function() {
            var t = []
                , n = arguments;
            if (Array.isArray(n[0]))
                t = n[0].slice();
            else
                for (var e = 0; e < arguments.length; e++)
                    t.push(arguments[e]);
            var i, a = new Hn;
            return t.forEach((function(r) {
                    i = i ? this._createCalendarFromConfig(a.merge(i, r)) : r
                }
            ).bind(this)),
                this.createCalendar(i)
        },
        _createCalendarFromConfig: function(t) {
            var n = new Be(this.$gantt,Rn(this.$gantt));
            n.id = String(ut());
            var e = this._convertWorkTimeSettings(t);
            if (e.customWeeks)
                for (var i in e.customWeeks)
                    e.customWeeks[i] = this._convertWorkTimeSettings(e.customWeeks[i]);
            return n._setConfig(e),
                n
        },
        createCalendar: function(t) {
            var n;
            return t || (t = {}),
                O(n = t.getConfig ? X(t.getConfig()) : t.worktime ? X(t.worktime) : X(t), X(this.defaults.fulltime.worktime)),
                this._createCalendarFromConfig(n)
        },
        getCalendar: function(t) {
            t = t || "global";
            var n = this._calendars[t];
            return n || (this.createDefaultCalendars(),
                n = this._calendars[t]),
                n
        },
        getCalendars: function() {
            var t = [];
            for (var n in this._calendars)
                t.push(this.getCalendar(n));
            return t
        },
        _getOwnCalendar: function(t) {
            var n = this.$gantt.config;
            if (t[n.calendar_property])
                return this.getCalendar(t[n.calendar_property]);
            if (n.resource_calendars) {
                var e;
                if (e = this._legacyConfig === !1 ? n.resource_property : Wt.getResourceProperty(n),
                Array.isArray(t[e]) && t[e].length)
                    n.dynamic_resource_calendars ? i = Qi.getCalendarIdFromMultipleResources(t[e], this) : a = this.getResourceCalendar(t[e]);
                else if (this._legacyConfig === void 0 && (this._legacyConfig = Wt.isLegacyResourceCalendarFormat(n.resource_calendars)),
                    this._legacyConfig)
                    var i = Wt.getCalendarIdFromLegacyConfig(t, n.resource_calendars);
                else if (e && t[e] && n.resource_calendars[t[e]])
                    var a = this.getResourceCalendar(t[e]);
                if (i && (a = this.getCalendar(i)),
                    a)
                    return a
            }
            return null
        },
        getResourceCalendar: function(t) {
            if (t == null)
                return this.getCalendar();
            var n = null;
            n = typeof t == "number" || typeof t == "string" ? t : t.id || t.key;
            var e = this.$gantt.config
                , i = e.resource_calendars
                , a = null;
            if (Array.isArray(t) && t.length === 1 && (n = typeof t[0] == "object" ? t[0].resource_id : t[0]),
                i) {
                if (this._legacyConfig === void 0 && (this._legacyConfig = Wt.isLegacyResourceCalendarFormat(e.resource_calendars)),
                    this._legacyConfig) {
                    for (var r in i)
                        if (i[r][n]) {
                            a = i[r][n];
                            break
                        }
                } else
                    a = i[n];
                if (a)
                    return this.getCalendar(a)
            }
            return this.getCalendar()
        },
        getTaskCalendar: function(t) {
            var n, e = this.$gantt;
            if (t == null)
                return this.getCalendar();
            if (!(n = typeof t != "number" && typeof t != "string" || !e.isTaskExists(t) ? t : e.getTask(t)))
                return this.getCalendar();
            var i = this._getOwnCalendar(n)
                , a = !!e.getState().group_mode;
            if (!i && e.config.inherit_calendar && e.isTaskExists(n.parent)) {
                for (var r = n; e.isTaskExists(r.parent) && (r = e.getTask(r.parent),
                !e.isSummaryTask(r) || !(i = this._getOwnCalendar(r))); )
                    ;
                a && !i && t.$effective_calendar && (i = this.getCalendar(t.$effective_calendar))
            }
            return i || this.getCalendar()
        },
        addCalendar: function(t) {
            if (!this.isCalendar(t)) {
                var n = t.id;
                (t = this.createCalendar(t)).id = n
            }
            if (t._tryChangeCalendarSettings(function() {})) {
                var e = this.$gantt.config;
                return t.id = t.id || ut(),
                    this._calendars[t.id] = t,
                e.worktimes || (e.worktimes = {}),
                    e.worktimes[t.id] = t.getConfig(),
                    t.id
            }
            return this.$gantt.callEvent("onCalendarError", [{
                message: "Invalid calendar settings, no worktime available"
            }, t]),
                null
        },
        deleteCalendar: function(t) {
            var n = this.$gantt.config;
            return !!t && !!this._calendars[t] && (delete this._calendars[t],
            n.worktimes && n.worktimes[t] && delete n.worktimes[t],
                !0)
        },
        restoreConfigCalendars: function(t) {
            for (var n in t)
                if (!this._calendars[n]) {
                    var e = t[n]
                        , i = this.createCalendar(e);
                    i.id = n,
                        this.addCalendar(i)
                }
        },
        defaults: {
            global: {
                id: "global",
                worktime: {
                    hours: [8, 12, 13, 17],
                    days: [0, 1, 1, 1, 1, 1, 0]
                }
            },
            fulltime: {
                id: "fulltime",
                worktime: {
                    hours: [0, 24],
                    days: [1, 1, 1, 1, 1, 1, 1]
                }
            }
        },
        createDefaultCalendars: function() {
            var t = this.$gantt.config;
            this.restoreConfigCalendars(this.defaults),
                this.restoreConfigCalendars(t.worktimes)
        },
        isCalendar: function(t) {
            return [t.isWorkTime, t.setWorkTime, t.getWorkHours, t.unsetWorkTime, t.getClosestWorkTime, t.calculateDuration, t.hasDuration, t.calculateEndDate].every(function(n) {
                return n instanceof Function
            })
        }
    },
        ze.prototype = {
            getWorkHours: function() {
                return [0, 24]
            },
            setWorkTime: function() {
                return !0
            },
            unsetWorkTime: function() {
                return !0
            },
            isWorkTime: function() {
                return !0
            },
            getClosestWorkTime: function(t) {
                return this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments).date
            },
            calculateDuration: function() {
                var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments)
                    , n = t.start_date
                    , e = t.end_date
                    , i = t.unit
                    , a = t.step;
                return this._calculateDuration(n, e, i, a)
            },
            _calculateDuration: function(t, n, e, i) {
                var a = this.$gantt.date
                    , r = {
                    week: 6048e5,
                    day: 864e5,
                    hour: 36e5,
                    minute: 6e4
                }
                    , s = 0;
                if (r[e])
                    s = Math.round((n - t) / (i * r[e]));
                else {
                    for (var o = new Date(t), l = new Date(n); o.valueOf() < l.valueOf(); )
                        s += 1,
                            o = a.add(o, i, e);
                    o.valueOf() != n.valueOf() && (s += (l - o) / (a.add(o, i, e) - o))
                }
                return Math.round(s)
            },
            hasDuration: function() {
                var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments)
                    , n = t.start_date
                    , e = t.end_date;
                return !!t.unit && (n = new Date(n),
                    e = new Date(e),
                n.valueOf() < e.valueOf())
            },
            hasWorkTime: function() {
                return !0
            },
            equals: function(t) {
                return t instanceof ze
            },
            calculateEndDate: function() {
                var t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments)
                    , n = t.start_date
                    , e = t.duration
                    , i = t.unit
                    , a = t.step;
                return this.$gantt.date.add(n, a * e, i)
            }
        },
        Bn.prototype = {
            _getCalendar: function(t) {
                var n;
                if (this.$gantt.config.work_time) {
                    var e = this.calendarManager;
                    t.task ? n = e.getTaskCalendar(t.task) : t.id ? n = e.getTaskCalendar(t) : t.calendar && (n = t.calendar),
                    n || (n = e.getTaskCalendar())
                } else
                    n = this.$disabledCalendar;
                return n
            },
            getWorkHours: function(t) {
                return t = this.argumentsHelper.getWorkHoursArguments.apply(this.argumentsHelper, arguments),
                    this._getCalendar(t).getWorkHours(t.date)
            },
            setWorkTime: function(t, n) {
                return t = this.argumentsHelper.setWorkTimeArguments.apply(this.argumentsHelper, arguments),
                n || (n = this.calendarManager.getCalendar()),
                    n.setWorkTime(t)
            },
            unsetWorkTime: function(t, n) {
                return t = this.argumentsHelper.unsetWorkTimeArguments.apply(this.argumentsHelper, arguments),
                n || (n = this.calendarManager.getCalendar()),
                    n.unsetWorkTime(t)
            },
            isWorkTime: function(t, n, e, i) {
                var a = this.argumentsHelper.isWorkTimeArguments.apply(this.argumentsHelper, arguments);
                return (i = this._getCalendar(a)).isWorkTime(a)
            },
            getClosestWorkTime: function(t) {
                return t = this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments),
                    this._getCalendar(t).getClosestWorkTime(t)
            },
            calculateDuration: function() {
                var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments);
                return this._getCalendar(t).calculateDuration(t)
            },
            hasDuration: function() {
                var t = this.argumentsHelper.hasDurationArguments.apply(this.argumentsHelper, arguments);
                return this._getCalendar(t).hasDuration(t)
            },
            calculateEndDate: function(t) {
                return t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments),
                    this._getCalendar(t).calculateEndDate(t)
            }
        };
    const ta = function(t, n) {
        return {
            getWorkHours: function(e) {
                return n.getWorkHours(e)
            },
            setWorkTime: function(e) {
                return n.setWorkTime(e)
            },
            unsetWorkTime: function(e) {
                n.unsetWorkTime(e)
            },
            isWorkTime: function(e, i, a) {
                return n.isWorkTime(e, i, a)
            },
            getClosestWorkTime: function(e) {
                return n.getClosestWorkTime(e)
            },
            calculateDuration: function(e, i, a) {
                return n.calculateDuration(e, i, a)
            },
            _hasDuration: function(e, i, a) {
                return n.hasDuration(e, i, a)
            },
            calculateEndDate: function(e, i, a, r) {
                return n.calculateEndDate(e, i, a, r)
            },
            mergeCalendars: z(t.mergeCalendars, t),
            createCalendar: z(t.createCalendar, t),
            addCalendar: z(t.addCalendar, t),
            getCalendar: z(t.getCalendar, t),
            getCalendars: z(t.getCalendars, t),
            getResourceCalendar: z(t.getResourceCalendar, t),
            getTaskCalendar: z(t.getTaskCalendar, t),
            deleteCalendar: z(t.deleteCalendar, t)
        }
    };
    function ea(t) {
        t.isUnscheduledTask = function(s) {
            return t.assert(s && s instanceof Object, "Invalid argument <b>task</b>=" + s + " of gantt.isUnscheduledTask. Task object was expected"),
            !!s.unscheduled || !s.start_date
        }
            ,
            t._isAllowedUnscheduledTask = function(s) {
                return !(!s.unscheduled || !t.config.show_unscheduled)
            }
            ,
            t._isTaskInTimelineLimits = function(s) {
                var o = s.start_date ? s.start_date.valueOf() : null
                    , l = s.end_date ? s.end_date.valueOf() : null;
                return !!(o && l && o <= this._max_date.valueOf() && l >= this._min_date.valueOf())
            }
            ,
            t.isTaskVisible = function(s) {
                if (!this.isTaskExists(s))
                    return !1;
                var o = this.getTask(s);
                return !(!this._isAllowedUnscheduledTask(o) && !this._isTaskInTimelineLimits(o)) && this.getGlobalTaskIndex(s) >= 0
            }
            ,
            t._getProjectEnd = function() {
                if (t.config.project_end)
                    return t.config.project_end;
                var s = t.getTaskByTime();
                return (s = s.sort(function(o, l) {
                    return +o.end_date > +l.end_date ? 1 : -1
                })).length ? s[s.length - 1].end_date : null
            }
            ,
            t._getProjectStart = function() {
                if (t.config.project_start)
                    return t.config.project_start;
                if (t.config.start_date)
                    return t.config.start_date;
                if (t.getState().min_date)
                    return t.getState().min_date;
                var s = t.getTaskByTime();
                return (s = s.sort(function(o, l) {
                    return +o.start_date > +l.start_date ? 1 : -1
                })).length ? s[0].start_date : null
            }
        ;
        var n = function(s, o) {
            var l = !!(o && o != t.config.root_id && t.isTaskExists(o)) && t.getTask(o)
                , d = null;
            if (l)
                if (t.config.schedule_from_end)
                    d = t.calculateEndDate({
                        start_date: l.end_date,
                        duration: -t.config.duration_step,
                        task: s
                    });
                else {
                    if (!l.start_date)
                        return n(l, t.getParent(l));
                    d = l.start_date
                }
            else if (t.config.schedule_from_end)
                d = t.calculateEndDate({
                    start_date: t._getProjectEnd(),
                    duration: -t.config.duration_step,
                    task: s
                });
            else {
                const c = t.getTaskByIndex(0)
                    , u = t.config.start_date || t.getState().min_date;
                d = c ? c.start_date ? c.start_date : c.end_date ? t.calculateEndDate({
                    start_date: c.end_date,
                    duration: -t.config.duration_step,
                    task: s
                }) : u : u
            }
            return t.assert(d, "Invalid dates"),
                new Date(d)
        };
        t._set_default_task_timing = function(s) {
            s.start_date = s.start_date || n(s, t.getParent(s)),
                s.duration = s.duration || t.config.duration_step,
                s.end_date = s.end_date || t.calculateEndDate(s)
        }
            ,
            t.createTask = function(s, o, l) {
                if (s = s || {},
                t.defined(s.id) || (s.id = t.uid()),
                s.start_date || (s.start_date = n(s, o)),
                s.text === void 0 && (s.text = t.locale.labels.new_task),
                s.duration === void 0 && (s.duration = 1),
                    this.isTaskExists(o)) {
                    this.setParent(s, o, !0);
                    var d = this.getTask(o);
                    d.$open = !0,
                    this.config.details_on_create || this.callEvent("onAfterParentExpand", [o, d])
                }
                return this.callEvent("onTaskCreated", [s]) ? (this.config.details_on_create ? (t.isTaskExists(s.id) ? t.getTask(s.id).$index != s.$index && (s.start_date && typeof s.start_date == "string" && (s.start_date = this.date.parseDate(s.start_date, "parse_date")),
                s.end_date && typeof s.end_date == "string" && (s.end_date = this.date.parseDate(s.end_date, "parse_date")),
                    this.$data.tasksStore.updateItem(s.id, s)) : (s.$new = !0,
                    this.silent(function() {
                        t.$data.tasksStore.addItem(s, l)
                    })),
                    this.selectTask(s.id),
                    this.refreshData(),
                    this.showLightbox(s.id)) : this.addTask(s, o, l) && (this.showTask(s.id),
                    this.selectTask(s.id)),
                    s.id) : null
            }
            ,
            t._update_flags = function(s, o) {
                var l = t.$data.tasksStore;
                s === void 0 ? (this._lightbox_id = null,
                    l.silent(function() {
                        l.unselect()
                    }),
                this.getSelectedTasks && this._multiselect.reset(),
                this._tasks_dnd && this._tasks_dnd.drag && (this._tasks_dnd.drag.id = null)) : (this._lightbox_id == s && (this._lightbox_id = o),
                l.getSelectedId() == s && l.silent(function() {
                    l.unselect(s),
                        l.select(o)
                }),
                this._tasks_dnd && this._tasks_dnd.drag && this._tasks_dnd.drag.id == s && (this._tasks_dnd.drag.id = o))
            }
        ;
        var e = function(s, o) {
            var l = t.getTaskType(s.type)
                , d = {
                type: l,
                $no_start: !1,
                $no_end: !1,
                scheduled_summary: !1
            };
            return l === t.config.types.project && s.auto_scheduling === !1 && (d.scheduled_summary = !0),
                o || l != s.$rendered_type ? (l == t.config.types.project ? d.$no_end = d.$no_start = !0 : l != t.config.types.milestone && (d.$no_end = !(s.end_date || s.duration),
                    d.$no_start = !s.start_date,
                t._isAllowedUnscheduledTask(s) && (d.$no_end = d.$no_start = !1)),
                    d) : (d.$no_start = s.$no_start,
                    d.$no_end = s.$no_end,
                    d)
        };
        function i(s) {
            s.$effective_calendar = t.getTaskCalendar(s).id,
                s.start_date = t.getClosestWorkTime({
                    dir: "future",
                    date: s.start_date,
                    unit: t.config.duration_unit,
                    task: s
                }),
                s.end_date = t.calculateEndDate(s)
        }
        function a(s, o, l, d) {
            const c = {
                start: "start_date",
                end: "end_date"
            }
                , u = {
                start: "$auto_start_date",
                end: "$auto_end_date"
            };
            let h;
            h = s.type === t.config.types.project && s.auto_scheduling === !1 ? u : c,
            o.$no_start && (s[h.start] = l ? new Date(l) : n(s, this.getParent(s))),
            o.$no_end && (s[h.end] = d ? new Date(d) : this.calculateEndDate({
                start_date: s[h.start],
                duration: this.config.duration_step,
                task: s
            })),
            (o.$no_start || o.$no_end) && this._init_task_timing(s)
        }
        function r(s) {
            var o = null
                , l = null
                , d = s !== void 0 ? s : t.config.root_id
                , c = [];
            return t.eachTask(function(u) {
                const h = t.getTaskType(u.type) == t.config.types.project && u.auto_scheduling === !1;
                t.getTaskType(u.type) == t.config.types.project && !h || t.isUnscheduledTask(u) || (u.rollup && c.push(u.id),
                !u.start_date || u.$no_start && !h || o && !(o > u.start_date.valueOf()) || (o = u.start_date.valueOf()),
                !u.end_date || u.$no_end && !h || l && !(l < u.end_date.valueOf()) || (l = u.end_date.valueOf()))
            }, d),
                {
                    start_date: o ? new Date(o) : null,
                    end_date: l ? new Date(l) : null,
                    rollup: c
                }
        }
        t._init_task_timing = function(s) {
            var o = e(s, !0)
                , l = s.$rendered_type != o.type
                , d = o.type;
            l && (s.$no_start = o.$no_start,
                s.$no_end = o.$no_end,
                s.$rendered_type = o.type),
            l && d != this.config.types.milestone && d == this.config.types.project && (this._set_default_task_timing(s),
                s.$calculate_duration = !1),
            d == this.config.types.milestone && (s.end_date = s.start_date),
            s.start_date && s.end_date && s.$calculate_duration !== !1 && (s.duration = this.calculateDuration(s)),
            s.$calculate_duration || (s.$calculate_duration = !0),
            s.end_date || (s.end_date = s.start_date),
                s.duration = s.duration || 0,
            this.config.min_duration === 0 && s.duration === 0 && (s.$no_end = !1,
            s.type === t.config.types.project && t.hasChild(s.id) && (s.$no_end = !0));
            var c = this.getTaskCalendar(s);
            s.$effective_calendar && s.$effective_calendar !== c.id && (i(s),
            this.config.inherit_calendar && this.isSummaryTask(s) && this.eachTask(function(u) {
                i(u)
            }, s.id)),
                s.$effective_calendar = c.id
        }
            ,
            t.isSummaryTask = function(s) {
                t.assert(s && s instanceof Object, "Invalid argument <b>task</b>=" + s + " of gantt.isSummaryTask. Task object was expected");
                var o = e(s);
                return !(!o.$no_end && !o.$no_start)
            }
            ,
            t.resetProjectDates = function(s) {
                var o = e(s);
                if (o.$no_end || o.$no_start) {
                    var l = r(s.id);
                    a.call(this, s, o, l.start_date, l.end_date),
                        s.$rollup = l.rollup
                }
            }
            ,
            t.getSubtaskDuration = function(s) {
                var o = 0
                    , l = s !== void 0 ? s : t.config.root_id;
                return this.eachTask(function(d) {
                    this.getTaskType(d.type) == t.config.types.project || this.isUnscheduledTask(d) || (o += d.duration)
                }, l),
                    o
            }
            ,
            t.getSubtaskDates = function(s) {
                var o = r(s);
                return {
                    start_date: o.start_date,
                    end_date: o.end_date
                }
            }
            ,
            t._update_parents = function(s, o, l) {
                if (s) {
                    var d = this.getTask(s);
                    d.rollup && (l = !0);
                    var c = this.getParent(d)
                        , u = e(d)
                        , h = !0;
                    if (l || d.start_date && d.end_date && (u.$no_start || u.$no_end)) {
                        const y = d.$auto_start_date ? "$auto_start_date" : "start_date"
                            , v = d.$auto_end_date ? "$auto_end_date" : "end_date";
                        var _ = d[y].valueOf()
                            , f = d[v].valueOf();
                        t.resetProjectDates(d),
                        l || _ != d[y].valueOf() || f != d[v].valueOf() || (h = !1),
                        h && !o && this.refreshTask(d.id, !0),
                        u.scheduled_summary && (h = !0)
                    }
                    h && c && this.isTaskExists(c) && this._update_parents(c, o, l)
                }
            }
            ,
            t.roundDate = function(s) {
                var o = t.getScale();
                nt(s) && (s = {
                    date: s,
                    unit: o ? o.unit : t.config.duration_unit,
                    step: o ? o.step : t.config.duration_step
                });
                var l, d, c, u = s.date, h = s.step, _ = s.unit;
                if (!o)
                    return u;
                if (_ == o.unit && h == o.step && +u >= +o.min_date && +u <= +o.max_date)
                    c = Math.floor(t.columnIndexByDate(u)),
                    o.trace_x[c] || (c -= 1,
                    o.rtl && (c = 0)),
                        d = new Date(o.trace_x[c]),
                        l = t.date.add(d, h, _);
                else {
                    for (c = Math.floor(t.columnIndexByDate(u)),
                             l = t.date[_ + "_start"](new Date(o.min_date)),
                         o.trace_x[c] && (l = t.date[_ + "_start"](o.trace_x[c])); +l < +u; ) {
                        var f = (l = t.date[_ + "_start"](t.date.add(l, h, _))).getTimezoneOffset();
                        l = t._correct_dst_change(l, f, l, _),
                        t.date[_ + "_start"] && (l = t.date[_ + "_start"](l))
                    }
                    d = t.date.add(l, -1 * h, _)
                }
                return s.dir && s.dir == "future" ? l : s.dir && s.dir == "past" || Math.abs(u - d) < Math.abs(l - u) ? d : l
            }
            ,
            t.correctTaskWorkTime = function(s) {
                t.config.work_time && t.config.correct_work_time && (this.isWorkTime(s.start_date, void 0, s) ? this.isWorkTime(new Date(+s.end_date - 1), void 0, s) || (s.end_date = this.calculateEndDate(s)) : (s.start_date = this.getClosestWorkTime({
                    date: s.start_date,
                    dir: "future",
                    task: s
                }),
                    s.end_date = this.calculateEndDate(s)))
            }
            ,
            t.attachEvent("onBeforeTaskUpdate", function(s, o) {
                return t._init_task_timing(o),
                    !0
            }),
            t.attachEvent("onBeforeTaskAdd", function(s, o) {
                return t._init_task_timing(o),
                    !0
            }),
            t.attachEvent("onAfterTaskMove", function(s, o, l) {
                return t._init_task_timing(t.getTask(s)),
                    !0
            })
    }
    function zn(t, n) {
        var e, i = t.config.container_resize_timeout || 20;
        let a = jn(t);
        if (t.config.container_resize_method == "timeout")
            l();
        else
            try {
                t.event(n, "resize", function() {
                    if (t.$scrollbarRepaint)
                        t.$scrollbarRepaint = null;
                    else {
                        let d = jn(t);
                        if (a.x == d.x && a.y == d.y)
                            return;
                        a = d,
                            r()
                    }
                })
            } catch {
                l()
            }
        function r() {
            clearTimeout(e),
                e = setTimeout(function() {
                    t.$destroyed || t.render()
                }, i)
        }
        var s = t.$root.offsetHeight
            , o = t.$root.offsetWidth;
        function l() {
            t.$root.offsetHeight == s && t.$root.offsetWidth == o || r(),
                s = t.$root.offsetHeight,
                o = t.$root.offsetWidth,
                setTimeout(l, i)
        }
    }
    function jn(t) {
        return {
            x: t.$root.offsetWidth,
            y: t.$root.offsetHeight
        }
    }
    function na(t) {
        t.assert = function(r) {
            return function(s, o) {
                s || r.config.show_errors && r.callEvent("onError", [o]) !== !1 && (r.message ? r.message({
                    type: "error",
                    text: o,
                    expire: -1
                }) : console.log(o))
            }
        }(t);
        var n = "Invalid value of the first argument of `gantt.init`. Supported values: HTMLElement, String (element id).This error means that either invalid object is passed into `gantt.init` or that the element with the specified ID doesn't exist on the page when `gantt.init` is called.";
        function e(r) {
            if (!r || typeof r == "string" && document.getElementById(r) || function(s) {
                try {
                    s.cloneNode(!1)
                } catch {
                    return !1
                }
                return !0
            }(r))
                return !0;
            throw t.assert(!1, n),
                new Error(n)
        }
        t.init = function(r, s, o) {
            t.env.isNode ? r = null : e(r),
            s && o && (this.config.start_date = this._min_date = new Date(s),
                this.config.end_date = this._max_date = new Date(o)),
                this.date.init(),
                this.init = function(l) {
                    t.env.isNode ? l = null : e(l),
                    this.$container && this.$container.parentNode && (this.$container.parentNode.removeChild(this.$container),
                        this.$container = null),
                    this.$layout && this.$layout.clear(),
                        this._reinit(l)
                }
                ,
                this._reinit(r)
        }
            ,
            t._quickRefresh = function(r) {
                for (var s = this._getDatastores.call(this), o = 0; o < s.length; o++)
                    s[o]._quick_refresh = !0;
                for (r(),
                         o = 0; o < s.length; o++)
                    s[o]._quick_refresh = !1
            }
        ;
        var i = (function() {
                this._clearTaskLayers && this._clearTaskLayers(),
                this._clearLinkLayers && this._clearLinkLayers(),
                this.$layout && (this.$layout.destructor(),
                    this.$layout = null,
                    this.$ui.reset())
            }
        ).bind(t)
            , a = (function() {
                K(t) || (this.$root.innerHTML = "",
                    this.$root.gantt = this,
                    De(this),
                    this.config.layout.id = "main",
                    this.$layout = this.$ui.createView("layout", this.$root, this.config.layout),
                    this.$layout.attachEvent("onBeforeResize", function() {
                        for (var r = t.$services.getService("datastores"), s = 0; s < r.length; s++)
                            t.getDatastore(r[s]).filter(),
                                t.$data.tasksStore._skipTaskRecalculation ? t.$data.tasksStore._skipTaskRecalculation != "lightbox" && (t.$data.tasksStore._skipTaskRecalculation = !1) : t.getDatastore(r[s]).callEvent("onBeforeRefreshAll", [])
                    }),
                    this.$layout.attachEvent("onResize", function() {
                        t._quickRefresh(function() {
                            t.refreshData()
                        })
                    }),
                    this.callEvent("onGanttLayoutReady", []),
                    this.$layout.render(),
                    this.$container = this.$layout.$container.firstChild,
                    function(r) {
                        window.getComputedStyle(r.$root).getPropertyValue("position") == "static" && (r.$root.style.position = "relative");
                        var s = document.createElement("iframe");
                        s.className = "gantt_container_resize_watcher",
                            s.tabIndex = -1,
                        r.config.wai_aria_attributes && (s.setAttribute("role", "none"),
                            s.setAttribute("aria-hidden", !0)),
                        r.env.isSalesforce && (r.config.container_resize_method = "timeout"),
                            r.$root.appendChild(s),
                            s.contentWindow ? zn(r, s.contentWindow) : (r.$root.removeChild(s),
                                zn(r, window))
                    }(this))
            }
        ).bind(t);
        t.resetLayout = function() {
            i(),
                a(),
                this.render()
        }
            ,
            t._reinit = function(r) {
                this.callEvent("onBeforeGanttReady", []),
                    this._update_flags(),
                    this.$services.getService("templateLoader").initTemplates(this),
                    i(),
                    this.$root = null,
                r && (this.$root = ye(r),
                    a(),
                    this.$mouseEvents.reset(this.$root),
                    function(s) {
                        s.$container && !s.config.autosize && s.$root.offsetHeight < 50 && console.warn(`The Gantt container has a small height, so you cannot see its content. If it is not intended, you need to set the 'height' style rule to the container:
https://docs.dhtmlx.com/gantt/faq.html#theganttchartisntrenderedcorrectly`)
                    }(t)),
                    this.callEvent("onTemplatesReady", []),
                    this.callEvent("onGanttReady", []),
                    this.render()
            }
            ,
            t.$click = {
                buttons: {
                    edit: function(r) {
                        t.isReadonly(t.getTask(r)) || t.showLightbox(r)
                    },
                    delete: function(r) {
                        var s = t.getTask(r);
                        if (!t.isReadonly(s)) {
                            var o = t.locale.labels.confirm_deleting
                                , l = t.locale.labels.confirm_deleting_title;
                            t._delete_task_confirm({
                                task: s,
                                message: o,
                                title: l,
                                callback: function() {
                                    t.isTaskExists(r) && (s.$new ? (t.$data.tasksStore._skipTaskRecalculation = "lightbox",
                                        t.silent(function() {
                                            t.deleteTask(r, !0)
                                        }),
                                        t.$data.tasksStore._skipTaskRecalculation = !1,
                                        t.refreshData()) : (t.$data.tasksStore._skipTaskRecalculation = !0,
                                        t.deleteTask(r))),
                                        t.hideLightbox()
                                }
                            })
                        }
                    }
                }
            },
            t.render = function() {
                var r;
                if (this.callEvent("onBeforeGanttRender", []),
                    !K(t)) {
                    !this.config.sort && this._sort && (this._sort = void 0),
                    this.$root && (this.config.rtl ? (this.$root.classList.add("gantt_rtl"),
                        this.$root.firstChild.classList.add("gantt_rtl")) : (this.$root.classList.remove("gantt_rtl"),
                        this.$root.firstChild.classList.remove("gantt_rtl")));
                    var s = this.getScrollState()
                        , o = s ? s.x : 0;
                    this._getHorizontalScrollbar() && (o = this._getHorizontalScrollbar().$config.codeScrollLeft || o || 0),
                        r = null,
                    o && (r = t.dateFromPos(o + this.config.task_scroll_offset))
                }
                if (De(this),
                    K(t))
                    t.refreshData();
                else {
                    this.$layout.$config.autosize = this.config.autosize;
                    var l = this.config.preserve_scroll;
                    if (this.config.preserve_scroll = !1,
                        this.$layout.resize(),
                        this.config.preserve_scroll = l,
                    this.config.preserve_scroll && s) {
                        if (o || s.y) {
                            var d = t.getScrollState();
                            if (+r != +t.dateFromPos(d.x) || d.y != s.y) {
                                o = null;
                                var c = null;
                                r && (o = Math.max(t.posFromDate(r) - t.config.task_scroll_offset, 0)),
                                s.y && (c = s.y),
                                    t.scrollTo(o, c)
                            }
                        }
                        this.$layout.getScrollbarsInfo().forEach(u => {
                                const h = t.$ui.getView(u.id)
                                    , _ = t.utils.dom.isChildOf(h.$view, t.$container);
                                u.boundViews.forEach(f => {
                                        const y = t.$ui.getView(f);
                                        u.y && u.y != s.y && y && !_ && y.scrollTo(void 0, 0),
                                        u.x_pos && u.x_pos != s.x && y && _ && y.scrollTo(u.x_pos, void 0)
                                    }
                                )
                            }
                        )
                    }
                }
                this.callEvent("onGanttRender", [])
            }
            ,
            t.setSizes = t.render,
            t.getTaskRowNode = function(r) {
                for (var s = this.$grid_data.childNodes, o = this.config.task_attribute, l = 0; l < s.length; l++)
                    if (s[l].getAttribute && s[l].getAttribute(o) == r)
                        return s[l];
                return null
            }
            ,
            t.changeLightboxType = function(r) {
                if (this.getLightboxType() == r)
                    return !0;
                t._silent_redraw_lightbox(r)
            }
            ,
            t._get_link_type = function(r, s) {
                var o = null;
                return r && s ? o = t.config.links.start_to_start : !r && s ? o = t.config.links.finish_to_start : r || s ? r && !s && (o = t.config.links.start_to_finish) : o = t.config.links.finish_to_finish,
                    o
            }
            ,
            t.isLinkAllowed = function(r, s, o, l) {
                var d = null;
                if (!(d = typeof r == "object" ? r : {
                    source: r,
                    target: s,
                    type: this._get_link_type(o, l)
                }) || !(d.source && d.target && d.type) || d.source == d.target)
                    return !1;
                var c = !0;
                return this.checkEvent("onLinkValidation") && (c = this.callEvent("onLinkValidation", [d])),
                    c
            }
            ,
            t._correct_dst_change = function(r, s, o, l) {
                var d = Jt(l) * o;
                if (d > 3600 && d < 86400) {
                    var c = r.getTimezoneOffset() - s;
                    c && (r = t.date.add(r, c, "minute"))
                }
                return r
            }
            ,
            t.isSplitTask = function(r) {
                return t.assert(r && r instanceof Object, "Invalid argument <b>task</b>=" + r + " of gantt.isSplitTask. Task object was expected"),
                    this.$data.tasksStore._isSplitItem(r)
            }
            ,
            t._is_icon_open_click = function(r) {
                if (!r)
                    return !1;
                var s = r.target || r.srcElement;
                if (!s || !s.className)
                    return !1;
                var o = it(s);
                return o.indexOf("gantt_tree_icon") !== -1 && (o.indexOf("gantt_close") !== -1 || o.indexOf("gantt_open") !== -1)
            }
    }
    const ia = {
        date: {
            month_full: ["كانون الثاني", "شباط", "آذار", "نيسان", "أيار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول"],
            month_short: ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"],
            day_full: ["الأحد", "الأثنين", "ألثلاثاء", "الأربعاء", "ألحميس", "ألجمعة", "السبت"],
            day_short: ["احد", "اثنين", "ثلاثاء", "اربعاء", "خميس", "جمعة", "سبت"]
        },
        labels: {
            new_task: "مهمة جديد",
            icon_save: "اخزن",
            icon_cancel: "الغاء",
            icon_details: "تفاصيل",
            icon_edit: "تحرير",
            icon_delete: "حذف",
            confirm_closing: "التغييرات سوف تضيع, هل انت متأكد؟",
            confirm_deleting: "الحدث سيتم حذفها نهائيا ، هل أنت متأكد؟",
            section_description: "الوصف",
            section_time: "الفترة الزمنية",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "الغاء",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , aa = {
        date: {
            month_full: ["Студзень", "Люты", "Сакавік", "Красавік", "Maй", "Чэрвень", "Ліпень", "Жнівень", "Верасень", "Кастрычнік", "Лістапад", "Снежань"],
            month_short: ["Студз", "Лют", "Сак", "Крас", "Maй", "Чэр", "Ліп", "Жнів", "Вер", "Каст", "Ліст", "Снеж"],
            day_full: ["Нядзеля", "Панядзелак", "Аўторак", "Серада", "Чацвер", "Пятніца", "Субота"],
            day_short: ["Нд", "Пн", "Аўт", "Ср", "Чцв", "Пт", "Сб"]
        },
        labels: {
            new_task: "Новае заданне",
            icon_save: "Захаваць",
            icon_cancel: "Адмяніць",
            icon_details: "Дэталі",
            icon_edit: "Змяніць",
            icon_delete: "Выдаліць",
            confirm_closing: "",
            confirm_deleting: "Падзея будзе выдалена незваротна, працягнуць?",
            section_description: "Апісанне",
            section_time: "Перыяд часу",
            section_type: "Тып",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "ІСР",
            column_text: "Задача",
            column_start_date: "Пачатак",
            column_duration: "Працяг",
            column_add: "",
            link: "Сувязь",
            confirm_link_deleting: "будзе выдалена",
            link_start: "(пачатак)",
            link_end: "(канец)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Хвiлiна",
            hours: "Гадзiна",
            days: "Дзень",
            weeks: "Тыдзень",
            months: "Месяц",
            years: "Год",
            message_ok: "OK",
            message_cancel: "Адмяніць",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , ra = {
        date: {
            month_full: ["Gener", "Febrer", "Març", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"],
            month_short: ["Gen", "Feb", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Oct", "Nov", "Des"],
            day_full: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"],
            day_short: ["Dg", "Dl", "Dm", "Dc", "Dj", "Dv", "Ds"]
        },
        labels: {
            new_task: "Nova tasca",
            icon_save: "Guardar",
            icon_cancel: "Cancel·lar",
            icon_details: "Detalls",
            icon_edit: "Editar",
            icon_delete: "Esborrar",
            confirm_closing: "",
            confirm_deleting: "L'esdeveniment s'esborrarà definitivament, continuar ?",
            section_description: "Descripció",
            section_time: "Periode de temps",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Cancel·lar",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , sa = {
        date: {
            month_full: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
            month_short: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
            day_full: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
            day_short: ["日", "一", "二", "三", "四", "五", "六"]
        },
        labels: {
            new_task: "新任務",
            icon_save: "保存",
            icon_cancel: "关闭",
            icon_details: "详细",
            icon_edit: "编辑",
            icon_delete: "删除",
            confirm_closing: "请确认是否撤销修改!",
            confirm_deleting: "是否删除日程?",
            section_description: "描述",
            section_time: "时间范围",
            section_type: "类型",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "工作分解结构",
            column_text: "任务名",
            column_start_date: "开始时间",
            column_duration: "持续时间",
            column_add: "",
            link: "关联",
            confirm_link_deleting: "将被删除",
            link_start: " (开始)",
            link_end: " (结束)",
            type_task: "任务",
            type_project: "项目",
            type_milestone: "里程碑",
            minutes: "分钟",
            hours: "小时",
            days: "天",
            weeks: "周",
            months: "月",
            years: "年",
            message_ok: "OK",
            message_cancel: "关闭",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , oa = {
        date: {
            month_full: ["Leden", "Únor", "Březen", "Duben", "Květen", "Červen", "Červenec", "Srpen", "Září", "Říjen", "Listopad", "Prosinec"],
            month_short: ["Led", "Ún", "Bře", "Dub", "Kvě", "Čer", "Čec", "Srp", "Září", "Říj", "List", "Pro"],
            day_full: ["Neděle", "Pondělí", "Úterý", "Středa", "Čtvrtek", "Pátek", "Sobota"],
            day_short: ["Ne", "Po", "Út", "St", "Čt", "Pá", "So"]
        },
        labels: {
            new_task: "Nová práce",
            icon_save: "Uložit",
            icon_cancel: "Zpět",
            icon_details: "Detail",
            icon_edit: "Edituj",
            icon_delete: "Smazat",
            confirm_closing: "",
            confirm_deleting: "Událost bude trvale smazána, opravdu?",
            section_description: "Poznámky",
            section_time: "Doba platnosti",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Zpět",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , la = {
        date: {
            month_full: ["Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"],
            month_short: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
            day_full: ["Søndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag"],
            day_short: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"]
        },
        labels: {
            new_task: "Ny opgave",
            icon_save: "Gem",
            icon_cancel: "Fortryd",
            icon_details: "Detaljer",
            icon_edit: "Tilret",
            icon_delete: "Slet",
            confirm_closing: "Dine rettelser vil gå tabt.. Er dy sikker?",
            confirm_deleting: "Bigivenheden vil blive slettet permanent. Er du sikker?",
            section_description: "Beskrivelse",
            section_time: "Tidsperiode",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Fortryd",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , da = {
        date: {
            month_full: [" Januar", " Februar", " März ", " April", " Mai", " Juni", " Juli", " August", " September ", " Oktober", " November ", " Dezember"],
            month_short: ["Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
            day_full: ["Sonntag", "Montag", "Dienstag", " Mittwoch", " Donnerstag", "Freitag", "Samstag"],
            day_short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"]
        },
        labels: {
            new_task: "Neue Aufgabe",
            icon_save: "Speichern",
            icon_cancel: "Abbrechen",
            icon_details: "Details",
            icon_edit: "Ändern",
            icon_delete: "Löschen",
            confirm_closing: "",
            confirm_deleting: "Der Eintrag wird gelöscht",
            section_description: "Beschreibung",
            section_time: "Zeitspanne",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "PSP",
            column_text: "Task-Namen",
            column_start_date: "Startzeit",
            column_duration: "Dauer",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "werden gelöscht",
            link_start: "(starten)",
            link_end: "(ende)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minuten",
            hours: "Stunden",
            days: "Tage",
            weeks: "Wochen",
            months: "Monate",
            years: "Jahre",
            message_ok: "OK",
            message_cancel: "Abbrechen",
            section_constraint: "Regel",
            constraint_type: "Regel",
            constraint_date: "Regel - Datum",
            asap: "So bald wie möglich",
            alap: "So spät wie möglich",
            snet: "Beginn nicht vor",
            snlt: "Beginn nicht später als",
            fnet: "Fertigstellung nicht vor",
            fnlt: "Fertigstellung nicht später als",
            mso: "Muss beginnen am",
            mfo: "Muss fertig sein am",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , ca = {
        date: {
            month_full: ["Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάϊος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος"],
            month_short: ["ΙΑΝ", "ΦΕΒ", "ΜΑΡ", "ΑΠΡ", "ΜΑΙ", "ΙΟΥΝ", "ΙΟΥΛ", "ΑΥΓ", "ΣΕΠ", "ΟΚΤ", "ΝΟΕ", "ΔΕΚ"],
            day_full: ["Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Κυριακή"],
            day_short: ["ΚΥ", "ΔΕ", "ΤΡ", "ΤΕ", "ΠΕ", "ΠΑ", "ΣΑ"]
        },
        labels: {
            new_task: "Νέα εργασία",
            icon_save: "Αποθήκευση",
            icon_cancel: "Άκυρο",
            icon_details: "Λεπτομέρειες",
            icon_edit: "Επεξεργασία",
            icon_delete: "Διαγραφή",
            confirm_closing: "",
            confirm_deleting: "Το έργο θα διαγραφεί οριστικά. Θέλετε να συνεχίσετε;",
            section_description: "Περιγραφή",
            section_time: "Χρονική περίοδος",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Άκυρο",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , ua = {
        date: {
            month_full: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            month_short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            day_full: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            day_short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        },
        labels: {
            new_task: "New task",
            icon_save: "Save",
            icon_cancel: "Cancel",
            icon_details: "Details",
            icon_edit: "Edit",
            icon_delete: "Delete",
            confirm_closing: "",
            confirm_deleting: "Task will be deleted permanently, are you sure?",
            section_description: "Description",
            section_time: "Time period",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Cancel",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , ha = {
        date: {
            month_full: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
            month_short: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
            day_full: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"],
            day_short: ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"]
        },
        labels: {
            new_task: "Nueva tarea",
            icon_save: "Guardar",
            icon_cancel: "Cancelar",
            icon_details: "Detalles",
            icon_edit: "Editar",
            icon_delete: "Eliminar",
            confirm_closing: "",
            confirm_deleting: "El evento se borrará definitivamente, ¿continuar?",
            section_description: "Descripción",
            section_time: "Período",
            section_type: "Tipo",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "EDT",
            column_text: "Tarea",
            column_start_date: "Inicio",
            column_duration: "Duración",
            column_add: "",
            link: "Enlace",
            confirm_link_deleting: "será borrada",
            link_start: " (inicio)",
            link_end: " (fin)",
            type_task: "Tarea",
            type_project: "Proyecto",
            type_milestone: "Hito",
            minutes: "Minutos",
            hours: "Horas",
            days: "Días",
            weeks: "Semanas",
            months: "Meses",
            years: "Años",
            message_ok: "OK",
            message_cancel: "Cancelar",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , _a = {
        date: {
            month_full: ["ژانویه", "فوریه", "مارس", "آوریل", "مه", "ژوئن", "ژوئیه", "اوت", "سپتامبر", "اکتبر", "نوامبر", "دسامبر"],
            month_short: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
            day_full: ["يکشنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنجشنبه", "جمعه", "شنبه"],
            day_short: ["ی", "د", "س", "چ", "پ", "ج", "ش"]
        },
        labels: {
            new_task: "وظیفه جدید",
            icon_save: "ذخیره",
            icon_cancel: "لغو",
            icon_details: "جزییات",
            icon_edit: "ویرایش",
            icon_delete: "حذف",
            confirm_closing: "تغییرات شما ازدست خواهد رفت، آیا مطمئن هستید؟",
            confirm_deleting: "این مورد برای همیشه حذف خواهد شد، آیا مطمئن هستید؟",
            section_description: "توضیحات",
            section_time: "مدت زمان",
            section_type: "نوع",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "عنوان",
            column_start_date: "زمان شروع",
            column_duration: "مدت",
            column_add: "",
            link: "ارتباط",
            confirm_link_deleting: "حذف خواهد شد",
            link_start: " (آغاز)",
            link_end: " (پایان)",
            type_task: "وظیفه",
            type_project: "پروژه",
            type_milestone: "نگارش",
            minutes: "دقایق",
            hours: "ساعات",
            days: "روزها",
            weeks: "هفته",
            months: "ماه‌ها",
            years: "سال‌ها",
            message_ok: "تایید",
            message_cancel: "لغو",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , ga = {
        date: {
            month_full: ["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Kes&auml;kuu", "Hein&auml;kuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"],
            month_short: ["Tam", "Hel", "Maa", "Huh", "Tou", "Kes", "Hei", "Elo", "Syy", "Lok", "Mar", "Jou"],
            day_full: ["Sunnuntai", "Maanantai", "Tiistai", "Keskiviikko", "Torstai", "Perjantai", "Lauantai"],
            day_short: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"]
        },
        labels: {
            new_task: "Uusi tehtävä",
            icon_save: "Tallenna",
            icon_cancel: "Peru",
            icon_details: "Tiedot",
            icon_edit: "Muokkaa",
            icon_delete: "Poista",
            confirm_closing: "",
            confirm_deleting: "Haluatko varmasti poistaa tapahtuman?",
            section_description: "Kuvaus",
            section_time: "Aikajakso",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Peru",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , fa = {
        date: {
            month_full: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"],
            month_short: ["Jan", "Fév", "Mar", "Avr", "Mai", "Juin", "Juil", "Aoû", "Sep", "Oct", "Nov", "Déc"],
            day_full: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"],
            day_short: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"]
        },
        labels: {
            new_task: "Nouvelle tâche",
            icon_save: "Enregistrer",
            icon_cancel: "Annuler",
            icon_details: "Détails",
            icon_edit: "Modifier",
            icon_delete: "Effacer",
            confirm_closing: "",
            confirm_deleting: "L'événement sera effacé sans appel, êtes-vous sûr ?",
            section_description: "Description",
            section_time: "Période",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "OTP",
            column_text: "Nom de la tâche",
            column_start_date: "Date initiale",
            column_duration: "Durée",
            column_add: "",
            link: "Le lien",
            confirm_link_deleting: "sera supprimé",
            link_start: "(début)",
            link_end: "(fin)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Heures",
            days: "Jours",
            weeks: "Semaines",
            months: "Mois",
            years: "Années",
            message_ok: "OK",
            message_cancel: "Annuler",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , pa = {
        date: {
            month_full: ["ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר"],
            month_short: ["ינו", "פבר", "מרץ", "אפר", "מאי", "יונ", "יול", "אוג", "ספט", "אוק", "נוב", "דצמ"],
            day_full: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"],
            day_short: ["א", "ב", "ג", "ד", "ה", "ו", "ש"]
        },
        labels: {
            new_task: "משימה חדש",
            icon_save: "שמור",
            icon_cancel: "בטל",
            icon_details: "פרטים",
            icon_edit: "ערוך",
            icon_delete: "מחק",
            confirm_closing: "",
            confirm_deleting: "ארוע ימחק סופית.להמשיך?",
            section_description: "הסבר",
            section_time: "תקופה",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "בטל",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , ma = {
        date: {
            month_full: ["Siječanj", "Veljača", "Ožujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"],
            month_short: ["Sij", "Velj", "Ožu", "Tra", "Svi", "Lip", "Srp", "Kol", "Ruj", "Lis", "Stu", "Pro"],
            day_full: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"],
            day_short: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"]
        },
        labels: {
            new_task: "Novi Zadatak",
            icon_save: "Spremi",
            icon_cancel: "Odustani",
            icon_details: "Detalji",
            icon_edit: "Izmjeni",
            icon_delete: "Obriši",
            confirm_closing: "",
            confirm_deleting: "Zadatak će biti trajno izbrisan, jeste li sigurni?",
            section_description: "Opis",
            section_time: "Vremenski Period",
            section_type: "Tip",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Naziv Zadatka",
            column_start_date: "Početno Vrijeme",
            column_duration: "Trajanje",
            column_add: "",
            link: "Poveznica",
            confirm_link_deleting: "će biti izbrisan",
            link_start: " (početak)",
            link_end: " (kraj)",
            type_task: "Zadatak",
            type_project: "Projekt",
            type_milestone: "Milestone",
            minutes: "Minute",
            hours: "Sati",
            days: "Dani",
            weeks: "Tjedni",
            months: "Mjeseci",
            years: "Godine",
            message_ok: "OK",
            message_cancel: "Odustani",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , va = {
        date: {
            month_full: ["Január", "Február", "Március", "Április", "Május", "Június", "Július", "Augusztus", "Szeptember", "Október", "November", "December"],
            month_short: ["Jan", "Feb", "Már", "Ápr", "Máj", "Jún", "Júl", "Aug", "Sep", "Okt", "Nov", "Dec"],
            day_full: ["Vasárnap", "Hétfõ", "Kedd", "Szerda", "Csütörtök", "Péntek", "szombat"],
            day_short: ["Va", "Hé", "Ke", "Sze", "Csü", "Pé", "Szo"]
        },
        labels: {
            new_task: "Új feladat",
            icon_save: "Mentés",
            icon_cancel: "Mégse",
            icon_details: "Részletek",
            icon_edit: "Szerkesztés",
            icon_delete: "Törlés",
            confirm_closing: "",
            confirm_deleting: "Az esemény törölve lesz, biztosan folytatja?",
            section_description: "Leírás",
            section_time: "Idõszak",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Mégse",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , ka = {
        date: {
            month_full: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"],
            month_short: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Ags", "Sep", "Okt", "Nov", "Des"],
            day_full: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"],
            day_short: ["Ming", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"]
        },
        labels: {
            new_task: "Tugas baru",
            icon_save: "Simpan",
            icon_cancel: "Batal",
            icon_details: "Detail",
            icon_edit: "Edit",
            icon_delete: "Hapus",
            confirm_closing: "",
            confirm_deleting: "Acara akan dihapus",
            section_description: "Keterangan",
            section_time: "Periode",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Batal",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , ya = {
        date: {
            month_full: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
            month_short: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"],
            day_full: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"],
            day_short: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"]
        },
        labels: {
            new_task: "Nuovo compito",
            icon_save: "Salva",
            icon_cancel: "Chiudi",
            icon_details: "Dettagli",
            icon_edit: "Modifica",
            icon_delete: "Elimina",
            confirm_closing: "",
            confirm_deleting: "Sei sicuro di confermare l'eliminazione?",
            section_description: "Descrizione",
            section_time: "Periodo di tempo",
            section_type: "Tipo",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Nome Attività",
            column_start_date: "Inizio",
            column_duration: "Durata",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "sarà eliminato",
            link_start: " (inizio)",
            link_end: " (fine)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minuti",
            hours: "Ore",
            days: "Giorni",
            weeks: "Settimane",
            months: "Mesi",
            years: "Anni",
            message_ok: "OK",
            message_cancel: "Chiudi",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , ba = {
        date: {
            month_full: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
            month_short: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
            day_full: ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"],
            day_short: ["日", "月", "火", "水", "木", "金", "土"]
        },
        labels: {
            new_task: "新しい仕事",
            icon_save: "保存",
            icon_cancel: "キャンセル",
            icon_details: "詳細",
            icon_edit: "編集",
            icon_delete: "削除",
            confirm_closing: "",
            confirm_deleting: "イベント完全に削除されます、宜しいですか？",
            section_description: "デスクリプション",
            section_time: "期間",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "キャンセル",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , $a = {
        date: {
            month_full: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
            month_short: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
            day_full: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"],
            day_short: ["일", "월", "화", "수", "목", "금", "토"]
        },
        labels: {
            new_task: "이름없는 작업",
            icon_save: "저장",
            icon_cancel: "취소",
            icon_details: "세부 사항",
            icon_edit: "수정",
            icon_delete: "삭제",
            confirm_closing: "",
            confirm_deleting: "작업을 삭제하시겠습니까?",
            section_description: "설명",
            section_time: "기간",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "작업명",
            column_start_date: "시작일",
            column_duration: "기간",
            column_add: "",
            link: "전제",
            confirm_link_deleting: "삭제 하시겠습니까?",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "작업",
            type_project: "프로젝트",
            type_milestone: "마일스톤",
            minutes: "분",
            hours: "시간",
            days: "일",
            weeks: "주",
            months: "달",
            years: "년",
            message_ok: "OK",
            message_cancel: "취소",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    };
    class xa {
        constructor(n) {
            this.addLocale = (e, i) => {
                this._locales[e] = i
            }
                ,
                this.getLocale = e => this._locales[e],
                this._locales = {};
            for (const e in n)
                this._locales[e] = n[e]
        }
    }
    const wa = {
        date: {
            month_full: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"],
            month_short: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"],
            day_full: ["Søndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag"],
            day_short: ["Søn", "Mon", "Tir", "Ons", "Tor", "Fre", "Lør"]
        },
        labels: {
            new_task: "Ny oppgave",
            icon_save: "Lagre",
            icon_cancel: "Avbryt",
            icon_details: "Detaljer",
            icon_edit: "Rediger",
            icon_delete: "Slett",
            confirm_closing: "",
            confirm_deleting: "Hendelsen vil bli slettet permanent. Er du sikker?",
            section_description: "Beskrivelse",
            section_time: "Tidsperiode",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Avbryt",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , Sa = {
        date: {
            month_full: ["Januari", "Februari", "Maart", "April", "Mei", "Juni", "Juli", "Augustus", "September", "Oktober", "November", "December"],
            month_short: ["Jan", "Feb", "mrt", "Apr", "Mei", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
            day_full: ["Zondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrijdag", "Zaterdag"],
            day_short: ["Zo", "Ma", "Di", "Wo", "Do", "Vr", "Za"]
        },
        labels: {
            new_task: "Nieuwe taak",
            icon_save: "Opslaan",
            icon_cancel: "Annuleren",
            icon_details: "Details",
            icon_edit: "Bewerken",
            icon_delete: "Verwijderen",
            confirm_closing: "",
            confirm_deleting: "Item zal permanent worden verwijderd, doorgaan?",
            section_description: "Beschrijving",
            section_time: "Tijd periode",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Taak omschrijving",
            column_start_date: "Startdatum",
            column_duration: "Duur",
            column_add: "",
            link: "Koppeling",
            confirm_link_deleting: "zal worden verwijderd",
            link_start: " (start)",
            link_end: " (eind)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "minuten",
            hours: "uren",
            days: "dagen",
            weeks: "weken",
            months: "maanden",
            years: "jaren",
            message_ok: "OK",
            message_cancel: "Annuleren",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , Ta = {
        date: {
            month_full: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"],
            month_short: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"],
            day_full: ["Søndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag"],
            day_short: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"]
        },
        labels: {
            new_task: "Ny oppgave",
            icon_save: "Lagre",
            icon_cancel: "Avbryt",
            icon_details: "Detaljer",
            icon_edit: "Endre",
            icon_delete: "Slett",
            confirm_closing: "Endringer blir ikke lagret, er du sikker?",
            confirm_deleting: "Oppføringen vil bli slettet, er du sikker?",
            section_description: "Beskrivelse",
            section_time: "Tidsperiode",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Avbryt",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , Ea = {
        date: {
            month_full: ["Styczeń", "Luty", "Marzec", "Kwiecień", "Maj", "Czerwiec", "Lipiec", "Sierpień", "Wrzesień", "Październik", "Listopad", "Grudzień"],
            month_short: ["Sty", "Lut", "Mar", "Kwi", "Maj", "Cze", "Lip", "Sie", "Wrz", "Paź", "Lis", "Gru"],
            day_full: ["Niedziela", "Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota"],
            day_short: ["Nie", "Pon", "Wto", "Śro", "Czw", "Pią", "Sob"]
        },
        labels: {
            new_task: "Nowe zadanie",
            icon_save: "Zapisz",
            icon_cancel: "Anuluj",
            icon_details: "Szczegóły",
            icon_edit: "Edytuj",
            icon_delete: "Usuń",
            confirm_closing: "",
            confirm_deleting: "Zdarzenie zostanie usunięte na zawsze, kontynuować?",
            section_description: "Opis",
            section_time: "Okres czasu",
            section_type: "Typ",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Nazwa zadania",
            column_start_date: "Początek",
            column_duration: "Czas trwania",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "zostanie usunięty",
            link_start: " (początek)",
            link_end: " (koniec)",
            type_task: "Zadanie",
            type_project: "Projekt",
            type_milestone: "Milestone",
            minutes: "Minuty",
            hours: "Godziny",
            days: "Dni",
            weeks: "Tydzień",
            months: "Miesiące",
            years: "Lata",
            message_ok: "OK",
            message_cancel: "Anuluj",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , Ca = {
        date: {
            month_full: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            month_short: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
            day_full: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"],
            day_short: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"]
        },
        labels: {
            new_task: "Nova tarefa",
            icon_save: "Salvar",
            icon_cancel: "Cancelar",
            icon_details: "Detalhes",
            icon_edit: "Editar",
            icon_delete: "Excluir",
            confirm_closing: "",
            confirm_deleting: "As tarefas serão excluidas permanentemente, confirme?",
            section_description: "Descrição",
            section_time: "Período",
            section_type: "Tipo",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "EAP",
            column_text: "Nome tarefa",
            column_start_date: "Data início",
            column_duration: "Duração",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "Será excluído!",
            link_start: " (início)",
            link_end: " (fim)",
            type_task: "Task",
            type_project: "Projeto",
            type_milestone: "Marco",
            minutes: "Minutos",
            hours: "Horas",
            days: "Dias",
            weeks: "Semanas",
            months: "Meses",
            years: "Anos",
            message_ok: "OK",
            message_cancel: "Cancelar",
            section_constraint: "Restrição",
            constraint_type: "Tipo Restrição",
            constraint_date: "Data restrição",
            asap: "Mais breve possível",
            alap: "Mais tarde possível",
            snet: "Não começar antes de",
            snlt: "Não começar depois de",
            fnet: "Não terminar antes de",
            fnlt: "Não terminar depois de",
            mso: "Precisa começar em",
            mfo: "Precisa terminar em",
            resources_filter_placeholder: "Tipo de filtros",
            resources_filter_label: "Ocultar vazios",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , Da = {
        date: {
            month_full: ["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "November", "December"],
            month_short: ["Ian", "Feb", "Mar", "Apr", "Mai", "Iun", "Iul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            day_full: ["Duminica", "Luni", "Marti", "Miercuri", "Joi", "Vineri", "Sambata"],
            day_short: ["Du", "Lu", "Ma", "Mi", "Jo", "Vi", "Sa"]
        },
        labels: {
            new_task: "Sarcina noua",
            icon_save: "Salveaza",
            icon_cancel: "Anuleaza",
            icon_details: "Detalii",
            icon_edit: "Editeaza",
            icon_delete: "Sterge",
            confirm_closing: "Schimbarile nu vor fi salvate, esti sigur?",
            confirm_deleting: "Evenimentul va fi sters permanent, esti sigur?",
            section_description: "Descriere",
            section_time: "Interval",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Anuleaza",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , Aa = {
        date: {
            month_full: ["Январь", "Февраль", "Март", "Апрель", "Maй", "Июнь", "Июль", "Август", "Сентябрь", "Oктябрь", "Ноябрь", "Декабрь"],
            month_short: ["Янв", "Фев", "Maр", "Aпр", "Maй", "Июн", "Июл", "Aвг", "Сен", "Окт", "Ноя", "Дек"],
            day_full: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"],
            day_short: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"]
        },
        labels: {
            new_task: "Новое задание",
            icon_save: "Сохранить",
            icon_cancel: "Отменить",
            icon_details: "Детали",
            icon_edit: "Изменить",
            icon_delete: "Удалить",
            confirm_closing: "",
            confirm_deleting: "Событие будет удалено безвозвратно, продолжить?",
            section_description: "Описание",
            section_time: "Период времени",
            section_type: "Тип",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "ИСР",
            column_text: "Задача",
            column_start_date: "Начало",
            column_duration: "Длительность",
            column_add: "",
            link: "Связь",
            confirm_link_deleting: "будет удалена",
            link_start: " (начало)",
            link_end: " (конец)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Минута",
            hours: "Час",
            days: "День",
            weeks: "Неделя",
            months: "Месяц",
            years: "Год",
            message_ok: "OK",
            message_cancel: "Отменить",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "начните вводить слово для фильтрации",
            resources_filter_label: "спрятать не установленные",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , Ma = {
        date: {
            month_full: ["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"],
            month_short: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
            day_full: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "Četrtek", "Petek", "Sobota"],
            day_short: ["Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"]
        },
        labels: {
            new_task: "Nova naloga",
            icon_save: "Shrani",
            icon_cancel: "Prekliči",
            icon_details: "Podrobnosti",
            icon_edit: "Uredi",
            icon_delete: "Izbriši",
            confirm_closing: "",
            confirm_deleting: "Dogodek bo izbrisan. Želite nadaljevati?",
            section_description: "Opis",
            section_time: "Časovni okvir",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Prekliči",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , Ia = {
        date: {
            month_full: ["Január", "Február", "Marec", "Apríl", "Máj", "Jún", "Júl", "August", "September", "Október", "November", "December"],
            month_short: ["Jan", "Feb", "Mar", "Apr", "Máj", "Jún", "Júl", "Aug", "Sept", "Okt", "Nov", "Dec"],
            day_full: ["Nedeľa", "Pondelok", "Utorok", "Streda", "Štvrtok", "Piatok", "Sobota"],
            day_short: ["Ne", "Po", "Ut", "St", "Št", "Pi", "So"]
        },
        labels: {
            new_task: "Nová úloha",
            icon_save: "Uložiť",
            icon_cancel: "Späť",
            icon_details: "Detail",
            icon_edit: "Edituj",
            icon_delete: "Zmazať",
            confirm_closing: "Vaše zmeny nebudú uložené. Skutočne?",
            confirm_deleting: "Udalosť bude natrvalo vymazaná. Skutočne?",
            section_description: "Poznámky",
            section_time: "Doba platnosti",
            section_type: "Type",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Späť",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , La = {
        date: {
            month_full: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
            month_short: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
            day_full: ["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"],
            day_short: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"]
        },
        labels: {
            new_task: "Ny uppgift",
            icon_save: "Spara",
            icon_cancel: "Avbryt",
            icon_details: "Detajer",
            icon_edit: "Ändra",
            icon_delete: "Ta bort",
            confirm_closing: "",
            confirm_deleting: "Är du säker på att du vill ta bort händelsen permanent?",
            section_description: "Beskrivning",
            section_time: "Tid",
            section_type: "Typ",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Uppgiftsnamn",
            column_start_date: "Starttid",
            column_duration: "Varaktighet",
            column_add: "",
            link: "Länk",
            confirm_link_deleting: "kommer tas bort",
            link_start: " (start)",
            link_end: " (slut)",
            type_task: "Uppgift",
            type_project: "Projekt",
            type_milestone: "Milstolpe",
            minutes: "Minuter",
            hours: "Timmar",
            days: "Dagar",
            weeks: "Veckor",
            months: "Månader",
            years: "År",
            message_ok: "OK",
            message_cancel: "Avbryt",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , Na = {
        date: {
            month_full: ["Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"],
            month_short: ["Oca", "Şub", "Mar", "Nis", "May", "Haz", "Tem", "Ağu", "Eyl", "Eki", "Kas", "Ara"],
            day_full: ["Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"],
            day_short: ["Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cmt"]
        },
        labels: {
            new_task: "Yeni görev",
            icon_save: "Kaydet",
            icon_cancel: "İptal",
            icon_details: "Detaylar",
            icon_edit: "Düzenle",
            icon_delete: "Sil",
            confirm_closing: "",
            confirm_deleting: "Görev silinecek, emin misiniz?",
            section_description: "Açıklama",
            section_time: "Zaman Aralığı",
            section_type: "Tip",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Görev Adı",
            column_start_date: "Başlangıç",
            column_duration: "Süre",
            column_add: "",
            link: "Bağlantı",
            confirm_link_deleting: "silinecek",
            link_start: " (başlangıç)",
            link_end: " (bitiş)",
            type_task: "Görev",
            type_project: "Proje",
            type_milestone: "Kilometretaşı",
            minutes: "Dakika",
            hours: "Saat",
            days: "Gün",
            weeks: "Hafta",
            months: "Ay",
            years: "Yıl",
            message_ok: "OK",
            message_cancel: "Ýptal",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    }
        , Pa = {
        date: {
            month_full: ["Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень"],
            month_short: ["Січ", "Лют", "Бер", "Кві", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру"],
            day_full: ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"],
            day_short: ["Нед", "Пон", "Вів", "Сер", "Чет", "Птн", "Суб"]
        },
        labels: {
            new_task: "Нове завдання",
            icon_save: "Зберегти",
            icon_cancel: "Відміна",
            icon_details: "Деталі",
            icon_edit: "Редагувати",
            icon_delete: "Вилучити",
            confirm_closing: "",
            confirm_deleting: "Подія вилучиться назавжди. Ви впевнені?",
            section_description: "Опис",
            section_time: "Часовий проміжок",
            section_type: "Тип",
            section_deadline: "Deadline",
            section_baselines: "Baselines",
            column_wbs: "WBS",
            column_text: "Task name",
            column_start_date: "Start time",
            column_duration: "Duration",
            column_add: "",
            link: "Link",
            confirm_link_deleting: "will be deleted",
            link_start: " (start)",
            link_end: " (end)",
            type_task: "Task",
            type_project: "Project",
            type_milestone: "Milestone",
            minutes: "Minutes",
            hours: "Hours",
            days: "Days",
            weeks: "Week",
            months: "Months",
            years: "Years",
            message_ok: "OK",
            message_cancel: "Відміна",
            section_constraint: "Constraint",
            constraint_type: "Constraint type",
            constraint_date: "Constraint date",
            asap: "As Soon As Possible",
            alap: "As Late As Possible",
            snet: "Start No Earlier Than",
            snlt: "Start No Later Than",
            fnet: "Finish No Earlier Than",
            fnlt: "Finish No Later Than",
            mso: "Must Start On",
            mfo: "Must Finish On",
            resources_filter_placeholder: "type to filter",
            resources_filter_label: "hide empty",
            empty_state_text_link: "Click here",
            empty_state_text_description: "to create your first task",
            baselines_section_placeholder: "Start adding a new baseline",
            baselines_add_button: "Add Baseline",
            baselines_remove_button: "Remove",
            baselines_remove_all_button: "Remove All",
            deadline_enable_button: "Set",
            deadline_disable_button: "Remove"
        }
    };
    function Ra() {
        this.constants = $i,
            this.version = "9.0.15",
            this.license = "site",
            this.templates = {},
            this.ext = {},
            this.keys = {
                edit_save: this.constants.KEY_CODES.ENTER,
                edit_cancel: this.constants.KEY_CODES.ESC
            }
    }
    function Ha(t) {
        var n = new Ra
            , e = new bn(t)
            , i = {};
        n.plugins = function(l) {
            for (var d in l)
                if (l[d] && !i[d]) {
                    var c = e.getExtension(d);
                    c && (c(n),
                        i[d] = !0)
                }
            return i
        }
            ,
            n.$services = function() {
                var l = {};
                return {
                    services: {},
                    setService: function(d, c) {
                        l[d] = c
                    },
                    getService: function(d) {
                        return l[d] ? l[d]() : null
                    },
                    dropService: function(d) {
                        l[d] && delete l[d]
                    },
                    destructor: function() {
                        for (var d in l)
                            if (l[d]) {
                                var c = l[d];
                                c && c.destructor && c.destructor()
                            }
                        l = null
                    }
                }
            }(),
            n.config = {
                layout: {
                    css: "gantt_container",
                    rows: [{
                        cols: [{
                            view: "grid",
                            scrollX: "scrollHor",
                            scrollY: "scrollVer"
                        }, {
                            resizer: !0,
                            width: 1
                        }, {
                            view: "timeline",
                            scrollX: "scrollHor",
                            scrollY: "scrollVer"
                        }, {
                            view: "scrollbar",
                            id: "scrollVer"
                        }]
                    }, {
                        view: "scrollbar",
                        id: "scrollHor",
                        height: 20
                    }]
                },
                links: {
                    finish_to_start: "0",
                    start_to_start: "1",
                    finish_to_finish: "2",
                    start_to_finish: "3"
                },
                types: {
                    task: "task",
                    project: "project",
                    milestone: "milestone"
                },
                auto_types: !1,
                duration_unit: "day",
                work_time: !1,
                correct_work_time: !1,
                skip_off_time: !1,
                cascade_delete: !0,
                autosize: !1,
                autosize_min_width: 0,
                autoscroll: !0,
                autoscroll_speed: 30,
                deepcopy_on_parse: !1,
                show_links: !0,
                show_task_cells: !0,
                static_background: !1,
                static_background_cells: !0,
                branch_loading: !1,
                branch_loading_property: "$has_child",
                show_loading: !1,
                show_chart: !0,
                show_grid: !0,
                min_duration: 36e5,
                date_format: "%d-%m-%Y %H:%i",
                xml_date: void 0,
                start_on_monday: !0,
                server_utc: !1,
                show_progress: !0,
                fit_tasks: !1,
                select_task: !0,
                scroll_on_click: !0,
                smart_rendering: !0,
                preserve_scroll: !0,
                readonly: !1,
                container_resize_timeout: 20,
                deadlines: !0,
                date_grid: "%Y-%m-%d",
                drag_links: !0,
                drag_progress: !0,
                drag_resize: !0,
                drag_project: !1,
                drag_move: !0,
                drag_mode: {
                    resize: "resize",
                    progress: "progress",
                    move: "move",
                    ignore: "ignore"
                },
                round_dnd_dates: !0,
                link_wrapper_width: 20,
                link_arrow_size: 12,
                root_id: 0,
                autofit: !1,
                columns: [{
                    name: "text",
                    tree: !0,
                    width: "*",
                    resize: !0
                }, {
                    name: "start_date",
                    align: "center",
                    resize: !0
                }, {
                    name: "duration",
                    align: "center"
                }, {
                    name: "add",
                    width: 44
                }],
                scale_offset_minimal: !0,
                inherit_scale_class: !1,
                scales: [{
                    unit: "day",
                    step: 1,
                    date: "%d %M"
                }],
                time_step: 60,
                duration_step: 1,
                task_date: "%d %F %Y",
                time_picker: "%H:%i",
                task_attribute: "data-task-id",
                link_attribute: "data-link-id",
                layer_attribute: "data-layer",
                buttons_left: ["gantt_save_btn", "gantt_cancel_btn"],
                _migrate_buttons: {
                    dhx_save_btn: "gantt_save_btn",
                    dhx_cancel_btn: "gantt_cancel_btn",
                    dhx_delete_btn: "gantt_delete_btn"
                },
                buttons_right: ["gantt_delete_btn"],
                lightbox: {
                    sections: [{
                        name: "description",
                        height: 70,
                        map_to: "text",
                        type: "textarea",
                        focus: !0
                    }, {
                        name: "time",
                        type: "duration",
                        map_to: "auto"
                    }],
                    project_sections: [{
                        name: "description",
                        height: 70,
                        map_to: "text",
                        type: "textarea",
                        focus: !0
                    }, {
                        name: "type",
                        type: "typeselect",
                        map_to: "type"
                    }, {
                        name: "time",
                        type: "duration",
                        readonly: !0,
                        map_to: "auto"
                    }],
                    milestone_sections: [{
                        name: "description",
                        height: 70,
                        map_to: "text",
                        type: "textarea",
                        focus: !0
                    }, {
                        name: "type",
                        type: "typeselect",
                        map_to: "type"
                    }, {
                        name: "time",
                        type: "duration",
                        single_date: !0,
                        map_to: "auto"
                    }]
                },
                drag_lightbox: !0,
                sort: !1,
                details_on_create: !0,
                details_on_dblclick: !0,
                initial_scroll: !0,
                task_scroll_offset: 100,
                order_branch: !1,
                order_branch_free: !1,
                task_height: void 0,
                bar_height: "full",
                bar_height_padding: 9,
                min_column_width: 70,
                min_grid_column_width: 70,
                grid_resizer_column_attribute: "data-column-index",
                keep_grid_width: !1,
                grid_resize: !1,
                grid_elastic_columns: !1,
                show_tasks_outside_timescale: !1,
                show_unscheduled: !0,
                resize_rows: !1,
                task_grid_row_resizer_attribute: "data-row-index",
                min_task_grid_row_height: 30,
                row_height: 36,
                readonly_property: "readonly",
                editable_property: "editable",
                calendar_property: "calendar_id",
                resource_calendars: {},
                dynamic_resource_calendars: !1,
                inherit_calendar: !1,
                type_renderers: {},
                open_tree_initially: !1,
                optimize_render: !0,
                prevent_default_scroll: !1,
                show_errors: !0,
                wai_aria_attributes: !0,
                smart_scales: !0,
                rtl: !1,
                placeholder_task: !1,
                horizontal_scroll_key: "shiftKey",
                drag_timeline: {
                    useKey: void 0,
                    ignore: ".gantt_task_line, .gantt_task_link",
                    render: !1
                },
                drag_multiple: !0,
                csp: "auto"
            },
            n.ajax = function(l) {
                return {
                    cache: !0,
                    method: "get",
                    parse: function(d) {
                        return typeof d != "string" ? d : (d = d.replace(/^[\s]+/, ""),
                            typeof DOMParser > "u" || kt.isIE ? J.ActiveXObject !== void 0 && ((c = new J.ActiveXObject("Microsoft.XMLDOM")).async = "false",
                                c.loadXML(d)) : c = new DOMParser().parseFromString(d, "text/xml"),
                            c);
                        var c
                    },
                    xmltop: function(d, c, u) {
                        if (c.status === void 0 || c.status < 400) {
                            var h = c.responseXML ? c.responseXML || c : this.parse(c.responseText || c);
                            if (h && h.documentElement !== null && !h.getElementsByTagName("parsererror").length)
                                return h.getElementsByTagName(d)[0]
                        }
                        return u !== -1 && l.callEvent("onLoadXMLError", ["Incorrect XML", arguments[1], u]),
                            document.createElement("DIV")
                    },
                    xpath: function(d, c) {
                        if (c.nodeName || (c = c.responseXML || c),
                            kt.isIE)
                            return c.selectNodes(d) || [];
                        for (var u, h = [], _ = (c.ownerDocument || c).evaluate(d, c, null, XPathResult.ANY_TYPE, null); u = _.iterateNext(); )
                            h.push(u);
                        return h
                    },
                    query: function(d) {
                        return this._call(d.method || "GET", d.url, d.data || "", d.async || !0, d.callback, d.headers)
                    },
                    get: function(d, c, u) {
                        var h = Rt("GET", arguments);
                        return this.query(h)
                    },
                    getSync: function(d, c) {
                        var u = Rt("GET", arguments);
                        return u.async = !1,
                            this.query(u)
                    },
                    put: function(d, c, u, h) {
                        var _ = Rt("PUT", arguments);
                        return this.query(_)
                    },
                    del: function(d, c, u) {
                        var h = Rt("DELETE", arguments);
                        return this.query(h)
                    },
                    post: function(d, c, u, h) {
                        arguments.length == 1 ? c = "" : arguments.length == 2 && typeof c == "function" && (u = c,
                            c = "");
                        var _ = Rt("POST", arguments);
                        return this.query(_)
                    },
                    postSync: function(d, c, u) {
                        c = c === null ? "" : String(c);
                        var h = Rt("POST", arguments);
                        return h.async = !1,
                            this.query(h)
                    },
                    _call: function(d, c, u, h, _, f) {
                        return new l.Promise(function(y, v) {
                                var b = typeof XMLHttpRequest !== void 0 ? new XMLHttpRequest : new J.ActiveXObject("Microsoft.XMLHTTP")
                                    , g = navigator.userAgent.match(/AppleWebKit/) !== null && navigator.userAgent.match(/Qt/) !== null && navigator.userAgent.match(/Safari/) !== null;
                                h && (b.onreadystatechange = function() {
                                        if (b.readyState == 4 || g && b.readyState == 3) {
                                            if ((b.status < 200 || b.status > 299 || b.responseText === "") && !l.callEvent("onAjaxError", [b]))
                                                return;
                                            setTimeout(function() {
                                                typeof _ == "function" && _.apply(J, [{
                                                    xmlDoc: b,
                                                    filePath: c
                                                }]),
                                                    y(b),
                                                typeof _ == "function" && (_ = null,
                                                    b = null)
                                            }, 0)
                                        }
                                    }
                                );
                                var m = !this || !this.cache;
                                if (d == "GET" && m && (c += (c.indexOf("?") >= 0 ? "&" : "?") + "dhxr" + new Date().getTime() + "=1"),
                                    b.open(d, c, h),
                                    f)
                                    for (var p in f)
                                        b.setRequestHeader(p, f[p]);
                                else
                                    d.toUpperCase() == "POST" || d == "PUT" || d == "DELETE" ? b.setRequestHeader("Content-Type", "application/x-www-form-urlencoded") : d == "GET" && (u = null);
                                if (b.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
                                    b.send(u),
                                    !h)
                                    return {
                                        xmlDoc: b,
                                        filePath: c
                                    }
                            }
                        )
                    },
                    urlSeparator: function(d) {
                        return d.indexOf("?") != -1 ? "&" : "?"
                    }
                }
            }(n),
            n.date = xi(n),
            n.RemoteEvents = Si;
        var a = function(l) {
            function d(u) {
                return {
                    target: u.target || u.srcElement,
                    pageX: u.pageX,
                    pageY: u.pageY,
                    clientX: u.clientX,
                    clientY: u.clientY,
                    metaKey: u.metaKey,
                    shiftKey: u.shiftKey,
                    ctrlKey: u.ctrlKey,
                    altKey: u.altKey
                }
            }
            function c(u, h) {
                this._obj = u,
                    this._settings = h || {},
                    ct(this);
                var _ = this.getInputMethods();
                this._drag_start_timer = null,
                    l.attachEvent("onGanttScroll", z(function(v, b) {
                        this.clearDragTimer()
                    }, this));
                for (var f = {
                    passive: !1
                }, y = 0; y < _.length; y++)
                    z(function(v) {
                        l.event(u, v.down, z(function(g) {
                            v.accessor(g) && (g.button !== void 0 && g.button !== 0 || (h.preventDefault && h.selector && dt(g.target, h.selector) && g.preventDefault(),
                            l.config.touch && g.timeStamp && g.timeStamp - 0 < 300 || (this._settings.original_target = d(g),
                                this._settings.original_element_sizes = {
                                    ...lt(g, hn(u)),
                                    width: g.target.offsetWidth,
                                    height: g.target.offsetHeight
                                },
                                l.config.touch ? (this.clearDragTimer(),
                                    this._drag_start_timer = setTimeout(z(function() {
                                        l.getState().lightbox || this.dragStart(u, g, v)
                                    }, this), l.config.touch_drag)) : this.dragStart(u, g, v))))
                        }, this), f);
                        var b = document.body;
                        l.event(b, v.up, z(function(g) {
                            v.accessor(g) && this.clearDragTimer()
                        }, this), f)
                    }, this)(_[y])
            }
            return c.prototype = {
                traceDragEvents: function(u, h) {
                    var _ = z(function(m) {
                        return this.dragMove(u, m, h.accessor)
                    }, this);
                    z(function(m) {
                        return this.dragScroll(u, m)
                    }, this);
                    var f = z(function(m) {
                        if (!this.config.started || !U(this.config.updates_per_second) || Sn(this, this.config.updates_per_second)) {
                            var p = _(m);
                            if (p)
                                try {
                                    m && m.preventDefault && m.cancelable && m.preventDefault()
                                } catch {}
                            return p
                        }
                    }, this)
                        , y = Ct(l.$root)
                        , v = this.config.mousemoveContainer || Ct(l.$root)
                        , b = {
                        passive: !1
                    }
                        , g = z(function(m) {
                        return l.eventRemove(v, h.move, f),
                            l.eventRemove(y, h.up, g, b),
                            this.dragEnd(u)
                    }, this);
                    l.event(v, h.move, f, b),
                        l.event(y, h.up, g, b)
                },
                checkPositionChange: function(u) {
                    var h = u.x - this.config.pos.x
                        , _ = u.y - this.config.pos.y;
                    return Math.sqrt(Math.pow(Math.abs(h), 2) + Math.pow(Math.abs(_), 2)) > this.config.sensitivity
                },
                initDnDMarker: function() {
                    var u = this.config.marker = document.createElement("div");
                    u.className = "gantt_drag_marker",
                        u.innerHTML = "",
                        document.body.appendChild(u)
                },
                backupEventTarget: function(u, h) {
                    if (l.config.touch) {
                        var _ = h(u)
                            , f = _.target || _.srcElement
                            , y = f.cloneNode(!0);
                        this.config.original_target = d(_),
                            this.config.original_target.target = y,
                            this.config.backup_element = f,
                            f.parentNode.appendChild(y),
                            f.style.display = "none",
                            (this.config.mousemoveContainer || document.body).appendChild(f)
                    }
                },
                getInputMethods: function() {
                    var u = [];
                    if (u.push({
                        move: "mousemove",
                        down: "mousedown",
                        up: "mouseup",
                        accessor: function(_) {
                            return _
                        }
                    }),
                        l.config.touch) {
                        var h = !0;
                        try {
                            document.createEvent("TouchEvent")
                        } catch {
                            h = !1
                        }
                        h ? u.push({
                            move: "touchmove",
                            down: "touchstart",
                            up: "touchend",
                            accessor: function(_) {
                                return _.touches && _.touches.length > 1 ? null : _.touches[0] ? {
                                    target: document.elementFromPoint(_.touches[0].clientX, _.touches[0].clientY),
                                    pageX: _.touches[0].pageX,
                                    pageY: _.touches[0].pageY,
                                    clientX: _.touches[0].clientX,
                                    clientY: _.touches[0].clientY
                                } : _
                            }
                        }) : J.navigator.pointerEnabled ? u.push({
                            move: "pointermove",
                            down: "pointerdown",
                            up: "pointerup",
                            accessor: function(_) {
                                return _.pointerType == "mouse" ? null : _
                            }
                        }) : J.navigator.msPointerEnabled && u.push({
                            move: "MSPointerMove",
                            down: "MSPointerDown",
                            up: "MSPointerUp",
                            accessor: function(_) {
                                return _.pointerType == _.MSPOINTER_TYPE_MOUSE ? null : _
                            }
                        })
                    }
                    return u
                },
                clearDragTimer: function() {
                    this._drag_start_timer && (clearTimeout(this._drag_start_timer),
                        this._drag_start_timer = null)
                },
                dragStart: function(u, h, _) {
                    this.config && this.config.started || (this.config = {
                        obj: u,
                        marker: null,
                        started: !1,
                        pos: this.getPosition(h),
                        sensitivity: 4
                    },
                    this._settings && O(this.config, this._settings, !0),
                        this.traceDragEvents(u, _),
                        l._prevent_touch_scroll = !0,
                    h.target.closest(".gantt_row") && !l.config.order_branch && (l._prevent_touch_scroll = !1),
                        document.body.classList.add("gantt_noselect"),
                    l.config.touch && this.dragMove(u, h, _.accessor))
                },
                dragMove: function(u, h, _) {
                    var f = _(h);
                    if (!f)
                        return !1;
                    if (!this.config.marker && !this.config.started) {
                        var y = this.getPosition(f);
                        if (l.config.touch || this.checkPositionChange(y)) {
                            if (this.config.started = !0,
                                this.config.ignore = !1,
                                l._touch_drag = !0,
                            this.callEvent("onBeforeDragStart", [u, this.config.original_target]) === !1)
                                return this.config.ignore = !0,
                                    !1;
                            this.backupEventTarget(h, _),
                                this.initDnDMarker(),
                                l._touch_feedback(),
                                this.callEvent("onAfterDragStart", [u, this.config.original_target])
                        } else
                            this.config.ignore = !0
                    }
                    return this.config.ignore ? !1 : h.targetTouches && !f.target ? void 0 : (f.pos = this.getPosition(f),
                        this.config.marker.style.left = f.pos.x + "px",
                        this.config.marker.style.top = f.pos.y + "px",
                        this.callEvent("onDragMove", [u, f]),
                        !0)
                },
                dragEnd: function(u) {
                    var h = this.config.backup_element;
                    h && h.parentNode && h.parentNode.removeChild(h),
                        l._prevent_touch_scroll = !1,
                    this.config.marker && (this.config.marker.parentNode.removeChild(this.config.marker),
                        this.config.marker = null,
                        this.callEvent("onDragEnd", [])),
                        this.config.started = !1,
                        l._touch_drag = !1,
                        document.body.classList.remove("gantt_noselect")
                },
                getPosition: function(u) {
                    var h = 0
                        , _ = 0;
                    return u.pageX || u.pageY ? (h = u.pageX,
                        _ = u.pageY) : (u.clientX || u.clientY) && (h = u.clientX + document.body.scrollLeft + document.documentElement.scrollLeft,
                        _ = u.clientY + document.body.scrollTop + document.documentElement.scrollTop),
                        {
                            x: h,
                            y: _
                        }
                }
            },
                c
        }(n);
        n.$services.setService("dnd", function() {
            return a
        });
        var r = function(l) {
            var d = {};
            function c(u, h, _) {
                _ = _ || u;
                var f = l.config
                    , y = l.templates;
                l.config[u] && d[_] != f[u] && (h && y[_] || (y[_] = l.date.date_to_str(f[u]),
                    d[_] = f[u]))
            }
            return {
                initTemplates: function() {
                    var u = l.date
                        , h = u.date_to_str
                        , _ = l.config
                        , f = h(_.xml_date || _.date_format, _.server_utc)
                        , y = u.str_to_date(_.xml_date || _.date_format, _.server_utc);
                    c("date_scale", !0, void 0, l.config, l.templates),
                        c("date_grid", !0, "grid_date_format", l.config, l.templates),
                        c("task_date", !0, void 0, l.config, l.templates),
                        l.mixin(l.templates, {
                            xml_format: void 0,
                            format_date: f,
                            xml_date: void 0,
                            parse_date: y,
                            progress_text: function(v, b, g) {
                                return ""
                            },
                            grid_header_class: function(v, b) {
                                return ""
                            },
                            task_text: function(v, b, g) {
                                return g.text
                            },
                            task_class: function(v, b, g) {
                                return ""
                            },
                            task_end_date: function(v) {
                                return l.templates.task_date(v)
                            },
                            grid_row_class: function(v, b, g) {
                                return ""
                            },
                            task_row_class: function(v, b, g) {
                                return ""
                            },
                            timeline_cell_class: function(v, b) {
                                return ""
                            },
                            timeline_cell_content: function(v, b) {
                                return ""
                            },
                            scale_cell_class: function(v) {
                                return ""
                            },
                            scale_row_class: function(v) {
                                return ""
                            },
                            grid_indent: function(v) {
                                return "<div class='gantt_tree_indent'></div>"
                            },
                            grid_folder: function(v) {
                                return "<div class='gantt_tree_icon gantt_folder_" + (v.$open ? "open" : "closed") + "'></div>"
                            },
                            grid_file: function(v) {
                                return "<div class='gantt_tree_icon gantt_file'></div>"
                            },
                            grid_open: function(v) {
                                return "<div class='gantt_tree_icon gantt_" + (v.$open ? "close" : "open") + "'></div>"
                            },
                            grid_blank: function(v) {
                                return "<div class='gantt_tree_icon gantt_blank'></div>"
                            },
                            date_grid: function(v, b, g) {
                                return b && l.isUnscheduledTask(b) && l.config.show_unscheduled ? l.templates.task_unscheduled_time(b) : l.templates.grid_date_format(v, g)
                            },
                            task_time: function(v, b, g) {
                                return l.isUnscheduledTask(g) && l.config.show_unscheduled ? l.templates.task_unscheduled_time(g) : l.templates.task_date(v) + " - " + l.templates.task_end_date(b)
                            },
                            task_unscheduled_time: function(v) {
                                return ""
                            },
                            time_picker: h(_.time_picker),
                            link_class: function(v) {
                                return ""
                            },
                            link_description: function(v) {
                                var b = l.getTask(v.source)
                                    , g = l.getTask(v.target);
                                return "<b>" + b.text + "</b> &ndash;  <b>" + g.text + "</b>"
                            },
                            drag_link: function(v, b, g, m) {
                                v = l.getTask(v);
                                var p = l.locale.labels
                                    , k = "<b>" + v.text + "</b> " + (b ? p.link_start : p.link_end) + "<br/>";
                                return g && (k += "<b> " + (g = l.getTask(g)).text + "</b> " + (m ? p.link_start : p.link_end) + "<br/>"),
                                    k
                            },
                            drag_link_class: function(v, b, g, m) {
                                var p = "";
                                return v && g && (p = " " + (l.isLinkAllowed(v, g, b, m) ? "gantt_link_allow" : "gantt_link_deny")),
                                "gantt_link_tooltip" + p
                            },
                            tooltip_date_format: u.date_to_str("%Y-%m-%d"),
                            tooltip_text: function(v, b, g) {
                                return `<div>Task: ${g.text}</div>
				<div>Start date: ${l.templates.tooltip_date_format(v)}</div>
				<div>End date: ${l.templates.tooltip_date_format(b)}</div>`
                            },
                            baseline_text: function(v, b, g) {
                                return ""
                            }
                        })
                },
                initTemplate: c
            }
        }(n);
        n.$services.setService("templateLoader", function() {
            return r
        }),
            ct(n);
        var s = new Ti;
        s.registerProvider("global", function() {
            var l = {
                min_date: n._min_date,
                max_date: n._max_date,
                selected_task: null
            };
            return n.$data && n.$data.tasksStore && (l.selected_task = n.$data.tasksStore.getSelectedId()),
                l
        }),
            n.getState = s.getState,
            n.$services.setService("state", function() {
                return s
            }),
            O(n, vn),
            n.Promise = Ei,
            n.env = kt,
            function(l) {
                var d = Di.create();
                O(l, d);
                var c, u = l.createDatastore({
                    name: "task",
                    type: "treeDatastore",
                    rootId: function() {
                        return l.config.root_id
                    },
                    initItem: z(function(m) {
                        this.defined(m.id) || (m.id = this.uid()),
                        m.start_date && (m.start_date = l.date.parseDate(m.start_date, "parse_date")),
                        m.end_date && (m.end_date = l.date.parseDate(m.end_date, "parse_date"));
                        var p = null;
                        (m.duration || m.duration === 0) && (m.duration = p = 1 * m.duration),
                        p && (m.start_date && !m.end_date ? m.end_date = this.calculateEndDate(m) : !m.start_date && m.end_date && (m.start_date = this.calculateEndDate({
                            start_date: m.end_date,
                            duration: -m.duration,
                            task: m
                        }))),
                        l.config.deadlines !== !1 && m.deadline && (m.deadline = l.date.parseDate(m.deadline, "parse_date")),
                            m.progress = Number(m.progress) || 0,
                        this._isAllowedUnscheduledTask(m) && this._set_default_task_timing(m),
                            this._init_task_timing(m),
                        m.start_date && m.end_date && this.correctTaskWorkTime(m),
                            m.$source = [],
                            m.$target = [];
                        var k = this.$data.tasksStore.getItem(m.id);
                        return k && !U(m.open) && (m.$open = k.$open),
                        m.parent === void 0 && (m.parent = this.config.root_id),
                        m.open && (m.$open = !0),
                            m
                    }, l),
                    getConfig: function() {
                        return l.config
                    }
                }), h = l.createDatastore({
                    name: "link",
                    initItem: z(function(m) {
                        return this.defined(m.id) || (m.id = this.uid()),
                            m
                    }, l)
                });
                function _(m) {
                    var p = l.isTaskVisible(m);
                    if (!p && l.isTaskExists(m)) {
                        var k = l.getParent(m);
                        l.isTaskExists(k) && l.isTaskVisible(k) && (k = l.getTask(k),
                        l.isSplitTask(k) && (p = !0))
                    }
                    return p
                }
                function f(m) {
                    if (l.isTaskExists(m.source)) {
                        var p = l.getTask(m.source);
                        p.$source = p.$source || [],
                        y(m.id, p.$source) && p.$source.push(m.id)
                    }
                    if (l.isTaskExists(m.target)) {
                        var k = l.getTask(m.target);
                        k.$target = k.$target || [],
                        y(m.id, k.$target) && k.$target.push(m.id)
                    }
                }
                function y(m, p) {
                    return p.indexOf(String(m)) === -1 && p.indexOf(Number(m)) === -1
                }
                function v(m) {
                    if (l.isTaskExists(m.source)) {
                        for (var p = l.getTask(m.source), k = 0; k < p.$source.length; k++)
                            if (p.$source[k] == m.id) {
                                p.$source.splice(k, 1);
                                break
                            }
                    }
                    if (l.isTaskExists(m.target)) {
                        var w = l.getTask(m.target);
                        for (k = 0; k < w.$target.length; k++)
                            if (w.$target[k] == m.id) {
                                w.$target.splice(k, 1);
                                break
                            }
                    }
                }
                function b() {
                    for (var m = null, p = l.$data.tasksStore.getItems(), k = 0, w = p.length; k < w; k++)
                        (m = p[k]).$source = [],
                            m.$target = [];
                    var x = l.$data.linksStore.getItems();
                    for (k = 0,
                             w = x.length; k < w; k++)
                        f(x[k])
                }
                function g(m) {
                    var p = m.source
                        , k = m.target;
                    for (var w in m.events)
                        (function(x, $) {
                                p.attachEvent(x, function() {
                                    return k.callEvent($, Array.prototype.slice.call(arguments))
                                }, $)
                            }
                        )(w, m.events[w])
                }
                l.attachEvent("onDestroy", function() {
                    u.destructor(),
                        h.destructor()
                }),
                    l.attachEvent("onLinkValidation", function(m) {
                        if (l.isLinkExists(m.id) || m.id === "predecessor_generated")
                            return !0;
                        for (var p = l.getTask(m.source).$source, k = 0; k < p.length; k++) {
                            var w = l.getLink(p[k])
                                , x = m.source == w.source
                                , $ = m.target == w.target
                                , S = m.type == w.type;
                            if (x && $ && S)
                                return !1
                        }
                        return !0
                    }),
                    u.attachEvent("onBeforeRefreshAll", function() {
                        if (!u._skipTaskRecalculation)
                            for (var m = u.getVisibleItems(), p = 0; p < m.length; p++) {
                                var k = m[p];
                                k.$index = p,
                                    k.$local_index = l.getTaskIndex(k.id),
                                    l.resetProjectDates(k)
                            }
                    }),
                    u.attachEvent("onFilterItem", function(m, p) {
                        if (l.config.show_tasks_outside_timescale)
                            return !0;
                        var k = null
                            , w = null;
                        if (l.config.start_date && l.config.end_date) {
                            if (l._isAllowedUnscheduledTask(p))
                                return !0;
                            if (k = l.config.start_date.valueOf(),
                                w = l.config.end_date.valueOf(),
                            +p.start_date > w || +p.end_date < +k)
                                return !1
                        }
                        return !0
                    }),
                    u.attachEvent("onIdChange", function(m, p) {
                        l._update_flags(m, p);
                        var k = l.getTask(p);
                        u.isSilent() || (k.$split_subtask || k.rollup) && l.eachParent(function(w) {
                            l.refreshTask(w.id)
                        }, p)
                    }),
                    u.attachEvent("onAfterUpdate", function(m) {
                        if (l._update_parents(m),
                            l.getState("batchUpdate").batch_update)
                            return !0;
                        var p = u.getItem(m);
                        p.$source || (p.$source = []);
                        for (var k = 0; k < p.$source.length; k++)
                            h.refresh(p.$source[k]);
                        for (p.$target || (p.$target = []),
                                 k = 0; k < p.$target.length; k++)
                            h.refresh(p.$target[k])
                    }),
                    u.attachEvent("onBeforeItemMove", function(m, p, k) {
                        return !jt(m, l, u) || (console.log("The placeholder task cannot be moved to another position."),
                            !1)
                    }),
                    u.attachEvent("onAfterItemMove", function(m, p, k) {
                        var w = l.getTask(m);
                        this.getNextSibling(m) !== null ? w.$drop_target = this.getNextSibling(m) : this.getPrevSibling(m) !== null ? w.$drop_target = "next:" + this.getPrevSibling(m) : w.$drop_target = "next:null"
                    }),
                    u.attachEvent("onStoreUpdated", function(m, p, k) {
                        if (k == "delete" && l._update_flags(m, null),
                            !l.$services.getService("state").getState("batchUpdate").batch_update) {
                            if (l.config.fit_tasks && k !== "paint") {
                                var w = l.getState();
                                De(l);
                                var x = l.getState();
                                if (+w.min_date != +x.min_date || +w.max_date != +x.max_date)
                                    return l.render(),
                                        l.callEvent("onScaleAdjusted", []),
                                        !0
                            }
                            k == "add" || k == "move" || k == "delete" ? l.$layout && (this.$config.name != "task" || k != "add" && k != "delete" || this._skipTaskRecalculation != "lightbox" && (this._skipTaskRecalculation = !0),
                                l.$layout.resize()) : m || h.refresh()
                        }
                    }),
                    h.attachEvent("onAfterAdd", function(m, p) {
                        f(p)
                    }),
                    h.attachEvent("onAfterUpdate", function(m, p) {
                        b()
                    }),
                    h.attachEvent("onAfterDelete", function(m, p) {
                        v(p)
                    }),
                    h.attachEvent("onAfterSilentDelete", function(m, p) {
                        v(p)
                    }),
                    h.attachEvent("onBeforeIdChange", function(m, p) {
                        v(l.mixin({
                            id: m
                        }, l.$data.linksStore.getItem(p))),
                            f(l.$data.linksStore.getItem(p))
                    }),
                    h.attachEvent("onFilterItem", function(m, p) {
                        if (!l.config.show_links)
                            return !1;
                        var k = _(p.source)
                            , w = _(p.target);
                        return !(!k || !w || l._isAllowedUnscheduledTask(l.getTask(p.source)) || l._isAllowedUnscheduledTask(l.getTask(p.target))) && l.callEvent("onBeforeLinkDisplay", [m, p])
                    }),
                    c = {},
                    l.attachEvent("onBeforeTaskDelete", function(m, p) {
                        return c[m] = Ae.getSubtreeLinks(l, m),
                            !0
                    }),
                    l.attachEvent("onAfterTaskDelete", function(m, p) {
                        c[m] && l.$data.linksStore.silent(function() {
                            for (var k in c[m])
                                l.isLinkExists(k) && l.$data.linksStore.removeItem(k),
                                    v(c[m][k]);
                            c[m] = null
                        })
                    }),
                    l.attachEvent("onAfterLinkDelete", function(m, p) {
                        l.isTaskExists(p.source) && l.refreshTask(p.source),
                        l.isTaskExists(p.target) && l.refreshTask(p.target)
                    }),
                    l.attachEvent("onParse", b),
                    g({
                        source: h,
                        target: l,
                        events: {
                            onItemLoading: "onLinkLoading",
                            onBeforeAdd: "onBeforeLinkAdd",
                            onAfterAdd: "onAfterLinkAdd",
                            onBeforeUpdate: "onBeforeLinkUpdate",
                            onAfterUpdate: "onAfterLinkUpdate",
                            onBeforeDelete: "onBeforeLinkDelete",
                            onAfterDelete: "onAfterLinkDelete",
                            onIdChange: "onLinkIdChange"
                        }
                    }),
                    g({
                        source: u,
                        target: l,
                        events: {
                            onItemLoading: "onTaskLoading",
                            onBeforeAdd: "onBeforeTaskAdd",
                            onAfterAdd: "onAfterTaskAdd",
                            onBeforeUpdate: "onBeforeTaskUpdate",
                            onAfterUpdate: "onAfterTaskUpdate",
                            onBeforeDelete: "onBeforeTaskDelete",
                            onAfterDelete: "onAfterTaskDelete",
                            onIdChange: "onTaskIdChange",
                            onBeforeItemMove: "onBeforeTaskMove",
                            onAfterItemMove: "onAfterTaskMove",
                            onFilterItem: "onBeforeTaskDisplay",
                            onItemOpen: "onTaskOpened",
                            onItemClose: "onTaskClosed",
                            onBeforeSelect: "onBeforeTaskSelected",
                            onAfterSelect: "onTaskSelected",
                            onAfterUnselect: "onTaskUnselected"
                        }
                    }),
                    l.$data = {
                        tasksStore: u,
                        linksStore: h
                    }
            }(n),
            n.dataProcessor = Ii,
            n.createDataProcessor = Li,
            function(l) {
                l.ext || (l.ext = {});
                for (var d = [Pi, Ri, Oi, Bi, zi, ji, Fi, Wi, Vi], c = 0; c < d.length; c++)
                    d[c] && d[c](l)
            }(n),
            function(l) {
                (function(d) {
                        d.getGridColumn = function(c) {
                            for (var u = d.config.columns, h = 0; h < u.length; h++)
                                if (u[h].name == c)
                                    return u[h];
                            return null
                        }
                            ,
                            d.getGridColumns = function() {
                                return d.config.columns.slice()
                            }
                    }
                )(l),
                    ne.prototype.getGridColumns = function() {
                        for (var d = this.$getConfig().columns, c = [], u = 0; u < d.length; u++)
                            d[u].hide || c.push(d[u]);
                        return c
                    }
            }(n),
            function(l) {
                l.isReadonly = function(d) {
                    return typeof d != "number" && typeof d != "string" || !l.isTaskExists(d) || (d = l.getTask(d)),
                    (!d || !d[this.config.editable_property]) && (d && d[this.config.readonly_property] || this.config.readonly)
                }
            }(n),
            qi(n),
            function(l) {
                var d = new On(l)
                    , c = new Bn(d);
                O(l, ta(d, c))
            }(n),
            ea(n),
            function(l) {
                l.getTaskType = function(d) {
                    var c = d;
                    for (var u in d && typeof d == "object" && (c = d.type),
                        this.config.types)
                        if (this.config.types[u] == c)
                            return c;
                    return l.config.types.task
                }
            }(n),
            function(l) {
                function d() {
                    return l._cached_functions.update_if_changed(l),
                    l._cached_functions.active || l._cached_functions.activate(),
                        !0
                }
                l._cached_functions = {
                    cache: {},
                    mode: !1,
                    critical_path_mode: !1,
                    wrap_methods: function(u, h) {
                        if (h._prefetch_originals)
                            for (var _ in h._prefetch_originals)
                                h[_] = h._prefetch_originals[_];
                        for (h._prefetch_originals = {},
                                 _ = 0; _ < u.length; _++)
                            this.prefetch(u[_], h)
                    },
                    prefetch: function(u, h) {
                        var _ = h[u];
                        if (_) {
                            var f = this;
                            h._prefetch_originals[u] = _,
                                h[u] = function() {
                                    for (var y = new Array(arguments.length), v = 0, b = arguments.length; v < b; v++)
                                        y[v] = arguments[v];
                                    if (f.active) {
                                        var g = f.get_arguments_hash(Array.prototype.slice.call(y));
                                        f.cache[u] || (f.cache[u] = {});
                                        var m = f.cache[u];
                                        if (f.has_cached_value(m, g))
                                            return f.get_cached_value(m, g);
                                        var p = _.apply(this, y);
                                        return f.cache_value(m, g, p),
                                            p
                                    }
                                    return _.apply(this, y)
                                }
                        }
                        return _
                    },
                    cache_value: function(u, h, _) {
                        this.is_date(_) && (_ = new Date(_)),
                            u[h] = _
                    },
                    has_cached_value: function(u, h) {
                        return u.hasOwnProperty(h)
                    },
                    get_cached_value: function(u, h) {
                        var _ = u[h];
                        return this.is_date(_) && (_ = new Date(_)),
                            _
                    },
                    is_date: function(u) {
                        return u && u.getUTCDate
                    },
                    get_arguments_hash: function(u) {
                        for (var h = [], _ = 0; _ < u.length; _++)
                            h.push(this.stringify_argument(u[_]));
                        return "(" + h.join(";") + ")"
                    },
                    stringify_argument: function(u) {
                        return (u.id ? u.id : this.is_date(u) ? u.valueOf() : u) + ""
                    },
                    activate: function() {
                        this.clear(),
                            this.active = !0
                    },
                    deactivate: function() {
                        this.clear(),
                            this.active = !1
                    },
                    clear: function() {
                        this.cache = {}
                    },
                    setup: function(u) {
                        var h = []
                            , _ = ["_isProjectEnd", "_getProjectEnd", "_getSlack"];
                        this.mode == "auto" ? u.config.highlight_critical_path && (h = _) : this.mode === !0 && (h = _),
                            this.wrap_methods(h, u)
                    },
                    update_if_changed: function(u) {
                        (this.critical_path_mode != u.config.highlight_critical_path || this.mode !== u.config.optimize_render) && (this.critical_path_mode = u.config.highlight_critical_path,
                            this.mode = u.config.optimize_render,
                            this.setup(u))
                    }
                },
                    l.attachEvent("onBeforeGanttRender", d),
                    l.attachEvent("onBeforeDataRender", d),
                    l.attachEvent("onBeforeSmartRender", function() {
                        d()
                    }),
                    l.attachEvent("onBeforeParse", d),
                    l.attachEvent("onDataRender", function() {
                        l._cached_functions.deactivate()
                    });
                var c = null;
                l.attachEvent("onSmartRender", function() {
                    c && clearTimeout(c),
                        c = setTimeout(function() {
                            l._cached_functions.deactivate()
                        }, 1e3)
                }),
                    l.attachEvent("onBeforeGanttReady", function() {
                        return l._cached_functions.update_if_changed(l),
                            !0
                    })
            }(n),
            na(n),
            function(l) {
                l.destructor = function() {
                    for (var d in this.clearAll(),
                        this.callEvent("onDestroy", []),
                        this._getDatastores().forEach(function(c) {
                            c.destructor()
                        }),
                    this.$root && delete this.$root.gantt,
                    this._eventRemoveAll && this._eventRemoveAll(),
                    this.$layout && this.$layout.destructor(),
                    this.resetLightbox && this.resetLightbox(),
                    this.ext.inlineEditors && this.ext.inlineEditors.destructor && this.ext.inlineEditors.destructor(),
                    this._dp && this._dp.destructor && this._dp.destructor(),
                        this.$services.destructor(),
                        this.detachAllEvents(),
                        this)
                        d.indexOf("$") === 0 && delete this[d];
                    this.$destroyed = !0
                }
            }(n);
        var o = new xa({
            en: ua,
            ar: ia,
            be: aa,
            ca: ra,
            cn: sa,
            cs: oa,
            da: la,
            de: da,
            el: ca,
            es: ha,
            fa: _a,
            fi: ga,
            fr: fa,
            he: pa,
            hr: ma,
            hu: va,
            id: ka,
            it: ya,
            jp: ba,
            kr: $a,
            nb: wa,
            nl: Sa,
            no: Ta,
            pl: Ea,
            pt: Ca,
            ro: Da,
            ru: Aa,
            si: Ma,
            sk: Ia,
            sv: La,
            tr: Na,
            ua: Pa
        });
        return n.i18n = {
            addLocale: o.addLocale,
            setLocale: function(l) {
                if (typeof l == "string") {
                    var d = o.getLocale(l);
                    d || (d = o.getLocale("en")),
                        n.locale = d
                } else if (l)
                    if (n.locale)
                        for (var c in l)
                            l[c] && typeof l[c] == "object" ? (n.locale[c] || (n.locale[c] = {}),
                                n.mixin(n.locale[c], l[c], !0)) : n.locale[c] = l[c];
                    else
                        n.locale = l;
                const u = n.locale.labels;
                u.gantt_save_btn = u.gantt_save_btn || u.icon_save,
                    u.gantt_cancel_btn = u.gantt_cancel_btn || u.icon_cancel,
                    u.gantt_delete_btn = u.gantt_delete_btn || u.icon_delete
            },
            getLocale: o.getLocale
        },
            n.i18n.setLocale("en"),
            n
    }
    function Oa(t) {
        var n = "data-dhxbox"
            , e = null;
        function i(g, m) {
            var p = g.callback;
            y.hide(g.box),
                e = g.box = null,
            p && p(m)
        }
        function a(g) {
            if (e) {
                var m = g.which || g.keyCode
                    , p = !1;
                if (v.keyboard) {
                    if (m == 13 || m == 32) {
                        var k = g.target || g.srcElement;
                        it(k).indexOf("gantt_popup_button") > -1 && k.click ? k.click() : (i(e, !0),
                            p = !0)
                    }
                    m == 27 && (i(e, !1),
                        p = !0)
                }
                return p ? (g.preventDefault && g.preventDefault(),
                    !(g.cancelBubble = !0)) : void 0
            }
        }
        var r = Ct(t.$root) || document;
        function s(g) {
            s.cover || (s.cover = document.createElement("div"),
                s.cover.onkeydown = a,
                s.cover.className = "dhx_modal_cover",
                document.body.appendChild(s.cover)),
                s.cover.style.display = g ? "inline-block" : "none"
        }
        function o(g, m, p) {
            return "<div " + t._waiAria.messageButtonAttrString(g) + " class='gantt_popup_button " + ("gantt_" + m.toLowerCase().replace(/ /g, "_") + "_button") + "' data-result='" + p + "' result='" + p + "' ><div>" + g + "</div></div>"
        }
        function l() {
            for (var g = [].slice.apply(arguments, [0]), m = 0; m < g.length; m++)
                if (g[m])
                    return g[m]
        }
        function d(g, m, p) {
            var k = g.tagName ? g : function($, S, T) {
                var E = document.createElement("div")
                    , C = ut();
                t._waiAria.messageModalAttr(E, C),
                    E.className = " gantt_modal_box gantt-" + $.type,
                    E.setAttribute(n, 1);
                var D = "";
                if ($.width && (E.style.width = $.width),
                $.height && (E.style.height = $.height),
                $.title && (D += '<div class="gantt_popup_title">' + $.title + "</div>"),
                    D += '<div class="gantt_popup_text" id="' + C + '"><span>' + ($.content ? "" : $.text) + '</span></div><div  class="gantt_popup_controls">',
                S && (D += o(l($.ok, t.locale.labels.message_ok, "OK"), "ok", !0)),
                T && (D += o(l($.cancel, t.locale.labels.message_cancel, "Cancel"), "cancel", !1)),
                    $.buttons)
                    for (var A = 0; A < $.buttons.length; A++) {
                        var I = $.buttons[A];
                        D += typeof I == "object" ? o(I.label, I.css || "gantt_" + I.label.toLowerCase() + "_button", I.value || A) : o(I, I, A)
                    }
                if (D += "</div>",
                    E.innerHTML = D,
                    $.content) {
                    var M = $.content;
                    typeof M == "string" && (M = document.getElementById(M)),
                    M.style.display == "none" && (M.style.display = ""),
                        E.childNodes[$.title ? 1 : 0].appendChild(M)
                }
                return E.onclick = function(L) {
                    var N = L.target || L.srcElement;
                    if (N.className || (N = N.parentNode),
                        dt(N, ".gantt_popup_button")) {
                        var P = N.getAttribute("data-result");
                        i($, P = P == "true" || P != "false" && P)
                    }
                }
                    ,
                    $.box = E,
                (S || T) && (e = $),
                    E
            }(g, m, p);
            g.hidden || s(!0),
                document.body.appendChild(k);
            var w = Math.abs(Math.floor(((window.innerWidth || document.documentElement.offsetWidth) - k.offsetWidth) / 2))
                , x = Math.abs(Math.floor(((window.innerHeight || document.documentElement.offsetHeight) - k.offsetHeight) / 2));
            return g.position == "top" ? k.style.top = "-3px" : k.style.top = x + "px",
                k.style.left = w + "px",
                k.onkeydown = a,
                y.focus(k),
            g.hidden && y.hide(k),
                t.callEvent("onMessagePopup", [k]),
                k
        }
        function c(g) {
            return d(g, !0, !1)
        }
        function u(g) {
            return d(g, !0, !0)
        }
        function h(g) {
            return d(g)
        }
        function _(g, m, p) {
            return typeof g != "object" && (typeof m == "function" && (p = m,
                m = ""),
                g = {
                    text: g,
                    type: m,
                    callback: p
                }),
                g
        }
        function f(g, m, p, k) {
            return typeof g != "object" && (g = {
                text: g,
                type: m,
                expire: p,
                id: k
            }),
                g.id = g.id || ut(),
                g.expire = g.expire || v.expire,
                g
        }
        t.event(r, "keydown", a, !0);
        var y = function() {
            var g = _.apply(this, arguments);
            return g.type = g.type || "alert",
                h(g)
        };
        y.hide = function(g) {
            for (; g && g.getAttribute && !g.getAttribute(n); )
                g = g.parentNode;
            g && (g.parentNode.removeChild(g),
                s(!1),
                t.callEvent("onAfterMessagePopup", [g]))
        }
            ,
            y.focus = function(g) {
                setTimeout(function() {
                    var m = zt(g);
                    m.length && m[0].focus && m[0].focus()
                }, 1)
            }
        ;
        var v = function(g, m, p, k) {
            switch ((g = f.apply(this, arguments)).type = g.type || "info",
                g.type.split("-")[0]) {
                case "alert":
                    return c(g);
                case "confirm":
                    return u(g);
                case "modalbox":
                    return h(g);
                default:
                    return function(w) {
                        v.area || (v.area = document.createElement("div"),
                            v.area.className = "gantt_message_area",
                            v.area.style[v.position] = "5px"),
                        tt(v.area, document.body) || document.body.appendChild(v.area),
                            v.hide(w.id);
                        var x = document.createElement("div");
                        return x.innerHTML = "<div>" + w.text + "</div>",
                            x.className = "gantt-info gantt-" + w.type,
                            x.onclick = function() {
                                v.hide(w.id),
                                    w = null
                            }
                            ,
                            t._waiAria.messageInfoAttr(x),
                            v.position == "bottom" && v.area.firstChild ? v.area.insertBefore(x, v.area.firstChild) : v.area.appendChild(x),
                        w.expire > 0 && (v.timers[w.id] = window.setTimeout(function() {
                            v && v.hide(w.id)
                        }, w.expire)),
                            v.pull[w.id] = x,
                            x = null,
                            w.id
                    }(g)
            }
        };
        v.seed = new Date().valueOf(),
            v.uid = ut,
            v.expire = 4e3,
            v.keyboard = !0,
            v.position = "top",
            v.pull = {},
            v.timers = {},
            v.hideAll = function() {
                for (var g in v.pull)
                    v.hide(g)
            }
            ,
            v.hide = function(g) {
                var m = v.pull[g];
                m && m.parentNode && (window.setTimeout(function() {
                    m.parentNode.removeChild(m),
                        m = null
                }, 2e3),
                    m.className += " hidden",
                v.timers[g] && window.clearTimeout(v.timers[g]),
                    delete v.pull[g])
            }
        ;
        var b = [];
        return t.attachEvent("onMessagePopup", function(g) {
            b.push(g)
        }),
            t.attachEvent("onAfterMessagePopup", function(g) {
                for (var m = 0; m < b.length; m++)
                    b[m] === g && (b.splice(m, 1),
                        m--)
            }),
            t.attachEvent("onDestroy", function() {
                s.cover && s.cover.parentNode && s.cover.parentNode.removeChild(s.cover);
                for (var g = 0; g < b.length; g++)
                    b[g].parentNode && b[g].parentNode.removeChild(b[g]);
                b = null,
                v.area && v.area.parentNode && v.area.parentNode.removeChild(v.area),
                    v = null
            }),
            {
                alert: function() {
                    var g = _.apply(this, arguments);
                    return g.type = g.type || "confirm",
                        c(g)
                },
                confirm: function() {
                    var g = _.apply(this, arguments);
                    return g.type = g.type || "alert",
                        u(g)
                },
                message: v,
                modalbox: y
            }
    }
    function Fn(t, n) {
        var e = this.$config[t];
        return e ? (e.$extendedConfig || (e.$extendedConfig = !0,
            Object.setPrototypeOf(e, n)),
            e) : n
    }
    function Ba(t, n) {
        var e, i, a;
        O(t, (e = n,
            {
                $getConfig: function() {
                    return i || (i = e ? e.$getConfig() : this.$gantt.config),
                        this.$config.config ? Fn.call(this, "config", i) : i
                },
                $getTemplates: function() {
                    return a || (a = e ? e.$getTemplates() : this.$gantt.templates),
                        this.$config.templates ? Fn.call(this, "templates", a) : a
                }
            }))
    }
    const za = function(t) {
        var n = {}
            , e = {};
        function i(a, r, s, o) {
            var l = n[a];
            if (!l || !l.create)
                return !1;
            a != "resizer" || s.mode || (o.$config.cols ? s.mode = "x" : s.mode = "y"),
            a != "viewcell" || s.view != "scrollbar" || s.scroll || (o.$config.cols ? s.scroll = "y" : s.scroll = "x"),
            (s = X(s)).id || e[s.view] || (s.id = s.view),
            s.id && !s.css && (s.css = s.id + "_cell");
            var d = new l.create(r,s,this,t);
            return l.configure && l.configure(d),
                Ba(d, o),
            d.$id || (d.$id = s.id || t.uid()),
            d.$parent || typeof r != "object" || (d.$parent = r),
            d.$config || (d.$config = s),
            e[d.$id] && (d.$id = t.uid()),
                e[d.$id] = d,
                d
        }
        return {
            initUI: function(a, r) {
                var s = "cell";
                return a.view ? s = "viewcell" : a.resizer ? s = "resizer" : a.rows || a.cols ? s = "layout" : a.views && (s = "multiview"),
                    i.call(this, s, null, a, r)
            },
            reset: function() {
                e = {}
            },
            registerView: function(a, r, s) {
                n[a] = {
                    create: r,
                    configure: s
                }
            },
            createView: i,
            getView: function(a) {
                return e[a]
            }
        }
    };
    var ja = function(t) {
        return function(n) {
            var e = {
                click: {},
                doubleclick: {},
                contextMenu: {}
            };
            function i(h, _, f, y) {
                e[h][_] || (e[h][_] = []),
                    e[h][_].push({
                        handler: f,
                        root: y
                    })
            }
            function a(h) {
                h = h || window.event;
                var _ = n.locate(h)
                    , f = s(h, e.click)
                    , y = !0;
                if (_ !== null ? y = !n.checkEvent("onTaskClick") || n.callEvent("onTaskClick", [_, h]) : n.callEvent("onEmptyClick", [h]),
                    y) {
                    if (!o(f, h, _))
                        return;
                    switch (h.target.nodeName) {
                        case "SELECT":
                        case "INPUT":
                            return
                    }
                    _ && n.getTask(_) && !n._multiselect && n.config.select_task && n.selectTask(_)
                }
            }
            function r(h) {
                var _ = (h = h || window.event).target || h.srcElement
                    , f = n.locate(_)
                    , y = n.locate(_, n.config.link_attribute)
                    , v = !n.checkEvent("onContextMenu") || n.callEvent("onContextMenu", [f, y, h]);
                return v || (h.preventDefault ? h.preventDefault() : h.returnValue = !1),
                    v
            }
            function s(h, _) {
                for (var f = h.target || h.srcElement, y = []; f; ) {
                    var v = t.getClassName(f);
                    if (v) {
                        v = v.split(" ");
                        for (var b = 0; b < v.length; b++)
                            if (v[b] && _[v[b]])
                                for (var g = _[v[b]], m = 0; m < g.length; m++)
                                    g[m].root && !t.isChildOf(f, g[m].root) || y.push(g[m].handler)
                    }
                    f = f.parentNode
                }
                return y
            }
            function o(h, _, f) {
                for (var y = !0, v = 0; v < h.length; v++) {
                    var b = h[v].call(n, _, f, _.target || _.srcElement);
                    y = y && !(b !== void 0 && b !== !0)
                }
                return y
            }
            function l(h) {
                h = h || window.event;
                var _ = n.locate(h)
                    , f = s(h, e.doubleclick)
                    , y = !n.checkEvent("onTaskDblClick") || _ === null || n.callEvent("onTaskDblClick", [_, h]);
                if (y) {
                    if (!o(f, h, _))
                        return;
                    _ !== null && n.getTask(_) && y && n.config.details_on_dblclick && !n.isReadonly(_) && n.showLightbox(_)
                }
            }
            function d(h) {
                if (n.checkEvent("onMouseMove")) {
                    var _ = n.locate(h);
                    n._last_move_event = h,
                        n.callEvent("onMouseMove", [_, h])
                }
            }
            var c = n._createDomEventScope();
            function u(h) {
                c.detachAll(),
                h && (c.attach(h, "click", a),
                    c.attach(h, "dblclick", l),
                    c.attach(h, "mousemove", d),
                    c.attach(h, "contextmenu", r))
            }
            return {
                reset: u,
                global: function(h, _, f) {
                    i(h, _, f, null)
                },
                delegate: i,
                detach: function(h, _, f, y) {
                    if (e[h] && e[h][_]) {
                        for (var v = e[h], b = v[_], g = 0; g < b.length; g++)
                            b[g].root == y && (b.splice(g, 1),
                                g--);
                        b.length || delete v[_]
                    }
                },
                callHandler: function(h, _, f, y) {
                    var v = e[h][_];
                    if (v)
                        for (var b = 0; b < v.length; b++)
                            (f || v[b].root) && v[b].root !== f || v[b].handler.apply(this, y)
                },
                onDoubleClick: l,
                onMouseMove: d,
                onContextMenu: r,
                onClick: a,
                destructor: function() {
                    u(),
                        e = null,
                        c = null
                }
            }
        }
    }(gn);
    const Fa = {
        init: ja
    };
    function Wn(t, n, e) {
        return !!n && !(n.left > t.x_end || n.left + n.width < t.x) && !(n.top > t.y_end || n.top + n.height < t.y)
    }
    function Vt(t) {
        return t.config.smart_rendering && t._smart_render
    }
    function ae(t, n, e) {
        return {
            top: n.getItemTop(t.id),
            height: n.getItemHeight(t.id),
            left: 0,
            right: 1 / 0
        }
    }
    function et(t, n, e, i, a) {
        var r = n.getItemIndexByTopPosition(a.y) || 0
            , s = n.getItemIndexByTopPosition(a.y_end) || i.count()
            , o = Math.max(0, r - 1)
            , l = Math.min(i.count(), s + 1);
        const d = [];
        if (t.config.keyboard_navigation && t.getSelectedId()) {
            let c = t.getTask(t.getSelectedId());
            c.$expanded_branch && !c.$split_subtask && d.push(t.getSelectedId())
        }
        if (t.$ui.getView("grid") && t.ext.inlineEditors && t.ext.inlineEditors.getState().id) {
            let c = t.ext.inlineEditors.getState().id;
            i.exists(c) && d.push(c)
        }
        return {
            start: o,
            end: l,
            ids: d
        }
    }
    var Wa = function(t) {
        var n = function(e) {
            var i = {}
                , a = {};
            function r(o) {
                var l = null;
                return typeof o.view == "string" ? l = e.$ui.getView(o.view) : o.view && (l = o.view),
                    l
            }
            function s(o, l, d) {
                if (a[o])
                    return a[o];
                l.renderer || e.assert(!1, "Invalid renderer call");
                var c = null
                    , u = null
                    , h = null
                    , _ = null
                    , f = null;
                typeof l.renderer == "function" ? (c = l.renderer,
                    h = ae) : (c = l.renderer.render,
                    u = l.renderer.update,
                    _ = l.renderer.onrender,
                    l.renderer.isInViewPort ? f = l.renderer.isInViewPort : h = l.renderer.getRectangle,
                h || h === null || (h = ae));
                var y = l.filter;
                return d && d.setAttribute(e.config.layer_attribute, !0),
                    a[o] = {
                        render_item: function(v, b, g, m, p) {
                            if (b = b || d,
                            !y || y(v)) {
                                var k = m || r(l)
                                    , w = p || (k ? k.$getConfig() : null)
                                    , x = g;
                                !x && w && w.smart_rendering && (x = k.getViewPort());
                                var $ = null;
                                !Vt(e) && (h || f) && x ? (f ? f(v, x, k, w, e) : Wn(x, h(v, k, w, e))) && ($ = c.call(e, v, k, w, x)) : $ = c.call(e, v, k, w, x),
                                    this.append(v, $, b);
                                var S = b.nodeType == 11;
                                _ && !S && $ && _.call(e, v, $, k)
                            } else
                                this.remove_item(v.id)
                        },
                        clear: function(v) {
                            this.rendered = i[o] = {},
                            l.append || this.clear_container(v)
                        },
                        clear_container: function(v) {
                            (v = v || d) && (v.innerHTML = "")
                        },
                        get_visible_range: function(v) {
                            var b, g, m = r(l), p = m ? m.$getConfig() : null;
                            return p && p.smart_rendering && (b = m.getViewPort()),
                            m && b && (typeof l.renderer == "function" ? g = et(e, m, 0, v, b) : l.renderer && l.renderer.getVisibleRange && (g = l.renderer.getVisibleRange(e, m, p, v, b))),
                            g || (g = {
                                start: 0,
                                end: v.count()
                            }),
                                g
                        },
                        prepare_data: function(v) {
                            if (l.renderer && l.renderer.prepareData)
                                return l.renderer.prepareData(v, e, l)
                        },
                        render_items: function(v, b) {
                            b = b || d;
                            var g = document.createDocumentFragment();
                            this.clear(b);
                            var m = null
                                , p = r(l)
                                , k = p ? p.$getConfig() : null;
                            k && k.smart_rendering && (m = p.getViewPort());
                            for (var w = 0, x = v.length; w < x; w++)
                                this.render_item(v[w], g, m, p, k);
                            b.appendChild(g, b);
                            var $ = {};
                            v.forEach(function(E) {
                                $[E.id] = E
                            });
                            var S = {};
                            if (_) {
                                var T = {};
                                for (var w in this.rendered)
                                    S[w] || (T[w] = this.rendered[w],
                                        _.call(e, $[w], this.rendered[w], p))
                            }
                        },
                        update_items: function(v, b) {
                            var g = r(l)
                                , m = g ? g.$getConfig() : null;
                            if (g && g.$getConfig().smart_rendering && !Vt(e) && this.rendered && (h || f)) {
                                b = b || d;
                                var p = document.createDocumentFragment()
                                    , k = null;
                                g && (k = g.getViewPort());
                                var w = {};
                                v.forEach(function(I) {
                                    w[I.id] = I
                                });
                                var x = {}
                                    , $ = {};
                                for (var S in this.rendered)
                                    $[S] = !0,
                                        x[S] = !0;
                                for (var T = {}, E = (S = 0,
                                    v.length); S < E; S++) {
                                    var C = v[S]
                                        , D = this.rendered[C.id];
                                    $[C.id] = !1,
                                        D && D.parentNode ? (f ? f(C, k, g, m, e) : Wn(k, h(C, g, m, e))) ? (u && u.call(e, C, D, g, m, k),
                                            this.restore(C, p)) : $[C.id] = !0 : (T[v[S].id] = !0,
                                            this.render_item(v[S], p, k, g, m))
                                }
                                for (var S in $)
                                    $[S] && this.hide(S);
                                if (p.childNodes.length && b.appendChild(p, b),
                                    _) {
                                    var A = {};
                                    for (var S in this.rendered)
                                        x[S] && !T[S] || (A[S] = this.rendered[S],
                                            _.call(e, w[S], this.rendered[S], g))
                                }
                            }
                        },
                        append: function(v, b, g) {
                            this.rendered && (b ? (this.rendered[v.id] && this.rendered[v.id].parentNode ? this.replace_item(v.id, b) : g.appendChild(b),
                                this.rendered[v.id] = b) : this.rendered[v.id] && this.remove_item(v.id))
                        },
                        replace_item: function(v, b) {
                            var g = this.rendered[v];
                            g && g.parentNode && g.parentNode.replaceChild(b, g),
                                this.rendered[v] = b
                        },
                        remove_item: function(v) {
                            this.hide(v),
                                delete this.rendered[v]
                        },
                        hide: function(v) {
                            var b = this.rendered[v];
                            b && b.parentNode && b.parentNode.removeChild(b),
                                delete this.rendered[v]
                        },
                        restore: function(v, b) {
                            var g = this.rendered[v.id];
                            g ? g.parentNode || this.append(v, g, b || d) : this.render_item(v, b || d)
                        },
                        change_id: function(v, b) {
                            this.rendered[b] = this.rendered[v],
                                delete this.rendered[v]
                        },
                        rendered: i[o],
                        node: d,
                        destructor: function() {
                            this.clear(),
                                delete a[o],
                                delete i[o]
                        }
                    },
                    a[o]
            }
            return {
                getRenderer: s,
                clearRenderers: function() {
                    for (var o in a)
                        s(o).destructor()
                }
            }
        }(t);
        return {
            createGroup: function(e, i, a, r) {
                var s = {
                    tempCollection: [],
                    renderers: {},
                    container: e,
                    filters: [],
                    getLayers: function() {
                        this._add();
                        var o = [];
                        for (var l in this.renderers)
                            o.push(this.renderers[l]);
                        return o
                    },
                    getLayer: function(o) {
                        return this.renderers[o]
                    },
                    _add: function(o) {
                        o && (o.id = o.id || ut(),
                            this.tempCollection.push(o));
                        const l = this.container()
                            , d = this.tempCollection;
                        for (let c = 0; c < d.length; c++) {
                            if (o = d[c],
                                !(this.container() || o && o.container && o.container.isConnected))
                                continue;
                            let u = o.container
                                , h = o.id
                                , _ = o.topmost;
                            if (!u.parentNode)
                                if (_)
                                    l.appendChild(u);
                                else {
                                    let f = i ? i() : l.firstChild;
                                    f && f.parentNode == l ? l.insertBefore(u, f) : l.appendChild(u)
                                }
                            this.renderers[h] = n.getRenderer(h, o, u),
                            r && r(o, t),
                                this.tempCollection.splice(c, 1),
                                c--
                        }
                    },
                    addLayer: function(o) {
                        if (o) {
                            typeof o == "function" && (o = {
                                renderer: o
                            }),
                                o.filter === void 0 ? o.filter = Vn(a || []) : o.filter instanceof Array && (o.filter.push(a),
                                    o.filter = Vn(o.filter)),
                            o.container || (o.container = document.createElement("div"));
                            var l = this;
                            o.requestUpdate = function() {
                                t.config.smart_rendering && !Vt(t) && l.renderers[o.id] && l.onUpdateRequest(l.renderers[o.id])
                            }
                        }
                        return this._add(o),
                            o ? o.id : void 0
                    },
                    onUpdateRequest: function(o) {},
                    eachLayer: function(o) {
                        for (var l in this.renderers)
                            o(this.renderers[l])
                    },
                    removeLayer: function(o) {
                        this.renderers[o] && (this.renderers[o].destructor(),
                            delete this.renderers[o])
                    },
                    clear: function() {
                        for (var o in this.renderers)
                            this.renderers[o].destructor();
                        this.renderers = {}
                    }
                };
                return t.attachEvent("onDestroy", function() {
                    s.clear(),
                        s = null
                }),
                    s
            }
        }
    };
    function Vn(t) {
        return t instanceof Array || (t = Array.prototype.slice.call(arguments, 0)),
            function(n) {
                for (var e = !0, i = 0, a = t.length; i < a; i++) {
                    var r = t[i];
                    r && (e = e && r(n.id, n) !== !1)
                }
                return e
            }
    }
    function Un(t, n, e) {
        if (!t.start_date || !t.end_date)
            return null;
        var i = n.posFromDate(t.start_date)
            , a = n.posFromDate(t.end_date)
            , r = Math.min(i, a) - 200
            , s = Math.max(i, a) + 200;
        return {
            top: n.getItemTop(t.id),
            height: n.getItemHeight(t.id),
            left: r,
            width: s - r
        }
    }
    function Gn() {
        var t = []
            , n = !1;
        function e() {
            t = [],
                n = !1
        }
        function i(r, s, o) {
            s.$getConfig(),
                r.getVisibleItems().forEach(function(l) {
                    var d = function(c, u, h, _) {
                        if (!_.isTaskExists(c.source) || !_.isTaskExists(c.target))
                            return null;
                        var f = Un(_.getTask(c.source), u)
                            , y = Un(_.getTask(c.target), u);
                        if (!f || !y)
                            return null;
                        var v = 100
                            , b = Math.min(f.left, y.left) - v
                            , g = Math.max(f.left + f.width, y.left + y.width) + v
                            , m = Math.min(f.top, y.top) - v
                            , p = Math.max(f.top + f.height, y.top + y.height) + v;
                        return {
                            top: m,
                            height: p - m,
                            bottom: p,
                            left: b,
                            width: g - b,
                            right: g
                        }
                    }(l, s, 0, o);
                    d && t.push({
                        id: l.id,
                        rec: d
                    })
                }),
                t.sort(function(l, d) {
                    return l.rec.right < d.rec.right ? -1 : 1
                }),
                n = !0
        }
        var a = !1;
        return function(r, s, o, l, d) {
            (function(f) {
                    a || (a = !0,
                        f.attachEvent("onPreFilter", e),
                        f.attachEvent("onStoreUpdated", e),
                        f.attachEvent("onClearAll", e),
                        f.attachEvent("onBeforeStoreUpdate", e))
                }
            )(l),
            n || i(l, s, r);
            for (var c = [], u = 0; u < t.length; u++) {
                var h = t[u]
                    , _ = h.rec;
                _.right < d.x || _.left < d.x_end && _.right > d.x && _.top < d.y_end && _.bottom > d.y && c.push(h.id)
            }
            return {
                ids: c
            }
        }
    }
    function qn(t, n, e, i, a) {
        var r = e.$gantt.getTask(t.source)
            , s = e.$gantt.getTask(t.target)
            , o = e.getItemTop(r.id)
            , l = e.getItemHeight(r.id)
            , d = e.getItemTop(s.id)
            , c = e.getItemHeight(s.id);
        if (n.y > o + l && n.y > d + c || n.y_end < d && n.y_end < o)
            return !1;
        var u = e.posFromDate(r.start_date)
            , h = e.posFromDate(r.end_date)
            , _ = e.posFromDate(s.start_date)
            , f = e.posFromDate(s.end_date);
        if (u > h) {
            var y = h;
            h = u,
                u = y
        }
        return _ > f && (y = f,
            f = _,
            _ = y),
            u += -100,
            h += 100,
            _ += -100,
            f += 100,
        !(n.x > h && n.x > f) && !(n.x_end < u && n.x_end < _)
    }
    function Va(t, n) {
        if (t.view) {
            var e = t.view;
            typeof e == "string" && (e = n.$ui.getView(e)),
            e && e.attachEvent && e.attachEvent("onScroll", function() {
                n.$services.getService("state").getState("batchUpdate").batch_update || e.$config.$skipSmartRenderOnScroll || t.requestUpdate && t.requestUpdate()
            })
        }
    }
    var xt = function() {
        function t(n, e, i, a) {
            n && (this.$container = ye(n),
                this.$parent = n),
                this.$config = O(e, {
                    headerHeight: 33
                }),
                this.$gantt = a,
                this.$domEvents = a._createDomEventScope(),
                this.$id = e.id || "c" + ut(),
                this.$name = "cell",
                this.$factory = i,
                this.$externalComponent = null,
                ct(this)
        }
        return t.prototype.destructor = function() {
            this.$parent = this.$container = this.$view = null,
                this.$gantt.$services.getService("mouseEvents").detach("click", "gantt_header_arrow", this._headerClickHandler),
                this.$domEvents.detachAll(),
                this.callEvent("onDestroy", []),
                this.detachAllEvents()
        }
            ,
            t.prototype.cell = function(n) {
                return null
            }
            ,
            t.prototype.scrollTo = function(n, e) {
                var i = this.$view;
                this.$config.html && (i = this.$view.firstChild),
                1 * n == n && (i.scrollLeft = n),
                1 * e == e && (i.scrollTop = e)
            }
            ,
            t.prototype.clear = function() {
                this.getNode().innerHTML = "",
                    this.getNode().className = "gantt_layout_content",
                    this.getNode().style.padding = "0"
            }
            ,
            t.prototype.resize = function(n) {
                if (this.$parent)
                    return this.$parent.resize(n);
                n === !1 && (this.$preResize = !0);
                var e = this.$container
                    , i = e.offsetWidth
                    , a = e.offsetHeight
                    , r = this.getSize();
                e === document.body && (i = document.body.offsetWidth,
                    a = document.body.offsetHeight),
                i < r.minWidth && (i = r.minWidth),
                i > r.maxWidth && (i = r.maxWidth),
                a < r.minHeight && (a = r.minHeight),
                a > r.maxHeight && (a = r.maxHeight),
                    this.setSize(i, a),
                    this.$preResize,
                    this.$preResize = !1
            }
            ,
            t.prototype.hide = function() {
                this._hide(!0),
                    this.resize()
            }
            ,
            t.prototype.show = function(n) {
                this._hide(!1),
                n && this.$parent && this.$parent.show(),
                    this.resize()
            }
            ,
            t.prototype._hide = function(n) {
                if (n === !0 && this.$view.parentNode)
                    this.$view.parentNode.removeChild(this.$view);
                else if (n === !1 && !this.$view.parentNode) {
                    var e = this.$parent.cellIndex(this.$id);
                    this.$parent.moveView(this, e)
                }
                this.$config.hidden = n
            }
            ,
            t.prototype.$toHTML = function(n, e) {
                n === void 0 && (n = ""),
                    e = [e || "", this.$config.css || ""].join(" ");
                var i = this.$config
                    , a = "";
                if (i.raw)
                    n = typeof i.raw == "string" ? i.raw : "";
                else {
                    if (!n) {
                        let r = null;
                        r = typeof i.html == "function" ? i.html() : i.html,
                        this.$gantt.config.external_render && this.$gantt.config.external_render.isElement(r) && (this.$externalComponent = r,
                            r = null),
                            n = "<div class='gantt_layout_content' " + (e ? " class='" + e + "' " : "") + " >" + (r || "") + "</div>"
                    }
                    i.header && (a = "<div class='gantt_layout_header'>" + (i.canCollapse ? "<div class='gantt_layout_header_arrow'></div>" : "") + "<div class='gantt_layout_header_content'>" + i.header + "</div></div>")
                }
                return "<div class='gantt_layout_cell " + e + "' data-cell-id='" + this.$id + "'>" + a + n + "</div>"
            }
            ,
            t.prototype.$fill = function(n, e) {
                this.$view = n,
                    this.$parent = e,
                    this.init()
            }
            ,
            t.prototype.getNode = function() {
                return this.$view.querySelector("gantt_layout_cell") || this.$view
            }
            ,
            t.prototype.init = function() {
                var n = this;
                this._headerClickHandler = function(e) {
                    Q(e, "data-cell-id") == n.$id && n.toggle()
                }
                    ,
                    this.$gantt.$services.getService("mouseEvents").delegate("click", "gantt_header_arrow", this._headerClickHandler),
                    this.callEvent("onReady", [])
            }
            ,
            t.prototype.toggle = function() {
                this.$config.collapsed = !this.$config.collapsed,
                    this.resize()
            }
            ,
            t.prototype.getSize = function() {
                var n = {
                    height: this.$config.height || 0,
                    width: this.$config.width || 0,
                    gravity: this.$config.gravity || 1,
                    minHeight: this.$config.minHeight || 0,
                    minWidth: this.$config.minWidth || 0,
                    maxHeight: this.$config.maxHeight || 1e11,
                    maxWidth: this.$config.maxWidth || 1e11
                };
                if (this.$config.collapsed) {
                    var e = this.$config.mode === "x";
                    n[e ? "width" : "height"] = n[e ? "maxWidth" : "maxHeight"] = this.$config.headerHeight
                }
                return n
            }
            ,
            t.prototype.getContentSize = function() {
                var n = this.$lastSize.contentX;
                n !== 1 * n && (n = this.$lastSize.width);
                var e = this.$lastSize.contentY;
                return e !== 1 * e && (e = this.$lastSize.height),
                    {
                        width: n,
                        height: e
                    }
            }
            ,
            t.prototype._getBorderSizes = function() {
                var n = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0,
                    horizontal: 0,
                    vertical: 0
                };
                return this._currentBorders && (this._currentBorders[this._borders.left] && (n.left = 1,
                    n.horizontal++),
                this._currentBorders[this._borders.right] && (n.right = 1,
                    n.horizontal++),
                this._currentBorders[this._borders.top] && (n.top = 1,
                    n.vertical++),
                this._currentBorders[this._borders.bottom] && (n.bottom = 1,
                    n.vertical++)),
                    n
            }
            ,
            t.prototype.setSize = function(n, e) {
                this.$view.style.width = n + "px",
                    this.$view.style.height = e + "px";
                var i = this._getBorderSizes()
                    , a = e - i.vertical
                    , r = n - i.horizontal;
                this.$lastSize = {
                    x: n,
                    y: e,
                    contentX: r,
                    contentY: a
                },
                    this.$config.header ? this._sizeHeader() : this._sizeContent()
            }
            ,
            t.prototype._borders = {
                left: "gantt_layout_cell_border_left",
                right: "gantt_layout_cell_border_right",
                top: "gantt_layout_cell_border_top",
                bottom: "gantt_layout_cell_border_bottom"
            },
            t.prototype._setBorders = function(n, e) {
                e || (e = this);
                var i = e.$view;
                for (var a in this._borders)
                    Pt(i, this._borders[a]);
                typeof n == "string" && (n = [n]);
                var r = {};
                for (a = 0; a < n.length; a++)
                    $t(i, n[a]),
                        r[n[a]] = !0;
                e._currentBorders = r
            }
            ,
            t.prototype._sizeContent = function() {
                var n = this.$view.childNodes[0];
                n && n.className == "gantt_layout_content" && (n.style.height = this.$lastSize.contentY + "px")
            }
            ,
            t.prototype._sizeHeader = function() {
                var n = this.$lastSize;
                n.contentY -= this.$config.headerHeight;
                var e = this.$view.childNodes[0]
                    , i = this.$view.childNodes[1]
                    , a = this.$config.mode === "x";
                if (this.$config.collapsed)
                    if (i.style.display = "none",
                        a) {
                        e.className = "gantt_layout_header collapsed_x",
                            e.style.width = n.y + "px";
                        var r = Math.floor(n.y / 2 - n.x / 2);
                        e.style.transform = "rotate(90deg) translate(" + r + "px, " + r + "px)",
                            i.style.display = "none"
                    } else
                        e.className = "gantt_layout_header collapsed_y";
                else
                    e.className = a ? "gantt_layout_header" : "gantt_layout_header vertical",
                        e.style.width = "auto",
                        e.style.transform = "",
                        i.style.display = "",
                        i.style.height = n.contentY + "px";
                e.style.height = this.$config.headerHeight + "px"
            }
            ,
            t
    }();
    function W(t, n) {
        for (var e in n)
            n.hasOwnProperty(e) && (t[e] = n[e]);
        function i() {
            this.constructor = t
        }
        t.prototype = n === null ? Object.create(n) : (i.prototype = n.prototype,
            new i)
    }
    var Yn = function(t) {
        function n(e, i, a) {
            var r = t.apply(this, arguments) || this;
            return e && (r.$root = !0),
                r._parseConfig(i),
                r.$name = "layout",
                r
        }
        return W(n, t),
            n.prototype.destructor = function() {
                this.$container && this.$view && dn(this.$view);
                for (var e = 0; e < this.$cells.length; e++)
                    this.$cells[e].destructor();
                this.$cells = [],
                    t.prototype.destructor.call(this)
            }
            ,
            n.prototype._resizeScrollbars = function(e, i) {
                var a = !1
                    , r = []
                    , s = [];
                const o = [];
                function l(f) {
                    f.$parent.show(),
                        a = !0,
                        r.push(f)
                }
                function d(f) {
                    f.$parent.hide(),
                        a = !0,
                        s.push(f)
                }
                for (var c, u = 0; u < i.length; u++)
                    e[(c = i[u]).$config.scroll] ? d(c) : c.shouldHide() ? o.push(c) : c.shouldShow() ? l(c) : c.isVisible() ? r.push(c) : s.push(c);
                var h = {};
                for (u = 0; u < r.length; u++)
                    r[u].$config.group && (h[r[u].$config.group] = !0);
                for (o.forEach(function(f) {
                    f.$config.group && h[f.$config.group] || d(f)
                }),
                         u = 0; u < s.length; u++)
                    if ((c = s[u]).$config.group && h[c.$config.group]) {
                        l(c);
                        for (var _ = 0; _ < r.length; _++)
                            if (r[_] == c) {
                                this.$gantt.$scrollbarRepaint = !0;
                                break
                            }
                    }
                return a
            }
            ,
            n.prototype.getScrollbarsInfo = function() {
                const e = this.getCellsByType("scroller")
                    , i = [];
                return e.forEach(a => {
                        let r = {};
                        const {visible: s, direction: o, size: l, scrollSize: d, position: c} = a.getScrollState();
                        let u = a._getLinkedViews().map(h => h.$config.id);
                        r.id = a.$id,
                            r.visible = s,
                            r.boundViews = u,
                            o === "x" ? (r.x = l,
                                r.x_inner = d,
                                r.x_pos = c || 0) : (r.y = l,
                                r.y_inner = d,
                                r.y_pos = c || 0),
                            i.push(r)
                    }
                ),
                    i
            }
            ,
            n.prototype._syncCellSizes = function(e, i) {
                if (e) {
                    var a = {};
                    return this._eachChild(function(r) {
                        r.$config.group && r.$name != "scrollbar" && r.$name != "resizer" && (a[r.$config.group] || (a[r.$config.group] = []),
                            a[r.$config.group].push(r))
                    }),
                    a[e] && this._syncGroupSize(a[e], i),
                        a[e]
                }
            }
            ,
            n.prototype._syncGroupSize = function(e, i) {
                if (e.length)
                    for (var a = e[0].$parent._xLayout ? "width" : "height", r = e[0].$parent.getNextSibling(e[0].$id) ? 1 : -1, s = i.value, o = i.isGravity, l = 0; l < e.length; l++) {
                        var d = e[l].getSize()
                            , c = r > 0 ? e[l].$parent.getNextSibling(e[l].$id) : e[l].$parent.getPrevSibling(e[l].$id);
                        c.$name == "resizer" && (c = r > 0 ? c.$parent.getNextSibling(c.$id) : c.$parent.getPrevSibling(c.$id));
                        var u = c.getSize();
                        if (o)
                            e[l].$config.gravity = s;
                        else if (c[a]) {
                            var h = d.gravity + u.gravity
                                , _ = d[a] + u[a]
                                , f = h / _;
                            e[l].$config.gravity = f * s,
                                c.$config[a] = _ - s,
                                c.$config.gravity = h - f * s
                        } else
                            e[l].$config[a] = s;
                        var y = this.$gantt.$ui.getView("grid");
                        !y || e[l].$content !== y || y.$config.scrollable || o || (this.$gantt.config.grid_width = s)
                    }
            }
            ,
            n.prototype.resize = function(e) {
                var i = !1;
                if (this.$root && !this._resizeInProgress && (this.callEvent("onBeforeResize", []),
                    i = !0,
                    this._resizeInProgress = !0),
                    t.prototype.resize.call(this, !0),
                    t.prototype.resize.call(this, !1),
                    i) {
                    var a = [];
                    a = (a = (a = a.concat(this.getCellsByType("viewCell"))).concat(this.getCellsByType("viewLayout"))).concat(this.getCellsByType("hostCell"));
                    for (var r = this.getCellsByType("scroller"), s = 0; s < a.length; s++)
                        a[s].$config.hidden || a[s].setContentSize();
                    var o = this._getAutosizeMode(this.$config.autosize)
                        , l = this._resizeScrollbars(o, r);
                    if (this.$config.autosize && (this.autosize(this.$config.autosize),
                        a.forEach(function(d) {
                            const c = d.$parent
                                , u = c.getContentSize(o);
                            o.x && (c.$config.$originalWidthStored || (c.$config.$originalWidthStored = !0,
                                c.$config.$originalWidth = c.$config.width),
                                c.$config.width = u.width),
                            o.y && (c.$config.$originalHeightStored || (c.$config.$originalHeightStored = !0,
                                c.$config.$originalHeight = c.$config.height),
                                c.$config.height = u.height)
                        }),
                        l = !0),
                        l)
                        for (this.resize(),
                                 s = 0; s < a.length; s++)
                            a[s].$config.hidden || a[s].setContentSize();
                    this.callEvent("onResize", [])
                }
                i && (this._resizeInProgress = !1)
            }
            ,
            n.prototype._eachChild = function(e, i) {
                if (e(i = i || this),
                    i.$cells)
                    for (var a = 0; a < i.$cells.length; a++)
                        this._eachChild(e, i.$cells[a])
            }
            ,
            n.prototype.isChild = function(e) {
                var i = !1;
                return this._eachChild(function(a) {
                    a !== e && a.$content !== e || (i = !0)
                }),
                    i
            }
            ,
            n.prototype.getCellsByType = function(e) {
                var i = [];
                if (e === this.$name && i.push(this),
                this.$content && this.$content.$name == e && i.push(this.$content),
                    this.$cells)
                    for (var a = 0; a < this.$cells.length; a++) {
                        var r = n.prototype.getCellsByType.call(this.$cells[a], e);
                        r.length && i.push.apply(i, r)
                    }
                return i
            }
            ,
            n.prototype.getNextSibling = function(e) {
                var i = this.cellIndex(e);
                return i >= 0 && this.$cells[i + 1] ? this.$cells[i + 1] : null
            }
            ,
            n.prototype.getPrevSibling = function(e) {
                var i = this.cellIndex(e);
                return i >= 0 && this.$cells[i - 1] ? this.$cells[i - 1] : null
            }
            ,
            n.prototype.cell = function(e) {
                for (var i = 0; i < this.$cells.length; i++) {
                    var a = this.$cells[i];
                    if (a.$id === e)
                        return a;
                    var r = a.cell(e);
                    if (r)
                        return r
                }
            }
            ,
            n.prototype.cellIndex = function(e) {
                for (var i = 0; i < this.$cells.length; i++)
                    if (this.$cells[i].$id === e)
                        return i;
                return -1
            }
            ,
            n.prototype.moveView = function(e, i) {
                if (this.$cells[i] !== e)
                    return window.alert("Not implemented");
                i += this.$config.header ? 1 : 0;
                var a = this.$view;
                i >= a.childNodes.length ? a.appendChild(e.$view) : a.insertBefore(e.$view, a.childNodes[i])
            }
            ,
            n.prototype._parseConfig = function(e) {
                this.$cells = [],
                    this._xLayout = !e.rows;
                for (var i = e.rows || e.cols || e.views, a = 0; a < i.length; a++) {
                    var r = i[a];
                    r.mode = this._xLayout ? "x" : "y";
                    var s = this.$factory.initUI(r, this);
                    s ? (s.$parent = this,
                        this.$cells.push(s)) : (i.splice(a, 1),
                        a--)
                }
            }
            ,
            n.prototype.getCells = function() {
                return this.$cells
            }
            ,
            n.prototype.render = function() {
                var e = ln(this.$container, this.$toHTML());
                this.$fill(e, null);
                const i = this.$gantt;
                this._eachChild(a => {
                        a.$externalComponent && (i.config.external_render.renderElement(a.$externalComponent, a.$view.querySelector(".gantt_layout_content")),
                            a.$externalComponent = null)
                    }
                ),
                    this.callEvent("onReady", []),
                    this.resize(),
                    this.render = this.resize
            }
            ,
            n.prototype.$fill = function(e, i) {
                this.$view = e,
                    this.$parent = i;
                for (var a = cn(e, "gantt_layout_cell"), r = a.length - 1; r >= 0; r--) {
                    var s = this.$cells[r];
                    s.$fill(a[r], this),
                    s.$config.hidden && s.$view.parentNode.removeChild(s.$view)
                }
            }
            ,
            n.prototype.$toHTML = function() {
                for (var e = this._xLayout ? "x" : "y", i = [], a = 0; a < this.$cells.length; a++)
                    i.push(this.$cells[a].$toHTML());
                return t.prototype.$toHTML.call(this, i.join(""), (this.$root ? "gantt_layout_root " : "") + "gantt_layout gantt_layout_" + e)
            }
            ,
            n.prototype.getContentSize = function(e) {
                for (var i, a, r, s = 0, o = 0, l = 0; l < this.$cells.length; l++)
                    (a = this.$cells[l]).$config.hidden || (i = a.getContentSize(e),
                    a.$config.view === "scrollbar" && e[a.$config.scroll] && (i.height = 0,
                        i.width = 0),
                    a.$config.resizer && (this._xLayout ? i.height = 0 : i.width = 0),
                        r = a._getBorderSizes(),
                        this._xLayout ? (s += i.width + r.horizontal,
                            o = Math.max(o, i.height + r.vertical)) : (s = Math.max(s, i.width + r.horizontal),
                            o += i.height + r.vertical));
                return {
                    width: s += (r = this._getBorderSizes()).horizontal,
                    height: o += r.vertical
                }
            }
            ,
            n.prototype._cleanElSize = function(e) {
                return 1 * (e || "").toString().replace("px", "") || 0
            }
            ,
            n.prototype._getBoxStyles = function(e) {
                var i = null
                    , a = ["width", "height", "paddingTop", "paddingBottom", "paddingLeft", "paddingRight", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"]
                    , r = {
                    boxSizing: (i = window.getComputedStyle ? window.getComputedStyle(e, null) : {
                        width: e.clientWidth,
                        height: e.clientHeight
                    }).boxSizing == "border-box"
                };
                i.MozBoxSizing && (r.boxSizing = i.MozBoxSizing == "border-box");
                for (var s = 0; s < a.length; s++)
                    r[a[s]] = i[a[s]] ? this._cleanElSize(i[a[s]]) : 0;
                var o = {
                    horPaddings: r.paddingLeft + r.paddingRight + r.borderLeftWidth + r.borderRightWidth,
                    vertPaddings: r.paddingTop + r.paddingBottom + r.borderTopWidth + r.borderBottomWidth,
                    borderBox: r.boxSizing,
                    innerWidth: r.width,
                    innerHeight: r.height,
                    outerWidth: r.width,
                    outerHeight: r.height
                };
                return o.borderBox ? (o.innerWidth -= o.horPaddings,
                    o.innerHeight -= o.vertPaddings) : (o.outerWidth += o.horPaddings,
                    o.outerHeight += o.vertPaddings),
                    o
            }
            ,
            n.prototype._getAutosizeMode = function(e) {
                var i = {
                    x: !1,
                    y: !1
                };
                return e === "xy" ? i.x = i.y = !0 : e === "y" || e === !0 ? i.y = !0 : e === "x" && (i.x = !0),
                    i
            }
            ,
            n.prototype.autosize = function(e) {
                var i = this._getAutosizeMode(e)
                    , a = this._getBoxStyles(this.$container)
                    , r = this.getContentSize(e)
                    , s = this.$container;
                i.x && (a.borderBox && (r.width += a.horPaddings),
                    s.style.width = r.width + "px"),
                i.y && (a.borderBox && (r.height += a.vertPaddings),
                    s.style.height = r.height + "px")
            }
            ,
            n.prototype.getSize = function() {
                this._sizes = [];
                for (var e = 0, i = 0, a = 1e11, r = 0, s = 1e11, o = 0, l = 0; l < this.$cells.length; l++) {
                    var d = this._sizes[l] = this.$cells[l].getSize();
                    this.$cells[l].$config.hidden || (this._xLayout ? (!d.width && d.minWidth ? e += d.minWidth : e += d.width,
                        a += d.maxWidth,
                        i += d.minWidth,
                        r = Math.max(r, d.height),
                        s = Math.min(s, d.maxHeight),
                        o = Math.max(o, d.minHeight)) : (!d.height && d.minHeight ? r += d.minHeight : r += d.height,
                        s += d.maxHeight,
                        o += d.minHeight,
                        e = Math.max(e, d.width),
                        a = Math.min(a, d.maxWidth),
                        i = Math.max(i, d.minWidth)))
                }
                var c = t.prototype.getSize.call(this);
                return c.maxWidth >= 1e5 && (c.maxWidth = a),
                c.maxHeight >= 1e5 && (c.maxHeight = s),
                    c.minWidth = c.minWidth != c.minWidth ? 0 : c.minWidth,
                    c.minHeight = c.minHeight != c.minHeight ? 0 : c.minHeight,
                    this._xLayout ? (c.minWidth += this.$config.margin * this.$cells.length || 0,
                        c.minWidth += 2 * this.$config.padding || 0,
                        c.minHeight += 2 * this.$config.padding || 0) : (c.minHeight += this.$config.margin * this.$cells.length || 0,
                        c.minHeight += 2 * this.$config.padding || 0),
                    c
            }
            ,
            n.prototype._calcFreeSpace = function(e, i, a) {
                var r = a ? i.minWidth : i.minHeight
                    , s = i.maxWidth
                    , o = e;
                return o ? (o > s && (o = s),
                o < r && (o = r),
                    this._free -= o) : ((o = Math.floor(this._free / this._gravity * i.gravity)) > s && (o = s,
                    this._free -= o,
                    this._gravity -= i.gravity),
                o < r && (o = r,
                    this._free -= o,
                    this._gravity -= i.gravity)),
                    o
            }
            ,
            n.prototype._calcSize = function(e, i, a) {
                var r = e
                    , s = a ? i.minWidth : i.minHeight
                    , o = a ? i.maxWidth : i.maxHeight;
                return r || (r = Math.floor(this._free / this._gravity * i.gravity)),
                r > o && (r = o),
                r < s && (r = s),
                    r
            }
            ,
            n.prototype._configureBorders = function() {
                this.$root && this._setBorders([this._borders.left, this._borders.top, this._borders.right, this._borders.bottom], this);
                for (var e = this._xLayout ? this._borders.right : this._borders.bottom, i = this.$cells, a = i.length - 1, r = a; r >= 0; r--)
                    if (!i[r].$config.hidden) {
                        a = r;
                        break
                    }
                for (r = 0; r < i.length; r++)
                    if (!i[r].$config.hidden) {
                        var s = r >= a
                            , o = "";
                        !s && i[r + 1] && i[r + 1].$config.view == "scrollbar" && (this._xLayout ? s = !0 : o = "gantt_layout_cell_border_transparent"),
                            this._setBorders(s ? [] : [e, o], i[r])
                    }
            }
            ,
            n.prototype._updateCellVisibility = function() {
                for (var e = this._visibleCells || {}, i = !this._visibleCells, a = {}, r = null, s = [], o = 0; o < this._sizes.length; o++)
                    (r = this.$cells[o]).$config.hide_empty && s.push(r),
                        !i && r.$config.hidden && e[r.$id] ? r._hide(!0) : r.$config.hidden || e[r.$id] || r._hide(!1),
                    r.$config.hidden || (a[r.$id] = !0);
                for (this._visibleCells = a,
                         o = 0; o < s.length; o++) {
                    var l = (r = s[o]).$cells
                        , d = !0;
                    l.forEach(function(c) {
                        c.$config.hidden || c.$config.resizer || (d = !1)
                    }),
                        r.$config.hidden = d
                }
            }
            ,
            n.prototype.setSize = function(e, i) {
                this._configureBorders(),
                    t.prototype.setSize.call(this, e, i),
                    i = this.$lastSize.contentY,
                    e = this.$lastSize.contentX;
                var a, r, s = this.$config.padding || 0;
                this.$view.style.padding = s + "px",
                    this._gravity = 0,
                    this._free = this._xLayout ? e : i,
                    this._free -= 2 * s,
                    this._updateCellVisibility();
                for (var o = 0; o < this._sizes.length; o++)
                    if (!(a = this.$cells[o]).$config.hidden) {
                        var l = this.$config.margin || 0;
                        a.$name != "resizer" || l || (l = -1);
                        var d = a.$view
                            , c = this._xLayout ? "marginRight" : "marginBottom";
                        o !== this.$cells.length - 1 && (d.style[c] = l + "px",
                            this._free -= l),
                            r = this._sizes[o],
                            this._xLayout ? r.width || (this._gravity += r.gravity) : r.height || (this._gravity += r.gravity)
                    }
                for (o = 0; o < this._sizes.length; o++)
                    if (!(a = this.$cells[o]).$config.hidden) {
                        var u = (r = this._sizes[o]).width
                            , h = r.height;
                        this._xLayout ? this._calcFreeSpace(u, r, !0) : this._calcFreeSpace(h, r, !1)
                    }
                for (o = 0; o < this.$cells.length; o++)
                    if (!(a = this.$cells[o]).$config.hidden) {
                        r = this._sizes[o];
                        var _ = void 0
                            , f = void 0;
                        this._xLayout ? (_ = this._calcSize(r.width, r, !0),
                            f = i - 2 * s) : (_ = e - 2 * s,
                            f = this._calcSize(r.height, r, !1)),
                            a.setSize(_, f)
                    }
            }
            ,
            n
    }(xt)
        , Ua = function(t) {
        function n(e, i, a) {
            for (var r = t.apply(this, arguments) || this, s = 0; s < r.$cells.length; s++)
                r.$cells[s].$config.hidden = s !== 0;
            return r.$cell = r.$cells[0],
                r.$name = "viewLayout",
                r
        }
        return W(n, t),
            n.prototype.cell = function(e) {
                var i = t.prototype.cell.call(this, e);
                return i.$view || this.$fill(null, this),
                    i
            }
            ,
            n.prototype.moveView = function(e) {
                var i = this.$view;
                this.$cell && (this.$cell.$config.hidden = !0,
                    i.removeChild(this.$cell.$view)),
                    this.$cell = e,
                    i.appendChild(e.$view)
            }
            ,
            n.prototype.setSize = function(e, i) {
                xt.prototype.setSize.call(this, e, i)
            }
            ,
            n.prototype.setContentSize = function() {
                var e = this.$lastSize;
                this.$cell.setSize(e.contentX, e.contentY)
            }
            ,
            n.prototype.getSize = function() {
                var e = t.prototype.getSize.call(this);
                if (this.$cell) {
                    var i = this.$cell.getSize();
                    if (this.$config.byMaxSize)
                        for (var a = 0; a < this.$cells.length; a++) {
                            var r = this.$cells[a].getSize();
                            for (var s in i)
                                i[s] = Math.max(i[s], r[s])
                        }
                    for (var o in e)
                        e[o] = e[o] || i[o];
                    e.gravity = Math.max(e.gravity, i.gravity)
                }
                return e
            }
            ,
            n
    }(Yn)
        , Ga = function(t) {
        function n(e, i, a) {
            var r = t.apply(this, arguments) || this;
            if (i.view) {
                i.id && (this.$id = ut());
                var s = X(i);
                if (delete s.config,
                    delete s.templates,
                    this.$content = this.$factory.createView(i.view, this, s, this),
                    !this.$content)
                    return !1
            }
            return r.$name = "viewCell",
                r
        }
        return W(n, t),
            n.prototype.destructor = function() {
                this.clear(),
                    t.prototype.destructor.call(this)
            }
            ,
            n.prototype.clear = function() {
                if (this.$initialized = !1,
                    this.$content) {
                    var e = this.$content.unload || this.$content.destructor;
                    e && e.call(this.$content)
                }
                t.prototype.clear.call(this)
            }
            ,
            n.prototype.scrollTo = function(e, i) {
                this.$content && this.$content.scrollTo ? this.$content.scrollTo(e, i) : t.prototype.scrollTo.call(this, e, i)
            }
            ,
            n.prototype._setContentSize = function(e, i) {
                var a = this._getBorderSizes();
                if (typeof e == "number") {
                    var r = e + a.horizontal;
                    this.$config.width = r
                }
                if (typeof i == "number") {
                    var s = i + a.vertical;
                    this.$config.height = s
                }
            }
            ,
            n.prototype.setSize = function(e, i) {
                if (t.prototype.setSize.call(this, e, i),
                !this.$preResize && this.$content && !this.$initialized) {
                    this.$initialized = !0;
                    var a = this.$view.childNodes[0]
                        , r = this.$view.childNodes[1];
                    r || (r = a),
                        this.$content.init(r)
                }
            }
            ,
            n.prototype.setContentSize = function() {
                !this.$preResize && this.$content && this.$initialized && this.$content.setSize(this.$lastSize.contentX, this.$lastSize.contentY)
            }
            ,
            n.prototype.getContentSize = function() {
                var e = t.prototype.getContentSize.call(this);
                if (this.$content && this.$initialized) {
                    var i = this.$content.getSize();
                    e.width = i.contentX === void 0 ? i.width : i.contentX,
                        e.height = i.contentY === void 0 ? i.height : i.contentY
                }
                var a = this._getBorderSizes();
                return e.width += a.horizontal,
                    e.height += a.vertical,
                    e
            }
            ,
            n
    }(xt)
        , qa = function(t) {
        function n(e, i, a) {
            var r, s, o = t.apply(this, arguments) || this;
            function l(d) {
                var c = d.pageX
                    , u = d.pageY;
                return d.touches && (c = d.touches[0].pageX,
                    u = d.touches[0].pageY),
                    {
                        x: c,
                        y: u
                    }
            }
            return o._moveHandler = function(d) {
                o._moveResizer(o._resizer, l(d).x, l(d).y)
            }
                ,
                o._upHandler = function(d) {
                    var c = o._getNewSizes();
                    o.callEvent("onResizeEnd", [r, s, c ? c.back : 0, c ? c.front : 0]) !== !1 && o._setSizes(),
                        o._setBackground(!1),
                        o._clearResizer(),
                        o._clearListeneres(),
                    d.touches && (o.$gantt._prevent_touch_scroll = !1)
                }
                ,
                o._clearListeneres = function() {
                    this.$domEvents.detach(document, "mouseup", o._upHandler),
                        this.$domEvents.detach(document, "mousemove", o._moveHandler),
                        this.$domEvents.detach(document, "mousemove", o._startOnMove),
                        this.$domEvents.detach(document, "mouseup", o._cancelDND),
                        this.$domEvents.detach(document, "touchend", o._upHandler),
                        this.$domEvents.detach(document, "touchmove", o._startOnMove),
                        this.$domEvents.detach(document, "touchstart", o._downHandler)
                }
                ,
                o._callStartDNDEvent = function() {
                    if (this._xMode ? (r = this._behind.$config.width || this._behind.$view.offsetWidth,
                        s = this._front.$config.width || this._front.$view.offsetWidth) : (r = this._behind.$config.height || this._behind.$view.offsetHeight,
                        s = this._front.$config.height || this._front.$view.offsetHeight),
                    o.callEvent("onResizeStart", [r, s]) === !1)
                        return !1
                }
                ,
                o._startDND = function(d) {
                    if (this._callStartDNDEvent() !== !1) {
                        var c = !1;
                        this._eachGroupItem(function(u) {
                            u._getSiblings(),
                            u._callStartDNDEvent() === !1 && (c = !0)
                        }),
                        c || (o._moveHandler(d),
                            o.$domEvents.attach(document, "mousemove", o._moveHandler),
                            o.$domEvents.attach(document, "mouseup", o._upHandler))
                    }
                }
                ,
                o._cancelDND = function() {
                    o._setBackground(!1),
                        o._clearResizer(),
                        o._clearListeneres()
                }
                ,
                o._startOnMove = function(d) {
                    d.touches && (o.$gantt._touch_drag = !0,
                        o.$gantt._prevent_touch_scroll = !0),
                    o._isPosChanged(d) && (o._clearListeneres(),
                        o._startDND(d))
                }
                ,
                o._downHandler = function(d) {
                    o._getSiblings(),
                    o._behind.$config.collapsed || o._front.$config.collapsed || (o._setBackground(!0),
                        o._resizer = o._setResizer(),
                        o._positions = {
                            x: l(d).x,
                            y: l(d).y,
                            timestamp: Date.now()
                        },
                        o.$domEvents.attach(document, "mousemove", o._startOnMove),
                        o.$domEvents.attach(document, "mouseup", o._cancelDND))
                }
                ,
                o.$name = "resizer",
                o
        }
        return W(n, t),
            n.prototype.init = function() {
                var e = this;
                t.prototype.init.call(this),
                    this._xMode = this.$config.mode === "x",
                    this._xMode && !this.$config.width ? this.$config.width = this.$config.minWidth = 1 : this._xMode || this.$config.height || (this.$config.height = this.$config.minHeight = 1),
                    this.$config.margin = -1,
                    this.$domEvents.attach(this.$view, "mousedown", e._downHandler),
                    this.$domEvents.attach(this.$view, "touchstart", e._downHandler),
                    this.$domEvents.attach(this.$view, "touchmove", e._startOnMove),
                    this.$domEvents.attach(this.$view, "touchend", e._upHandler)
            }
            ,
            n.prototype.$toHTML = function() {
                var e = this.$config.mode
                    , i = this.$config.css || "";
                return "<div class='gantt_layout_cell gantt_resizer gantt_resizer_" + e + "'><div class='gantt_layout_content gantt_resizer_" + e + (i ? " " + i : "") + "'></div></div>"
            }
            ,
            n.prototype._clearResizer = function() {
                this._resizer && (this._resizer.parentNode && this._resizer.parentNode.removeChild(this._resizer),
                    this._resizer = null)
            }
            ,
            n.prototype._isPosChanged = function(e) {
                return !!this._positions && (Math.abs(this._positions.x - e.pageX) > 3 || Math.abs(this._positions.y - e.pageY) > 3 || Date.now() - this._positions.timestamp > 300)
            }
            ,
            n.prototype._getSiblings = function() {
                var e = this.$parent.getCells();
                this.$config.prev && (this._behind = this.$factory.getView(this.$config.prev),
                this._behind instanceof xt || (this._behind = this._behind.$parent)),
                this.$config.next && (this._front = this.$factory.getView(this.$config.next),
                this._front instanceof xt || (this._front = this._behind.$parent));
                for (var i = 0; i < e.length; i++)
                    this === e[i] && (this._behind || (this._behind = e[i - 1]),
                    this._front || (this._front = e[i + 1]))
            }
            ,
            n.prototype._setBackground = function(e) {
                var i = "gantt_resizing";
                if (!e)
                    return Pt(this._behind.$view, i),
                        Pt(this._front.$view, i),
                        void document.body.classList.remove("gantt_noselect");
                $t(this._behind.$view, i),
                    $t(this._front.$view, i),
                    document.body.classList.add("gantt_noselect")
            }
            ,
            n.prototype._setResizer = function() {
                var e = document.createElement("div");
                return e.className = "gantt_resizer_stick",
                    this.$view.appendChild(e),
                    this.$view.style.overflow = "visible",
                    e.style.height = this.$view.style.height,
                    e
            }
            ,
            n.prototype._getDirection = function(e, i) {
                var a;
                return (a = this._xMode ? e - this._positions.x : i - this._positions.y) ? a < 0 ? -1 : 1 : 0
            }
            ,
            n.prototype._getResizePosition = function(e, i) {
                var a, r, s, o, l;
                this._xMode ? (a = e - this._positions.x,
                    r = this._behind.$config.width || this._behind.$view.offsetWidth,
                    o = this._front.$config.width || this._front.$view.offsetWidth,
                    s = this._behind.$config.minWidth,
                    l = this._front.$config.minWidth) : (a = i - this._positions.y,
                    r = this._behind.$config.height || this._behind.$view.offsetHeight,
                    o = this._front.$config.height || this._front.$view.offsetHeight,
                    s = this._front.$config.minHeight,
                    l = this._front.$config.minHeight);
                var d, c, u = this._getDirection(e, i);
                if (u === -1) {
                    if (c = o - a,
                        d = r - Math.abs(a),
                    o - a > this._front.$config.maxWidth)
                        return;
                    Math.abs(a) >= r && (a = -Math.abs(r - 2)),
                    r - Math.abs(a) <= s && (a = -Math.abs(r - s))
                } else
                    c = o - Math.abs(a),
                        d = r + a,
                    r + a > this._behind.$config.maxWidth && (a = this._behind.$config.maxWidth - r),
                    Math.abs(a) >= o && (a = o - 2),
                    o - Math.abs(a) <= l && (a = Math.abs(o - l));
                return u === -1 ? (c = o - a,
                    d = r - Math.abs(a)) : (c = o - Math.abs(a),
                    d = r + a),
                    {
                        size: a,
                        newFrontSide: c,
                        newBehindSide: d
                    }
            }
            ,
            n.prototype._getGroupName = function() {
                return this._getSiblings(),
                this._front.$config.group || this._behind.$config.group
            }
            ,
            n.prototype._eachGroupItem = function(e, i) {
                for (var a = this.$factory.getView("main"), r = this._getGroupName(), s = a.getCellsByType("resizer"), o = 0; o < s.length; o++)
                    s[o]._getGroupName() == r && s[o] != this && e.call(i || this, s[o])
            }
            ,
            n.prototype._getGroupResizePosition = function(e, i) {
                var a = this._getResizePosition(e, i);
                if (!this._getGroupName())
                    return a;
                var r, s = [a];
                this._eachGroupItem(function(l) {
                    l._getSiblings();
                    var d = X(this._positions);
                    this._xMode ? d.x += l._behind.$config.width - this._behind.$config.width : d.y += l._behind.$config.height - this._behind.$config.height,
                        l._positions = d,
                        s.push(l._getResizePosition(e, i))
                });
                for (var o = 0; o < s.length; o++) {
                    if (!s[o])
                        return;
                    (r === void 0 || s[o].newBehindSide > r.newBehindSide) && (r = s[o])
                }
                return r
            }
            ,
            n.prototype._moveResizer = function(e, i, a) {
                if (i !== 0) {
                    var r = this._getGroupResizePosition(i, a);
                    r && Math.abs(r.size) !== 1 && (this._xMode ? (e.style.left = r.size + "px",
                        this._positions.nextX = r.size || 0) : (e.style.top = r.size + "px",
                        this._positions.nextY = r.size || 0),
                        this.callEvent("onResize", [r.newBehindSide, r.newFrontSide]))
                }
            }
            ,
            n.prototype._setGravity = function(e) {
                var i = this._xMode ? "offsetWidth" : "offsetHeight"
                    , a = this._xMode ? this._positions.nextX : this._positions.nextY
                    , r = this._front.$view[i]
                    , s = this._behind.$view[i]
                    , o = (r - a) / r * this._front.getSize().gravity
                    , l = (s + a) / s * this._behind.getSize().gravity;
                e !== "front" && (this._front.$config.gravity = o),
                e !== "behind" && (this._behind.$config.gravity = l)
            }
            ,
            n.prototype._getNewSizes = function() {
                var e, i, a;
                return this._xMode ? (e = this._behind.$config.width,
                    i = this._front.$config.width,
                    a = this._positions.nextX) : (e = this._behind.$config.height,
                    i = this._front.$config.height,
                    a = this._positions.nextY),
                    i || e ? {
                        front: i ? i - a || 1 : 0,
                        back: e ? e + a || 1 : 0
                    } : null
            }
            ,
            n.prototype._assignNewSizes = function(e) {
                this._getSiblings();
                var i = this._xMode ? "width" : "height";
                e ? (e.front ? this._front.$config[i] = e.front : this._setGravity("behind"),
                    e.back ? this._behind.$config[i] = e.back : this._setGravity("front")) : this._setGravity()
            }
            ,
            n.prototype._setSizes = function() {
                this._resizer && this.$view.removeChild(this._resizer);
                var e = this._getNewSizes();
                if (this._positions.nextX || this._positions.nextY) {
                    this._assignNewSizes(e);
                    var i, a = this._xMode ? "width" : "height";
                    e && e.front || this._front.$config.group && (i = {
                        value: this._front.$config.gravity,
                        isGravity: !0
                    },
                        this.$gantt.$layout._syncCellSizes(this._front.$config.group, i)),
                    e && e.back || this._behind.$config.group && (i = {
                        value: this._behind.$config.gravity,
                        isGravity: !0
                    },
                        this.$gantt.$layout._syncCellSizes(this._behind.$config.group, i)),
                    e && (e.front ? this._front.$config.group && (i = {
                        value: this._front.$config[a],
                        isGravity: !1
                    },
                        this.$gantt.$layout._syncCellSizes(this._front.$config.group, i)) : e.back && this._behind.$config.group && (i = {
                        value: this._behind.$config[a],
                        isGravity: !1
                    },
                        this.$gantt.$layout._syncCellSizes(this._behind.$config.group, i))),
                        this._getGroupName() ? this.$factory.getView("main").resize() : this.$parent.resize()
                }
            }
            ,
            n
    }(xt)
        , Ya = function(t) {
        var n = ["altKey", "shiftKey", "metaKey"];
        function e(a, r, s, o) {
            var l = t.apply(this, arguments) || this;
            this.$config = O(r, {
                scroll: "x"
            }),
                l._scrollHorizontalHandler = z(l._scrollHorizontalHandler, l),
                l._scrollVerticalHandler = z(l._scrollVerticalHandler, l),
                l._outerScrollVerticalHandler = z(l._outerScrollVerticalHandler, l),
                l._outerScrollHorizontalHandler = z(l._outerScrollHorizontalHandler, l),
                l._mouseWheelHandler = z(l._mouseWheelHandler, l),
                this.$config.hidden = !0;
            var d = o.config.scroll_size;
            return o.env.isIE && (d += 1),
                this._isHorizontal() ? (l.$config.height = d,
                    l.$parent.$config.height = d) : (l.$config.width = d,
                    l.$parent.$config.width = d),
                this.$config.scrollPosition = 0,
                l.$name = "scroller",
                l
        }
        function i(a, r) {
            if (r.push(a),
                a.$cells)
                for (var s = 0; s < a.$cells.length; s++)
                    i(a.$cells[s], r)
        }
        return W(e, t),
            e.prototype.init = function(a) {
                a.innerHTML = this.$toHTML(),
                    this.$view = a.firstChild,
                this.$view || this.init(),
                    this._isVertical() ? this._initVertical() : this._initHorizontal(),
                    this._initMouseWheel(),
                    this._initLinkedViews()
            }
            ,
            e.prototype.$toHTML = function() {
                return "<div class='gantt_layout_cell " + (this._isHorizontal() ? "gantt_hor_scroll" : "gantt_ver_scroll") + "'><div style='" + (this._isHorizontal() ? "width:2000px" : "height:2000px") + "'></div></div>"
            }
            ,
            e.prototype._getRootParent = function() {
                for (var a = this.$parent; a && a.$parent; )
                    a = a.$parent;
                if (a)
                    return a
            }
            ,
            e.prototype._eachView = function() {
                var a = [];
                return i(this._getRootParent(), a),
                    a
            }
            ,
            e.prototype._getLinkedViews = function() {
                for (var a = this._eachView(), r = [], s = 0; s < a.length; s++)
                    a[s].$config && (this._isVertical() && a[s].$config.scrollY == this.$id || this._isHorizontal() && a[s].$config.scrollX == this.$id) && r.push(a[s]);
                return r
            }
            ,
            e.prototype._initHorizontal = function() {
                this.$scroll_hor = this.$view,
                    this.$domEvents.attach(this.$view, "scroll", this._scrollHorizontalHandler)
            }
            ,
            e.prototype._initLinkedViews = function() {
                for (var a = this._getLinkedViews(), r = this._isVertical() ? "gantt_layout_outer_scroll gantt_layout_outer_scroll_vertical" : "gantt_layout_outer_scroll gantt_layout_outer_scroll_horizontal", s = 0; s < a.length; s++)
                    $t(a[s].$view || a[s].getNode(), r)
            }
            ,
            e.prototype._initVertical = function() {
                this.$scroll_ver = this.$view,
                    this.$domEvents.attach(this.$view, "scroll", this._scrollVerticalHandler)
            }
            ,
            e.prototype._updateLinkedViews = function() {}
            ,
            e.prototype._initMouseWheel = function() {
                kt.isFF ? this.$domEvents.attach(this._getRootParent().$view, "wheel", this._mouseWheelHandler, {
                    passive: !1
                }) : this.$domEvents.attach(this._getRootParent().$view, "mousewheel", this._mouseWheelHandler, {
                    passive: !1
                })
            }
            ,
            e.prototype.scrollHorizontally = function(a) {
                if (!this._scrolling) {
                    this._scrolling = !0,
                        this.$scroll_hor.scrollLeft = a,
                        this.$config.codeScrollLeft = a,
                        a = this.$scroll_hor.scrollLeft;
                    for (var r = this._getLinkedViews(), s = 0; s < r.length; s++)
                        r[s].scrollTo && r[s].scrollTo(a, void 0);
                    var o = this.$config.scrollPosition;
                    this.$config.scrollPosition = a,
                        this.callEvent("onScroll", [o, a, this.$config.scroll]),
                        this._scrolling = !1
                }
            }
            ,
            e.prototype.scrollVertically = function(a) {
                if (!this._scrolling) {
                    this._scrolling = !0,
                        this.$scroll_ver.scrollTop = a,
                        a = this.$scroll_ver.scrollTop;
                    for (var r = this._getLinkedViews(), s = 0; s < r.length; s++)
                        r[s].scrollTo && r[s].scrollTo(void 0, a);
                    var o = this.$config.scrollPosition;
                    this.$config.scrollPosition = a,
                        this.callEvent("onScroll", [o, a, this.$config.scroll]),
                        this._scrolling = !1
                }
            }
            ,
            e.prototype._isVertical = function() {
                return this.$config.scroll == "y"
            }
            ,
            e.prototype._isHorizontal = function() {
                return this.$config.scroll == "x"
            }
            ,
            e.prototype._scrollHorizontalHandler = function(a) {
                if (!this._isVertical() && !this._scrolling) {
                    if (new Date - (this._wheel_time || 0) < 100)
                        return !0;
                    var r = this.$scroll_hor.scrollLeft;
                    this.scrollHorizontally(r),
                        this._oldLeft = this.$scroll_hor.scrollLeft
                }
            }
            ,
            e.prototype._outerScrollHorizontalHandler = function(a) {
                this._isVertical()
            }
            ,
            e.prototype.show = function() {
                this.$parent.show()
            }
            ,
            e.prototype.hide = function() {
                this.$parent.hide()
            }
            ,
            e.prototype._getScrollSize = function() {
                for (var a, r = 0, s = 0, o = this._isHorizontal(), l = this._getLinkedViews(), d = o ? "scrollWidth" : "scrollHeight", c = o ? "contentX" : "contentY", u = o ? "x" : "y", h = this._getScrollOffset(), _ = 0; _ < l.length; _++)
                    if ((a = l[_]) && a.$content && a.$content.getSize && !a.$config.hidden) {
                        var f, y = a.$content.getSize();
                        if (f = y.hasOwnProperty(d) ? y[d] : y[c],
                            h)
                            y[c] > y[u] && y[c] > r && f > y[u] - h + 2 && (r = f + (o ? 0 : 2),
                                s = y[u]);
                        else {
                            var v = Math.max(y[c] - f, 0);
                            (f += v) > Math.max(y[u] - v, 0) && f > r && (r = f,
                                s = y[u])
                        }
                    }
                return {
                    outerScroll: s,
                    innerScroll: r
                }
            }
            ,
            e.prototype.scroll = function(a) {
                this._isHorizontal() ? this.scrollHorizontally(a) : this.scrollVertically(a)
            }
            ,
            e.prototype.getScrollState = function() {
                return {
                    visible: this.isVisible(),
                    direction: this.$config.scroll,
                    size: this.$config.outerSize,
                    scrollSize: this.$config.scrollSize || 0,
                    position: this.$config.scrollPosition || 0
                }
            }
            ,
            e.prototype.setSize = function(a, r) {
                t.prototype.setSize.apply(this, arguments);
                var s = this._getScrollSize()
                    , o = (this._isVertical() ? r : a) - this._getScrollOffset() + (this._isHorizontal() ? 1 : 0);
                s.innerScroll && o > s.outerScroll && (s.innerScroll += o - s.outerScroll),
                    this.$config.scrollSize = s.innerScroll,
                    this.$config.width = a,
                    this.$config.height = r,
                    this._setScrollSize(s.innerScroll)
            }
            ,
            e.prototype.isVisible = function() {
                return !(!this.$parent || !this.$parent.$view.parentNode)
            }
            ,
            e.prototype.shouldShow = function() {
                var a = this._getScrollSize();
                return !(!a.innerScroll && this.$parent && this.$parent.$view.parentNode) && !(!a.innerScroll || this.$parent && this.$parent.$view.parentNode)
            }
            ,
            e.prototype.shouldHide = function() {
                return !(this._getScrollSize().innerScroll || !this.$parent || !this.$parent.$view.parentNode)
            }
            ,
            e.prototype.toggleVisibility = function() {
                this.shouldHide() ? this.hide() : this.shouldShow() && this.show()
            }
            ,
            e.prototype._getScaleOffset = function(a) {
                var r = 0;
                return !a || a.$config.view != "timeline" && a.$config.view != "grid" || (r = a.$content.$getConfig().scale_height),
                    r
            }
            ,
            e.prototype._getScrollOffset = function() {
                var a = 0;
                if (this._isVertical()) {
                    var r = this.$parent.$parent;
                    a = Math.max(this._getScaleOffset(r.getPrevSibling(this.$parent.$id)), this._getScaleOffset(r.getNextSibling(this.$parent.$id)))
                } else
                    for (var s = this._getLinkedViews(), o = 0; o < s.length; o++) {
                        var l = s[o].$parent.$cells
                            , d = l[l.length - 1];
                        if (d && d.$config.view == "scrollbar" && d.$config.hidden === !1) {
                            a = d.$config.width;
                            break
                        }
                    }
                return a || 0
            }
            ,
            e.prototype._setScrollSize = function(a) {
                var r = this._isHorizontal() ? "width" : "height"
                    , s = this._isHorizontal() ? this.$scroll_hor : this.$scroll_ver
                    , o = this._getScrollOffset()
                    , l = s.firstChild;
                o ? this._isVertical() ? (this.$config.outerSize = this.$config.height - o + 3,
                    s.style.height = this.$config.outerSize + "px",
                    s.style.top = o - 1 + "px",
                    $t(s, this.$parent._borders.top),
                    $t(s.parentNode, "gantt_task_vscroll")) : (this.$config.outerSize = this.$config.width - o + 1,
                    s.style.width = this.$config.outerSize + "px") : (s.style.top = "auto",
                    Pt(s, this.$parent._borders.top),
                    Pt(s.parentNode, "gantt_task_vscroll"),
                    this.$config.outerSize = this.$config.height),
                    l.style[r] = a + "px"
            }
            ,
            e.prototype._scrollVerticalHandler = function(a) {
                if (!this._scrollHorizontalHandler() && !this._scrolling) {
                    var r = this.$scroll_ver.scrollTop;
                    r != this._oldTop && (this.scrollVertically(r),
                        this._oldTop = this.$scroll_ver.scrollTop)
                }
            }
            ,
            e.prototype._outerScrollVerticalHandler = function(a) {
                this._scrollHorizontalHandler()
            }
            ,
            e.prototype._checkWheelTarget = function(a) {
                for (var r = this._getLinkedViews().concat(this), s = 0; s < r.length; s++)
                    if (tt(a, r[s].$view))
                        return !0;
                return !1
            }
            ,
            e.prototype._mouseWheelHandler = function(a) {
                var r = a.target || a.srcElement;
                if (this._checkWheelTarget(r)) {
                    this._wheel_time = new Date;
                    var s = {}
                        , o = {
                        x: 1,
                        y: 1
                    }
                        , l = this.$gantt.config.wheel_scroll_sensitivity;
                    typeof l == "number" && l ? o = {
                        x: l,
                        y: l
                    } : {}.toString.apply(l) == "[object Object]" && (o = {
                        x: l.x,
                        y: l.y
                    });
                    var d = kt.isFF
                        , c = d ? a.deltaX : a.wheelDeltaX
                        , u = d ? a.deltaY : a.wheelDelta
                        , h = -20;
                    if (d) {
                        const k = parseInt(navigator.userAgent.split("Firefox/")[1]);
                        h = k <= 87 ? a.deltaMode !== 0 ? -40 : -10 : k <= 90 ? -3 : k <= 96 ? -1.5 : -1
                    }
                    var _ = d ? c * h * o.x : 2 * c * o.x
                        , f = d ? u * h * o.y : u * o.y
                        , y = this.$gantt.config.horizontal_scroll_key;
                    if (y !== !1 && n.indexOf(y) >= 0 && (!a[y] || a.deltaX || a.wheelDeltaX || (_ = 2 * f,
                        f = 0)),
                    _ && Math.abs(_) > Math.abs(f)) {
                        if (this._isVertical())
                            return;
                        if (s.x || !this.$scroll_hor || !this.$scroll_hor.offsetWidth)
                            return !0;
                        var v = _ / -40
                            , b = this._oldLeft
                            , g = b + 30 * v;
                        if (this.scrollHorizontally(g),
                            this.$scroll_hor.scrollLeft = g,
                        b == this.$scroll_hor.scrollLeft)
                            return !0;
                        this._oldLeft = this.$scroll_hor.scrollLeft
                    } else {
                        if (this._isHorizontal())
                            return;
                        if (s.y || !this.$scroll_ver || !this.$scroll_ver.offsetHeight)
                            return !0;
                        v = f / -40,
                        f === void 0 && (v = a.detail);
                        var m = this._oldTop
                            , p = this.$scroll_ver.scrollTop + 30 * v;
                        if (this.scrollVertically(p),
                            this.$scroll_ver.scrollTop = p,
                        m == this.$scroll_ver.scrollTop)
                            return !0;
                        this._oldTop = this.$scroll_ver.scrollTop
                    }
                    return a.preventDefault && a.preventDefault(),
                        a.cancelBubble = !0,
                        !1
                }
            }
            ,
            e
    }(xt)
        , Ja = function(t, n) {
        var e = {}
            , i = "gantt-static-bg-styles-" + t.uid();
        function a(u) {
            var h = /^rgba?\(([\d]{1,3}), *([\d]{1,3}), *([\d]{1,3}) *(,( *[\d.]+ *))?\)$/i.exec(u);
            return h ? {
                r: 1 * h[1],
                g: 1 * h[2],
                b: 1 * h[3],
                a: 255 * h[5] || 255
            } : null
        }
        function r(u) {
            return e[u] || null
        }
        function s(u, h, _) {
            return (u + "" + h + _.bottomBorderColor + _.rightBorderColor).replace(/[^\w\d]/g, "")
        }
        function o(u, h) {
            e[u] = h
        }
        function l(u, h, _) {
            var f = Math.floor(500 / u) || 1
                , y = Math.floor(500 / h) || 1
                , v = document.createElement("canvas");
            v.height = h * y,
                v.width = u * f;
            var b = v.getContext("2d");
            return function(m, p, k, w, x, $) {
                var S = x.createImageData(p * w, m * k);
                S.imageSmoothingEnabled = !1;
                for (var T = 1 * $.rightBorderWidth, E = a($.rightBorderColor), C = 0, D = 0, A = 0, I = 1; I <= w; I++)
                    for (C = I * p - 1,
                             A = 0; A < T; A++)
                        for (D = 0; D < m * k; D++)
                            g(C - A, D, E, S);
                var M = 1 * $.bottomBorderWidth
                    , L = a($.bottomBorderColor);
                D = 0;
                for (var N = 1; N <= k; N++)
                    for (D = N * m - 1,
                             A = 0; A < M; A++)
                        for (C = 0; C < p * w; C++)
                            g(C, D - A, L, S);
                x.putImageData(S, 0, 0)
            }(h, u, y, f, b, _),
                v.toDataURL();
            function g(m, p, k, w) {
                var x = 4 * (p * (u * f) + m);
                w.data[x] = k.r,
                    w.data[x + 1] = k.g,
                    w.data[x + 2] = k.b,
                    w.data[x + 3] = k.a
            }
        }
        function d(u) {
            return "gantt-static-bg-" + u
        }
        function c() {
            var u = document.createElement("div");
            u.className = "gantt_task_cell";
            var h = document.createElement("div");
            return h.className = "gantt_task_row",
                h.appendChild(u),
                h
        }
        return {
            render: function(u, h, _, f, y) {
                if ((h.static_background || h.timeline_placeholder) && document.createElement("canvas").getContext) {
                    u.innerHTML = "";
                    var v = function(p) {
                        var k = c()
                            , w = c();
                        p.appendChild(k),
                            p.appendChild(w);
                        var x = k.firstChild
                            , $ = getComputedStyle(k)
                            , S = getComputedStyle(x)
                            , T = {
                            bottomBorderWidth: $.getPropertyValue("border-bottom-width").replace("px", ""),
                            rightBorderWidth: S.getPropertyValue("border-right-width").replace("px", ""),
                            bottomBorderColor: $.getPropertyValue("border-bottom-color"),
                            rightBorderColor: S.getPropertyValue("border-right-color")
                        };
                        return p.removeChild(k),
                            p.removeChild(w),
                            T
                    }(u)
                        , b = function(p, k, w, x) {
                        var $ = {}
                            , S = function(M) {
                            for (var L = M.width, N = {}, P = 0; P < L.length; P++)
                                1 * L[P] && (N[L[P]] = !0);
                            return N
                        }(w)
                            , T = x
                            , E = "";
                        for (var C in S) {
                            var D = 1 * C
                                , A = s(D, T, p);
                            if (!r(A)) {
                                var I = l(D, T, p);
                                o(A, I),
                                    E += "." + d(A) + "{ background-image: url('" + I + "');}"
                            }
                            $[C] = d(A)
                        }
                        return E && (function() {
                            var M = document.getElementById(i);
                            return M || ((M = document.createElement("style")).id = i,
                                document.body.appendChild(M)),
                                M
                        }().innerHTML += E),
                            $
                    }(v, 0, _, y)
                        , g = function(p, k, w, x) {
                        var $, S, T = [], E = 0, C = w.width.filter(function(F) {
                            return !!F
                        }), D = 0, A = 1e5;
                        if (n.isIE) {
                            var I = navigator.appVersion || "";
                            I.indexOf("Windows NT 6.2") == -1 && I.indexOf("Windows NT 6.1") == -1 && I.indexOf("Windows NT 6.0") == -1 || (A = 2e4)
                        }
                        for (var M = 0; M < C.length; M++) {
                            var L = C[M];
                            if (L != S && S !== void 0 || M == C.length - 1 || E > A) {
                                for (var N = x, P = 0, R = Math.floor(A / k.row_height) * k.row_height, B = E; N > 0; ) {
                                    var H = Math.min(N, R);
                                    N -= R,
                                        ($ = document.createElement("div")).style.height = H + "px",
                                        $.style.position = "absolute",
                                        $.style.top = P + "px",
                                        $.style.left = D + "px",
                                        $.style.pointerEvents = "none",
                                        $.style.whiteSpace = "no-wrap",
                                        $.className = p[S || L],
                                    M == C.length - 1 && (B = L + B - 1),
                                        $.style.width = B + "px",
                                        T.push($),
                                        P += H
                                }
                                E = 0,
                                    D += B
                            }
                            L && (E += L,
                                S = L)
                        }
                        return T
                    }(b, h, _, f)
                        , m = document.createDocumentFragment();
                    g.forEach(function(p) {
                        m.appendChild(p)
                    }),
                        u.appendChild(m)
                }
            },
            destroy: function() {
                var u = document.getElementById(i);
                u && u.parentNode && u.parentNode.removeChild(u)
            }
        }
    };
    const Ka = function() {
        return Ja(vn, kt)
    };
    var je = function(t, n, e, i) {
        this.$config = O({}, n || {}),
            this.$scaleHelper = new En(i),
            this.$gantt = i,
            this._posFromDateCache = {},
            this._timelineDragScroll = null,
            O(this, Nn(this)),
            ct(this)
    };
    function Fe(t) {
        if (t._delayRender && t._delayRender.$cancelTimeout(),
            t.$gantt) {
            var n = t.$gantt.$data.tasksStore
                , e = t.$config.rowStore
                , i = "_attached_" + e.$config.name;
            t[i] && (n.detachEvent(t[i]),
                t[i] = null),
            e.$attachedResourceViewHandler && (e.detachEvent(e.$attachedResourceViewHandler),
                e.$attachedResourceViewHandler = null,
                n.detachEvent(e.$attachedTaskStoreHandler),
                e.$attachedTaskStoreHandler = null)
        }
    }
    function We(t) {
        var n = t.prototype.init
            , e = t.prototype.destructor;
        return {
            init: function() {
                n.apply(this, arguments),
                    this._linkToTaskStore()
            },
            destructor: function() {
                Fe(this),
                    e.apply(this, arguments)
            },
            previousDragId: null,
            relevantResources: null,
            _linkToTaskStore: function() {
                if (this.$config.rowStore && this.$gantt.$data.tasksStore) {
                    var i = this.$gantt.$data.tasksStore
                        , a = this.$config.rowStore;
                    Fe(this);
                    var r = this
                        , s = Xt(function() {
                        if (r.$gantt.getState().lightbox)
                            s();
                        else {
                            const l = r.$config.rowStore
                                , d = r._getRelevantResources();
                            if (d && l.$config.name === r.$gantt.config.resource_store) {
                                if (d == "nothing_to_repaint")
                                    return;
                                l._quick_refresh = !0,
                                    r.relevantResources.forEach(function(c) {
                                        l.refresh(c)
                                    }),
                                    l._quick_refresh = !1
                            } else
                                l.refresh()
                        }
                    }, 300);
                    this._delayRender = s;
                    var o = "_attached_" + a.$config.name;
                    r[o] || (r[o] = i.attachEvent("onStoreUpdated", function() {
                        if (!s.$pending && !this._skipResourceRepaint) {
                            const l = r.$gantt.getState();
                            if (l.drag_mode == "progress")
                                return !0;
                            l.drag_mode && l.drag_id && (r.previousDragId = l.drag_id),
                                s()
                        }
                        return !0
                    })),
                        this.$gantt.attachEvent("onDestroy", function() {
                            return Fe(r),
                                !0
                        }),
                    a.$attachedResourceViewHandler || (a.$attachedResourceViewHandler = a.attachEvent("onBeforeFilter", function() {
                        return !r.$gantt.getState().lightbox && (s.$pending && s.$cancelTimeout(),
                            r._updateNestedTasks(),
                            !0)
                    }),
                        a.$attachedTaskStoreHandler = i.attachEvent("onAfterDelete", function() {
                            a._mark_recompute = !0
                        }))
                }
            },
            _getRelevantResources: function() {
                if (!this.$gantt.getTaskAssignments)
                    return null;
                const i = this.$gantt.getState()
                    , a = this.$config.rowStore;
                let r = [];
                if (i.drag_mode && i.drag_id)
                    if (this.previousDragId == i.drag_id) {
                        if (this.relevantResources)
                            return this.relevantResources;
                        r = this._getIdsFromAssignments(this.previousDragId)
                    } else
                        this.previousDragId = i.drag_id,
                            r = this._getIdsFromAssignments(this.previousDragId);
                else {
                    if (!this.previousDragId)
                        return null;
                    r = this._getIdsFromAssignments(this.previousDragId),
                        this.previousDragId = null
                }
                return r.length ? (r.forEach(function(s) {
                    a.eachParent(function(o) {
                        r.push(o.id)
                    }, s)
                }),
                    this.relevantResources = [...new Set(r)]) : this.relevantResources = "nothing_to_repaint"
            },
            _getIdsFromAssignments: function(i) {
                const a = this.$gantt
                    , r = []
                    , s = a.getTask(i);
                return a.getTaskAssignments(i).forEach(function(o) {
                    r.push(o.resource_id)
                }),
                a.isSummaryTask(s) && a.config.drag_project && a.eachTask(function(o) {
                    a.getTaskAssignments(o.id).forEach(function(l) {
                        r.push(l.resource_id)
                    })
                }, i),
                a.config.drag_multiple && a.getSelectedTasks && a.getSelectedTasks().forEach(function(o) {
                    a.getTaskAssignments(o).forEach(function(l) {
                        r.push(l.resource_id)
                    })
                }),
                    r
            },
            _updateNestedTasks: function() {
                var i = this.$gantt
                    , a = i.getDatastore(i.config.resource_store);
                a.$config.fetchTasks && a.silent(function() {
                    var r = []
                        , s = {}
                        , o = {};
                    for (var l in a.eachItem(function(d) {
                        if (d.$role != "task") {
                            var c = i.getResourceAssignments(d.id)
                                , u = {};
                            c.sort(function(h, _) {
                                const f = a.pull
                                    , y = f[`${h.task_id}_${h.resource_id}`]
                                    , v = f[`${_.task_id}_${_.resource_id}`];
                                return y && v ? y.$local_index - v.$local_index : 0
                            }),
                                c.forEach(function(h) {
                                    if (!u[h.task_id] && i.isTaskExists(h.task_id)) {
                                        u[h.task_id] = !0;
                                        var _, f = i.getTask(h.task_id);
                                        (_ = a.$config.copyOnParse ? i.copy(f) : Object.create(f)).id = f.id + "_" + d.id,
                                            _.$task_id = f.id,
                                            _.$resource_id = d.id,
                                            _[a.$parentProperty] = d.id,
                                            _.$role = "task",
                                            r.push(_),
                                            s[_.id] = !0
                                    }
                                })
                        } else
                            o[d.id] = !0
                    }),
                        o)
                        s[l] || a.removeItem(l);
                    r.length && a.parse(r)
                })
            }
        }
    }
    je.prototype = {
        init: function(t) {
            t.innerHTML += "<div class='gantt_task' style='width:inherit;height:inherit;'></div>",
                this.$task = t.childNodes[0],
                this.$task.innerHTML = "<div class='gantt_task_scale'></div><div class='gantt_data_area'></div>",
                this.$task_scale = this.$task.childNodes[0],
                this.$task_data = this.$task.childNodes[1],
                this.$task_data.innerHTML = "<div class='gantt_task_bg'></div><div class='gantt_task_baselines'></div><div class='gantt_links_area'></div><div class='gantt_bars_area'></div><div class='gantt_task_constraints'></div><div class='gantt_task_deadlines'></div>",
                this.$task_bg = this.$task_data.childNodes[0],
                this.$task_baselines = this.$task_data.childNodes[1],
                this.$task_links = this.$task_data.childNodes[2],
                this.$task_bars = this.$task_data.childNodes[3],
                this.$task_constraints = this.$task_data.childNodes[4],
                this.$task_deadlines = this.$task_data.childNodes[5],
                this._tasks = {
                    col_width: 0,
                    width: [],
                    full_width: 0,
                    trace_x: [],
                    rendered: {}
                };
            var n = this.$getConfig()
                , e = n[this.$config.bind + "_attribute"]
                , i = n[this.$config.bindLinks + "_attribute"];
            !e && this.$config.bind && (e = "data-" + this.$config.bind + "-id"),
            !i && this.$config.bindLinks && (i = "data-" + this.$config.bindLinks + "-id"),
                this.$config.item_attribute = e || null,
                this.$config.link_attribute = i || null;
            var a = this._createLayerConfig();
            this.$config.layers || (this.$config.layers = a.tasks),
            this.$config.linkLayers || (this.$config.linkLayers = a.links),
                this._attachLayers(this.$gantt),
                this.callEvent("onReady", []),
            this.$gantt.ext.dragTimeline && (this._timelineDragScroll = this.$gantt.ext.dragTimeline.create(),
                this._timelineDragScroll.attach(this))
        },
        setSize: function(t, n) {
            var e = this.$getConfig();
            if (1 * t === t && (this.$config.width = t),
            1 * n === n) {
                this.$config.height = n;
                var i = Math.max(this.$config.height - e.scale_height);
                this.$task_data.style.height = i + "px"
            }
            this.refresh(),
                this.$task_bg.style.backgroundImage = "",
                e.smart_rendering && this.$config.rowStore ? this.$task_bg.style.height = this.getTotalHeight() + "px" : this.$task_bg.style.height = "";
            for (var a = this._tasks, r = this.$task_data.childNodes, s = 0, o = r.length; s < o; s++) {
                var l = r[s];
                l.hasAttribute("data-layer") && l.style && (l.style.width = a.full_width + "px")
            }
        },
        isVisible: function() {
            return this.$parent && this.$parent.$config ? !this.$parent.$config.hidden : this.$task.offsetWidth
        },
        getSize: function() {
            var t = this.$getConfig()
                , n = this.$config.rowStore ? this.getTotalHeight() : 0
                , e = this.isVisible() ? this._tasks.full_width : 0;
            return {
                x: this.isVisible() ? this.$config.width : 0,
                y: this.isVisible() ? this.$config.height : 0,
                contentX: this.isVisible() ? e : 0,
                contentY: this.isVisible() ? t.scale_height + n : 0,
                scrollHeight: this.isVisible() ? n : 0,
                scrollWidth: this.isVisible() ? e : 0
            }
        },
        scrollTo: function(t, n) {
            if (this.isVisible()) {
                var e = !1;
                this.$config.scrollTop = this.$config.scrollTop || 0,
                    this.$config.scrollLeft = this.$config.scrollLeft || 0,
                1 * n === n && (this.$config.scrollTop = n,
                    this.$task_data.scrollTop = this.$config.scrollTop,
                    e = !0),
                1 * t === t && (this.$task.scrollLeft = t,
                    this.$config.scrollLeft = this.$task.scrollLeft,
                    this._refreshScales(),
                    e = !0),
                e && this.callEvent("onScroll", [this.$config.scrollLeft, this.$config.scrollTop])
            }
        },
        _refreshScales: function() {
            if (this.isVisible() && this.$getConfig().smart_scales) {
                var t = this.getViewPort()
                    , n = this._scales;
                this.$task_scale.innerHTML = this._getScaleChunkHtml(n, t.x, t.x_end)
            }
        },
        getViewPort: function() {
            var t = this.$config.scrollLeft || 0
                , n = this.$config.scrollTop || 0
                , e = this.$config.height || 0
                , i = this.$config.width || 0;
            return {
                y: n,
                y_end: n + e,
                x: t,
                x_end: t + i,
                height: e,
                width: i
            }
        },
        _createLayerConfig: function() {
            var t = this
                , n = function() {
                return t.isVisible()
            };
            const e = this.$gantt
                , i = function(r, s) {
                return s.type === e.config.types.project && s.auto_scheduling === !1
            };
            var a = [{
                expose: !0,
                renderer: this.$gantt.$ui.layers.taskBar(),
                container: this.$task_bars,
                filter: [n, function(r, s) {
                    return !s.hide_bar
                }
                    , function(r, s) {
                        return !i(0, s)
                    }
                ]
            }, {
                renderer: this.$gantt.$ui.layers.timedProjectBar(),
                filter: [n, i],
                container: this.$task_bars,
                append: !0
            }, {
                renderer: this.$gantt.$ui.layers.taskSplitBar(),
                filter: [n],
                container: this.$task_bars,
                append: !0
            }, {
                renderer: this.$gantt.$ui.layers.taskRollupBar(),
                filter: [n],
                container: this.$task_bars,
                append: !0
            }, {
                renderer: this.$gantt.$ui.layers.taskConstraints(),
                filter: [n],
                container: this.$task_constraints,
                append: !1
            }];
            return e.config.deadlines && a.push({
                renderer: this.$gantt.$ui.layers.taskDeadline(),
                filter: [n],
                container: this.$task_deadlines,
                append: !1
            }),
            e.config.baselines && a.push({
                renderer: this.$gantt.$ui.layers.taskBaselines(),
                filter: [n],
                container: this.$task_baselines,
                append: !1
            }),
                a.push({
                    renderer: this.$gantt.$ui.layers.taskBg(),
                    container: this.$task_bg,
                    filter: [n]
                }),
                {
                    tasks: a,
                    links: [{
                        expose: !0,
                        renderer: this.$gantt.$ui.layers.link(),
                        container: this.$task_links,
                        filter: [n]
                    }]
                }
        },
        _attachLayers: function(t) {
            this._taskLayers = [],
                this._linkLayers = [];
            var n = this
                , e = this.$gantt.$services.getService("layers");
            if (this.$config.bind) {
                this._bindStore();
                var i = e.getDataRender(this.$config.bind);
                i || (i = e.createDataRender({
                    name: this.$config.bind,
                    defaultContainer: function() {
                        return n.$task_data
                    }
                })),
                    i.container = function() {
                        return n.$task_data
                    }
                ;
                for (var a = this.$config.layers, r = 0; a && r < a.length; r++) {
                    typeof (d = a[r]) == "string" && (d = this.$gantt.$ui.layers[d]()),
                    (typeof d == "function" || d && d.render && d.update) && (d = {
                        renderer: d
                    }),
                        d.view = this;
                    var s = i.addLayer(d);
                    this._taskLayers.push(s),
                    d.expose && (this._taskRenderer = i.getLayer(s))
                }
                this._initStaticBackgroundRender()
            }
            if (this.$config.bindLinks) {
                n.$config.linkStore = n.$gantt.getDatastore(n.$config.bindLinks);
                var o = e.getDataRender(this.$config.bindLinks);
                o || (o = e.createDataRender({
                    name: this.$config.bindLinks,
                    defaultContainer: function() {
                        return n.$task_data
                    }
                }));
                var l = this.$config.linkLayers;
                for (r = 0; l && r < l.length; r++) {
                    var d;
                    typeof d == "string" && (d = this.$gantt.$ui.layers[d]()),
                        (d = l[r]).view = this;
                    var c = o.addLayer(d);
                    this._taskLayers.push(c),
                    l[r].expose && (this._linkRenderer = o.getLayer(c))
                }
            }
        },
        _initStaticBackgroundRender: function() {
            var t = this
                , n = Ka()
                , e = t.$config.rowStore;
            e && (this._staticBgHandler = e.attachEvent("onStoreUpdated", function(i, a, r) {
                    if (i === null && t.isVisible()) {
                        var s = t.$getConfig();
                        if (s.static_background || s.timeline_placeholder) {
                            var o = t.$gantt.getDatastore(t.$config.bind)
                                , l = t.$task_bg_static;
                            if (l || ((l = document.createElement("div")).className = "gantt_task_bg",
                                t.$task_bg_static = l,
                                t.$task_bg.nextSibling ? t.$task_data.insertBefore(l, t.$task_bg.nextSibling) : t.$task_data.appendChild(l)),
                                o) {
                                var d = t.getTotalHeight();
                                s.timeline_placeholder && (d = s.timeline_placeholder.height || t.$task_data.offsetHeight || 99999),
                                    n.render(l, s, t.getScale(), d, t.getItemHeight(a ? a.id : null))
                            }
                        } else
                            s.static_background && t.$task_bg_static && t.$task_bg_static.parentNode && t.$task_bg_static.parentNode.removeChild(t.$task_bg_static)
                    }
                }),
                    this.attachEvent("onDestroy", function() {
                        n.destroy()
                    }),
                    this._initStaticBackgroundRender = function() {}
            )
        },
        _clearLayers: function(t) {
            var n = this.$gantt.$services.getService("layers")
                , e = n.getDataRender(this.$config.bind)
                , i = n.getDataRender(this.$config.bindLinks);
            if (this._taskLayers)
                for (var a = 0; a < this._taskLayers.length; a++)
                    e.removeLayer(this._taskLayers[a]);
            if (this._linkLayers)
                for (a = 0; a < this._linkLayers.length; a++)
                    i.removeLayer(this._linkLayers[a]);
            this._linkLayers = [],
                this._taskLayers = []
        },
        _render_tasks_scales: function() {
            var t = this.$getConfig()
                , n = ""
                , e = 0
                , i = 0
                , a = this.$gantt.getState();
            if (this.isVisible()) {
                var r = this.$scaleHelper
                    , s = this._getScales();
                i = t.scale_height;
                var o = this.$config.width;
                t.autosize != "x" && t.autosize != "xy" || (o = Math.max(t.autosize_min_width, 0));
                var l = r.prepareConfigs(s, t.min_column_width, o, i - 1, a.min_date, a.max_date, t.rtl)
                    , d = this._tasks = l[l.length - 1];
                this._scales = l,
                    this._posFromDateCache = {},
                    n = this._getScaleChunkHtml(l, 0, this.$config.width),
                    e = d.full_width + "px",
                    i += "px"
            }
            this.$task_scale.style.height = i,
                this.$task_data.style.width = this.$task_scale.style.width = e,
                this.$task_scale.innerHTML = n
        },
        _getScaleChunkHtml: function(t, n, e) {
            for (var i = [], a = this.$gantt.templates.scale_row_class, r = 0; r < t.length; r++) {
                var s = "gantt_scale_line"
                    , o = a(t[r]);
                o && (s += " " + o),
                    i.push('<div class="' + s + '" style="height:' + t[r].height + "px;position:relative;line-height:" + t[r].height + 'px">' + this._prepareScaleHtml(t[r], n, e, r) + "</div>")
            }
            return i.join("")
        },
        _prepareScaleHtml: function(t, n, e, i) {
            var a = this.$getConfig()
                , r = this.$gantt.templates
                , s = []
                , o = null
                , l = null
                , d = t.format || t.template || t.date;
            typeof d == "string" && (d = this.$gantt.date.date_to_str(d));
            var c = 0
                , u = t.count;
            !a.smart_scales || isNaN(n) || isNaN(e) || (c = Bt(t.left, n),
                u = Bt(t.left, e) + 1),
                l = t.css || function() {}
                ,
            !t.css && a.inherit_scale_class && (l = r.scale_cell_class);
            for (var h = c; h < u && t.trace_x[h]; h++) {
                o = new Date(t.trace_x[h]);
                var _ = d.call(this, o)
                    , f = t.width[h];
                t.height;
                var y = t.left[h]
                    , v = ""
                    , b = ""
                    , g = "";
                if (f) {
                    v = "width:" + f + "px;" + (a.smart_scales ? "position:absolute;left:" + y + "px" : "");
                    const p = this.getViewPort()
                        , k = (a.scales[i] || {}).sticky;
                    let w = "";
                    const x = 70;
                    if (k !== !1 && f > x || k === !0) {
                        if (y < p.x && y + f / 2 - x / 2 < p.x)
                            w = ` style='position:absolute;left: ${p.x - y + 10}px;' `;
                        else if (y + f / 2 + x / 2 > p.x_end && f > x) {
                            let $ = p.x_end - y - 10
                                , S = "-100%";
                            $ < x && ($ = x,
                                S = `-${$}px`),
                                w = ` style='position:absolute;left: ${$}px;transform: translate(${S},0);' `
                        }
                    }
                    g = "gantt_scale_cell" + (h == t.count - 1 ? " gantt_last_cell" : ""),
                    (b = l.call(this, o)) && (g += " " + b);
                    var m = `<div class='${g}' ${this.$gantt._waiAria.getTimelineCellAttr(_)} style='${v}'><span ${w}>${_}</span></div>`;
                    s.push(m)
                }
            }
            return s.join("")
        },
        dateFromPos: function(t) {
            var n = this._tasks;
            if (t < 0 || t > n.full_width || !n.full_width)
                return null;
            var e = Bt(this._tasks.left, t)
                , i = this._tasks.left[e]
                , a = n.width[e] || n.col_width
                , r = 0;
            a && (r = (t - i) / a,
            n.rtl && (r = 1 - r));
            var s = 0;
            return r && (s = this._getColumnDuration(n, n.trace_x[e])),
                new Date(n.trace_x[e].valueOf() + Math.round(r * s))
        },
        posFromDate: function(t) {
            if (!this.isVisible() || !t)
                return 0;
            var n = String(t.valueOf());
            if (this._posFromDateCache[n] !== void 0)
                return this._posFromDateCache[n];
            var e = this.columnIndexByDate(t);
            this.$gantt.assert(e >= 0, "Invalid day index");
            var i = Math.floor(e)
                , a = e % 1
                , r = this._tasks.left[Math.min(i, this._tasks.width.length - 1)];
            i == this._tasks.width.length && (r += this._tasks.width[this._tasks.width.length - 1]),
            a && (i < this._tasks.width.length ? r += this._tasks.width[i] * (a % 1) : r += 1);
            var s = Math.round(r);
            return this._posFromDateCache[n] = s,
                Math.round(s)
        },
        _getNextVisibleColumn: function(t, n, e) {
            for (var i = +n[t], a = t; e[i]; )
                i = +n[++a];
            return a
        },
        _getPrevVisibleColumn: function(t, n, e) {
            for (var i = +n[t], a = t; e[i]; )
                i = +n[--a];
            return a
        },
        _getClosestVisibleColumn: function(t, n, e) {
            var i = this._getNextVisibleColumn(t, n, e);
            return n[i] || (i = this._getPrevVisibleColumn(t, n, e)),
                i
        },
        columnIndexByDate: function(t) {
            var n = new Date(t).valueOf()
                , e = this._tasks.trace_x_ascending
                , i = this._tasks.ignore_x
                , a = this.$gantt.getState();
            if (n <= a.min_date)
                return this._tasks.rtl ? e.length : 0;
            if (n >= a.max_date)
                return this._tasks.rtl ? 0 : e.length;
            var r = Bt(e, n)
                , s = this._getClosestVisibleColumn(r, e, i)
                , o = e[s]
                , l = this._tasks.trace_index_transition;
            if (!o)
                return l ? l[0] : 0;
            var d = (t - e[s]) / this._getColumnDuration(this._tasks, e[s]);
            return l ? l[s] + (1 - d) : s + d
        },
        getItemPosition: function(t, n, e) {
            var i, a, r;
            let s = n || t.start_date || t.$auto_start_date
                , o = e || t.end_date || t.$auto_end_date;
            return this._tasks.rtl ? (a = this.posFromDate(s),
                i = this.posFromDate(o)) : (i = this.posFromDate(s),
                a = this.posFromDate(o)),
                r = Math.max(a - i, 0),
                {
                    left: i,
                    top: this.getItemTop(t.id),
                    height: this.getBarHeight(t.id),
                    width: r,
                    rowHeight: this.getItemHeight(t.id)
                }
        },
        getBarHeight: function(t, n) {
            var e = this.$getConfig()
                , i = this.$config.rowStore.getItem(t)
                , a = i.task_height || i.bar_height || e.bar_height || e.task_height
                , r = this.getItemHeight(t);
            return a == "full" && (a = r - (e.bar_height_padding || 3)),
                a = Math.min(a, r),
            n && (a = Math.round(a / Math.sqrt(2))),
                Math.max(a, 0)
        },
        getScale: function() {
            return this._tasks
        },
        _getScales: function() {
            var t = this.$getConfig()
                , n = this.$scaleHelper
                , e = [n.primaryScale(t)].concat(n.getSubScales(t));
            return n.sortScales(e),
                e
        },
        _getColumnDuration: function(t, n) {
            return this.$gantt.date.add(n, t.step, t.unit) - n
        },
        _bindStore: function() {
            if (this.$config.bind) {
                var t = this.$gantt.getDatastore(this.$config.bind);
                if (this.$config.rowStore = t,
                t && !t._timelineCacheAttached) {
                    var n = this;
                    t._timelineCacheAttached = t.attachEvent("onBeforeFilter", function() {
                        n._resetTopPositionHeight()
                    })
                }
            }
        },
        _unbindStore: function() {
            if (this.$config.bind) {
                var t = this.$gantt.getDatastore(this.$config.bind);
                t && t._timelineCacheAttached && (t.detachEvent(t._timelineCacheAttached),
                    t._timelineCacheAttached = !1)
            }
        },
        refresh: function() {
            this._bindStore(),
            this.$config.bindLinks && (this.$config.linkStore = this.$gantt.getDatastore(this.$config.bindLinks)),
                this._resetTopPositionHeight(),
                this._resetHeight(),
                this._initStaticBackgroundRender(),
                this._render_tasks_scales()
        },
        destructor: function() {
            var t = this.$gantt;
            this._clearLayers(t),
                this._unbindStore(),
                this.$task = null,
                this.$task_scale = null,
                this.$task_data = null,
                this.$task_bg = null,
                this.$task_links = null,
                this.$task_bars = null,
                this.$gantt = null,
            this.$config.rowStore && (this.$config.rowStore.detachEvent(this._staticBgHandler),
                this.$config.rowStore = null),
            this.$config.linkStore && (this.$config.linkStore = null),
            this._timelineDragScroll && (this._timelineDragScroll.destructor(),
                this._timelineDragScroll = null),
                this.callEvent("onDestroy", []),
                this.detachAllEvents()
        }
    };
    var Xa = function(t) {
        function n(e, i, a, r) {
            return t.apply(this, arguments) || this
        }
        return W(n, t),
            O(n.prototype, {
                init: function() {
                    this.$config.bind === void 0 && (this.$config.bind = this.$getConfig().resource_store),
                        t.prototype.init.apply(this, arguments)
                },
                _initEvents: function() {
                    var e = this.$gantt;
                    t.prototype._initEvents.apply(this, arguments),
                        this._mouseDelegates.delegate("click", "gantt_row", e.bind(function(i, a, r) {
                            var s = this.$config.rowStore;
                            if (!s)
                                return !0;
                            var o = Q(i, this.$config.item_attribute);
                            return o && s.select(o.getAttribute(this.$config.item_attribute)),
                                !1
                        }, this), this.$grid)
                }
            }, !0),
            O(n.prototype, We(n), !0),
            n
    }(ne)
        , Jn = function(t) {
        function n(e, i, a, r) {
            var s = t.apply(this, arguments) || this;
            return s.$config.bindLinks = null,
                s
        }
        return W(n, t),
            O(n.prototype, {
                init: function() {
                    this.$config.bind === void 0 && (this.$config.bind = this.$getConfig().resource_store),
                        t.prototype.init.apply(this, arguments)
                },
                _createLayerConfig: function() {
                    var e = this
                        , i = function() {
                        return e.isVisible()
                    };
                    return {
                        tasks: [{
                            renderer: this.$gantt.$ui.layers.resourceRow(),
                            container: this.$task_bars,
                            filter: [i]
                        }, {
                            renderer: this.$gantt.$ui.layers.taskBg(),
                            container: this.$task_bg,
                            filter: [i]
                        }],
                        links: []
                    }
                }
            }, !0),
            O(n.prototype, We(n), !0),
            n
    }(je)
        , Za = function(t) {
        function n(e, i, a, r) {
            var s = t.apply(this, arguments) || this;
            return s.$config.bindLinks = null,
                s
        }
        return W(n, t),
            O(n.prototype, {
                _createLayerConfig: function() {
                    var e = this
                        , i = function() {
                        return e.isVisible()
                    };
                    return {
                        tasks: [{
                            renderer: this.$gantt.$ui.layers.resourceHistogram(),
                            container: this.$task_bars,
                            filter: [i]
                        }, {
                            renderer: this.$gantt.$ui.layers.taskBg(),
                            container: this.$task_bg,
                            filter: [i]
                        }],
                        links: []
                    }
                }
            }, !0),
            O(n.prototype, We(t), !0),
            n
    }(Jn);
    const Qa = {
        init: function(t, n) {
            var e = n.$gantt;
            e.attachEvent("onTaskClick", function(i, a) {
                if (e._is_icon_open_click(a))
                    return !0;
                var r = t.getState()
                    , s = t.locateCell(a.target);
                return !s || !t.getEditorConfig(s.columnName) || (t.isVisible() && r.id == s.id && r.columnName == s.columnName || t.startEdit(s.id, s.columnName),
                    !1)
            }),
                e.attachEvent("onEmptyClick", function() {
                    return t.isVisible() && t.isChanged() ? t.save() : t.hide(),
                        !0
                }),
                e.attachEvent("onTaskDblClick", function(i, a) {
                    var r = t.getState()
                        , s = t.locateCell(a.target);
                    return !s || !t.isVisible() || s.columnName != r.columnName
                })
        },
        onShow: function(t, n, e) {
            var i = e.$gantt;
            i.ext && i.ext.keyboardNavigation && i.ext.keyboardNavigation.attachEvent("onKeyDown", function(a, r) {
                var s = i.constants.KEY_CODES
                    , o = !1;
                return r.keyCode === s.SPACE && t.isVisible() && (o = !0),
                    !o
            }),
                n.onkeydown = function(a) {
                    a = a || window.event;
                    var r = i.constants.KEY_CODES;
                    if (!(a.defaultPrevented || a.shiftKey && a.keyCode != r.TAB)) {
                        var s = !0;
                        switch (a.keyCode) {
                            case i.keys.edit_save:
                                t.save();
                                break;
                            case i.keys.edit_cancel:
                                t.hide();
                                break;
                            case r.UP:
                            case r.DOWN:
                                t.isVisible() && (t.hide(),
                                    s = !1);
                                break;
                            case r.TAB:
                                a.shiftKey ? t.editPrevCell(!0) : t.editNextCell(!0);
                                break;
                            default:
                                s = !1
                        }
                        s && a.preventDefault()
                    }
                }
        },
        onHide: function() {},
        destroy: function() {}
    }
        , tr = {
        init: function(t, n) {
            var e = t
                , i = n.$gantt
                , a = null
                , r = i.ext.keyboardNavigation;
            r.attachEvent("onBeforeFocus", function(s) {
                var o = t.locateCell(s);
                if (clearTimeout(a),
                    o) {
                    var l = o.columnName
                        , d = o.id
                        , c = e.getState();
                    if (e.isVisible() && c.id == d && c.columnName === l)
                        return !1
                }
                return !0
            }),
                r.attachEvent("onFocus", function(s) {
                    var o = t.locateCell(s)
                        , l = t.getState();
                    return clearTimeout(a),
                    !o || o.id == l.id && o.columnName == l.columnName || e.isVisible() && e.save(),
                        !0
                }),
                t.attachEvent("onHide", function() {
                    clearTimeout(a)
                }),
                r.attachEvent("onBlur", function() {
                    return a = setTimeout(function() {
                        e.save()
                    }),
                        !0
                }),
                i.attachEvent("onTaskDblClick", function(s, o) {
                    var l = t.getState()
                        , d = t.locateCell(o.target);
                    return !d || !t.isVisible() || d.columnName != l.columnName
                }),
                i.attachEvent("onTaskClick", function(s, o) {
                    if (i._is_icon_open_click(o))
                        return !0;
                    var l = t.getState()
                        , d = t.locateCell(o.target);
                    return !d || !t.getEditorConfig(d.columnName) || (t.isVisible() && l.id == d.id && l.columnName == d.columnName || t.startEdit(d.id, d.columnName),
                        !1)
                }),
                i.attachEvent("onEmptyClick", function() {
                    return e.save(),
                        !0
                }),
                r.attachEvent("onKeyDown", function(s, o) {
                    var l = t.locateCell(o.target)
                        , d = !!l && t.getEditorConfig(l.columnName)
                        , c = t.getState()
                        , u = i.constants.KEY_CODES
                        , h = o.keyCode
                        , _ = !1;
                    switch (h) {
                        case u.ENTER:
                            t.isVisible() ? (t.save(),
                                o.preventDefault(),
                                _ = !0) : d && !(o.ctrlKey || o.metaKey || o.shiftKey) && (e.startEdit(l.id, l.columnName),
                                o.preventDefault(),
                                _ = !0);
                            break;
                        case u.ESC:
                            t.isVisible() && (t.hide(),
                                o.preventDefault(),
                                _ = !0);
                            break;
                        case u.UP:
                        case u.DOWN:
                            break;
                        case u.LEFT:
                        case u.RIGHT:
                            (d && t.isVisible() || c.editorType === "date") && (_ = !0);
                            break;
                        case u.SPACE:
                            t.isVisible() && (_ = !0),
                            d && !t.isVisible() && (e.startEdit(l.id, l.columnName),
                                o.preventDefault(),
                                _ = !0);
                            break;
                        case u.DELETE:
                            d && !t.isVisible() ? (e.startEdit(l.id, l.columnName),
                                _ = !0) : d && t.isVisible() && (_ = !0);
                            break;
                        case u.TAB:
                            if (t.isVisible()) {
                                o.shiftKey ? t.editPrevCell(!0) : t.editNextCell(!0);
                                var f = t.getState();
                                f.id && r.focus({
                                    type: "taskCell",
                                    id: f.id,
                                    column: f.columnName
                                }),
                                    o.preventDefault(),
                                    _ = !0
                            }
                            break;
                        default:
                            if (t.isVisible())
                                _ = !0;
                            else if (h >= 48 && h <= 57 || h > 95 && h < 112 || h >= 64 && h <= 91 || h > 185 && h < 193 || h > 218 && h < 223) {
                                var y = s.modifiers
                                    , v = y.alt || y.ctrl || y.meta || y.shift;
                                y.alt || v && r.getCommandHandler(s, "taskCell") || d && !t.isVisible() && (e.startEdit(l.id, l.columnName),
                                    _ = !0)
                            }
                    }
                    return !_
                })
        },
        onShow: function(t, n, e) {},
        onHide: function(t, n, e) {
            const i = e.$gantt;
            i && i.focus()
        },
        destroy: function() {}
    };
    function Ht(t) {
        var n = function() {};
        return n.prototype = {
            show: function(e, i, a, r) {},
            hide: function() {},
            set_value: function(e, i, a, r) {
                this.get_input(r).value = e
            },
            get_value: function(e, i, a) {
                return this.get_input(a).value || ""
            },
            is_changed: function(e, i, a, r) {
                var s = this.get_value(i, a, r);
                return s && e && s.valueOf && e.valueOf ? s.valueOf() != e.valueOf() : s != e
            },
            is_valid: function(e, i, a, r) {
                return !0
            },
            save: function(e, i, a) {},
            get_input: function(e) {
                return e.querySelector("input")
            },
            focus: function(e) {
                var i = this.get_input(e);
                i && (i.focus && i.focus(),
                i.select && i.select())
            }
        },
            n
    }
    function er(t) {
        var n = Ht();
        function e() {
            return n.apply(this, arguments) || this
        }
        return W(e, n),
            O(e.prototype, {
                show: function(i, a, r, s) {
                    var o = `<div role='cell'><input type='text' name='${a.name}' title='${a.name}'></div>`;
                    s.innerHTML = o
                }
            }, !0),
            e
    }
    function nr(t) {
        var n = Ht();
        function e() {
            return n.apply(this, arguments) || this
        }
        return W(e, n),
            O(e.prototype, {
                show: function(i, a, r, s) {
                    var o = r.min || 0
                        , l = r.max || 100
                        , d = `<div role='cell'><input type='number' min='${o}' max='${l}' name='${a.name}' title='${a.name}'></div>`;
                    s.innerHTML = d,
                        s.oninput = function(c) {
                            +c.target.value < o && (c.target.value = o),
                            +c.target.value > l && (c.target.value = l)
                        }
                },
                get_value: function(i, a, r) {
                    return this.get_input(r).value || ""
                },
                is_valid: function(i, a, r, s) {
                    return !isNaN(parseInt(i, 10))
                }
            }, !0),
            e
    }
    function ir(t) {
        var n = Ht();
        function e() {
            return n.apply(this, arguments) || this
        }
        return W(e, n),
            O(e.prototype, {
                show: function(i, a, r, s) {
                    for (var o = `<div role='cell'><select name='${a.name}' title='${a.name}'>`, l = [], d = r.options || [], c = 0; c < d.length; c++)
                        l.push("<option value='" + r.options[c].key + "'>" + d[c].label + "</option>");
                    o += l.join("") + "</select></div>",
                        s.innerHTML = o
                },
                get_input: function(i) {
                    return i.querySelector("select")
                }
            }, !0),
            e
    }
    function ar(t) {
        var n = Ht()
            , e = "%Y-%m-%d"
            , i = null
            , a = null;
        function r() {
            return n.apply(this, arguments) || this
        }
        return W(r, n),
            O(r.prototype, {
                show: function(s, o, l, d) {
                    i || (i = t.date.date_to_str(e)),
                    a || (a = t.date.str_to_date(e));
                    var c = null
                        , u = null;
                    c = typeof l.min == "function" ? l.min(s, o) : l.min,
                        u = typeof l.max == "function" ? l.max(s, o) : l.max;
                    var h = `<div style='width:140px' role='cell'><input type='date' ${c ? " min='" + i(c) + "' " : ""} ${u ? " max='" + i(u) + "' " : ""} name='${o.name}' title='${o.name}'></div>`;
                    d.innerHTML = h,
                        d.oninput = function(_) {
                            _.target.value && (c || u) && (+t.date.str_to_date("%Y-%m-%d")(_.target.value) < +c && (_.target.value = t.date.date_to_str("%Y-%m-%d")(c)),
                            +t.date.str_to_date("%Y-%m-%d")(_.target.value) > +u && (_.target.value = t.date.date_to_str("%Y-%m-%d")(u)))
                        }
                },
                set_value: function(s, o, l, d) {
                    s && s.getFullYear ? this.get_input(d).value = i(s) : this.get_input(d).value = s
                },
                is_valid: function(s, o, l, d) {
                    return !(!s || isNaN(s.getTime()))
                },
                get_value: function(s, o, l) {
                    var d;
                    try {
                        d = a(this.get_input(l).value || "")
                    } catch {
                        d = null
                    }
                    return d
                }
            }, !0),
            r
    }
    function rr(t) {
        var n = Ht();
        function e() {
            return n.apply(this, arguments) || this
        }
        function i(l) {
            return l.formatter || t.ext.formatters.linkFormatter()
        }
        function a(l, d) {
            for (var c = (l || "").split(d.delimiter || ","), u = 0; u < c.length; u++) {
                var h = c[u].trim();
                h ? c[u] = h : (c.splice(u, 1),
                    u--)
            }
            return c.sort(),
                c
        }
        function r(l, d, c) {
            for (var u = l.$target, h = [], _ = 0; _ < u.length; _++) {
                var f = c.getLink(u[_]);
                h.push(i(d).format(f))
            }
            return h.join((d.delimiter || ",") + " ")
        }
        function s(l) {
            return l.source + "_" + l.target + "_" + l.type + "_" + (l.lag || 0)
        }
        function o(l, d, c) {
            var u = function(v, b, g) {
                var m = [];
                return [...new Set(b)].forEach(function(p) {
                    var k = i(g).parse(p);
                    k && (k.target = v,
                        k.id = "predecessor_generated",
                    t.isLinkAllowed(k) && (k.id = void 0,
                        m.push(k)))
                }),
                    m
            }(l.id, d, c)
                , h = {};
            l.$target.forEach(function(v) {
                var b = t.getLink(v);
                h[s(b)] = b.id
            });
            var _ = [];
            u.forEach(function(v) {
                var b = s(v);
                h[b] ? delete h[b] : _.push(v)
            });
            var f = [];
            for (var y in h)
                f.push(h[y]);
            return {
                add: _,
                remove: f
            }
        }
        return W(e, n),
            O(e.prototype, {
                show: function(l, d, c, u) {
                    var h = `<div role='cell'><input type='text' name='${d.name}' title='${d.name}'></div>`;
                    u.innerHTML = h
                },
                hide: function() {},
                set_value: function(l, d, c, u) {
                    this.get_input(u).value = r(l, c.editor, t)
                },
                get_value: function(l, d, c) {
                    return a(this.get_input(c).value || "", d.editor)
                },
                save: function(l, d, c) {
                    var u = o(t.getTask(l), this.get_value(l, d, c), d.editor);
                    (u.add.length || u.remove.length) && t.batchUpdate(function() {
                        u.add.forEach(function(h) {
                            t.addLink(h)
                        }),
                            u.remove.forEach(function(h) {
                                t.deleteLink(h)
                            }),
                        t.autoSchedule && t.autoSchedule()
                    })
                },
                is_changed: function(l, d, c, u) {
                    var h = this.get_value(d, c, u)
                        , _ = a(r(l, c.editor, t), c.editor);
                    return h.join() !== _.join()
                }
            }, !0),
            e
    }
    function sr(t) {
        var n = Ht();
        function e() {
            return n.apply(this, arguments) || this
        }
        function i(a) {
            return a.formatter || t.ext.formatters.durationFormatter()
        }
        return W(e, n),
            O(e.prototype, {
                show: function(a, r, s, o) {
                    var l = `<div role='cell'><input type='text' name='${r.name}' title='${r.name}'></div>`;
                    o.innerHTML = l
                },
                set_value: function(a, r, s, o) {
                    this.get_input(o).value = i(s.editor).format(a)
                },
                get_value: function(a, r, s) {
                    return i(r.editor).parse(this.get_input(s).value || "")
                }
            }, !0),
            e
    }
    function or(t) {
        return function(e, i, a) {
            a == "keepDates" ? function(r, s) {
                s == "duration" ? r.end_date = t.calculateEndDate(r) : s != "end_date" && s != "start_date" || (r.duration = t.calculateDuration(r))
            }(e, i) : a == "keepDuration" ? function(r, s) {
                s == "end_date" ? r.start_date = n(r) : s != "start_date" && s != "duration" || (r.end_date = t.calculateEndDate(r))
            }(e, i) : function(r, s) {
                t.config.schedule_from_end ? s == "end_date" || s == "duration" ? r.start_date = n(r) : s == "start_date" && (r.duration = t.calculateDuration(r)) : s == "start_date" || s == "duration" ? r.end_date = t.calculateEndDate(r) : s == "end_date" && (r.duration = t.calculateDuration(r))
            }(e, i)
        }
            ;
        function n(e) {
            return t.calculateEndDate({
                start_date: e.end_date,
                duration: -e.duration,
                task: e
            })
        }
    }
    function lr(t) {
        t.config.editor_types = {
            text: new (er()),
            number: new (nr()),
            select: new (ir()),
            date: new (ar(t)),
            predecessor: new (rr(t)),
            duration: new (sr(t))
        }
    }
    function dr(t) {
        var n = function(a) {
            var r = null;
            return {
                setMapping: function(s) {
                    r = s
                },
                getMapping: function() {
                    return r || (a.config.keyboard_navigation_cells && a.ext.keyboardNavigation ? tr : Qa)
                }
            }
        }(t)
            , e = {};
        ct(e);
        var i = {
            init: lr,
            createEditors: function(a) {
                function r(u, h) {
                    var _ = a.$getConfig()
                        , f = function(b, g) {
                        for (var m = a.$getConfig(), p = a.getItemTop(b), k = a.getItemHeight(b), w = a.getGridColumns(), x = 0, $ = 0, S = 0, T = 0; T < w.length; T++) {
                            if (w[T].name == g) {
                                S = w[T].width;
                                break
                            }
                            m.rtl ? $ += w[T].width : x += w[T].width
                        }
                        return m.rtl ? {
                            top: p,
                            right: $,
                            height: k,
                            width: S
                        } : {
                            top: p,
                            left: x,
                            height: k,
                            width: S
                        }
                    }(u, h)
                        , y = document.createElement("div");
                    y.className = "gantt_grid_editor_placeholder",
                        y.setAttribute(a.$config.item_attribute, u),
                        y.setAttribute(a.$config.bind + "_id", u),
                        y.setAttribute("data-column-name", h);
                    var v = function(b, g) {
                        for (var m = b.getGridColumns(), p = 0; p < m.length; p++)
                            if (m[p].name == g)
                                return p;
                        return 0
                    }(a, h);
                    return y.setAttribute("data-column-index", v),
                        t._waiAria.inlineEditorAttr(y),
                        _.rtl ? y.style.cssText = ["top:" + f.top + "px", "right:" + f.right + "px", "width:" + f.width + "px", "height:" + f.height + "px"].join(";") : y.style.cssText = ["top:" + f.top + "px", "left:" + f.left + "px", "width:" + f.width + "px", "height:" + f.height + "px"].join(";"),
                        y
                }
                var s = or(t)
                    , o = []
                    , l = []
                    , d = null
                    , c = {
                    _itemId: null,
                    _columnName: null,
                    _editor: null,
                    _editorType: null,
                    _placeholder: null,
                    locateCell: function(u) {
                        if (!tt(u, a.$grid))
                            return null;
                        var h = Q(u, a.$config.item_attribute)
                            , _ = Q(u, "data-column-name");
                        if (h && _) {
                            var f = _.getAttribute("data-column-name");
                            return {
                                id: h.getAttribute(a.$config.item_attribute),
                                columnName: f
                            }
                        }
                        return null
                    },
                    getEditorConfig: function(u) {
                        return a.getColumn(u).editor
                    },
                    init: function() {
                        var u = n.getMapping();
                        u.init && u.init(this, a),
                            d = a.$gantt.getDatastore(a.$config.bind);
                        var h = this;
                        o.push(d.attachEvent("onIdChange", function(_, f) {
                            h._itemId == _ && (h._itemId = f)
                        })),
                            o.push(d.attachEvent("onStoreUpdated", function() {
                                a.$gantt.getState("batchUpdate").batch_update || h.isVisible() && !d.isVisible(h._itemId) && h.hide()
                            })),
                            l.push(t.attachEvent("onDataRender", function() {
                                h._editor && h._placeholder && !tt(h._placeholder, t.$root) && a.$grid_data.appendChild(h._placeholder)
                            })),
                            this.init = function() {}
                    },
                    getState: function() {
                        return {
                            editor: this._editor,
                            editorType: this._editorType,
                            placeholder: this._placeholder,
                            id: this._itemId,
                            columnName: this._columnName
                        }
                    },
                    startEdit: function(u, h) {
                        if (this.isVisible() && this.save(),
                            !d.exists(u))
                            return;
                        var _ = {
                            id: u,
                            columnName: h
                        };
                        if (t.isReadonly(d.getItem(u)))
                            return void this.callEvent("onEditPrevent", [_]);
                        if (this.callEvent("onBeforeEditStart", [_]) === !1)
                            return void this.callEvent("onEditPrevent", [_]);
                        const f = this.show(_.id, _.columnName);
                        f && f.then ? f.then((function() {
                                this.setValue(),
                                    this.callEvent("onEditStart", [_])
                            }
                        ).bind(this)) : (this.setValue(),
                            this.callEvent("onEditStart", [_]))
                    },
                    isVisible: function() {
                        return !(!this._editor || !tt(this._placeholder, t.$root))
                    },
                    show: function(u, h) {
                        this.isVisible() && this.save();
                        var _ = {
                            id: u,
                            columnName: h
                        }
                            , f = a.getColumn(_.columnName)
                            , y = this.getEditorConfig(f.name);
                        if (!y)
                            return;
                        var v = a.$getConfig().editor_types[y.type]
                            , b = r(_.id, _.columnName);
                        a.$grid_data.appendChild(b);
                        const g = (function() {
                                this._editor = v,
                                    this._placeholder = b,
                                    this._itemId = _.id,
                                    this._columnName = _.columnName,
                                    this._editorType = y.type;
                                var p = n.getMapping();
                                p.onShow && p.onShow(this, b, a),
                                    b._onReMount = (function() {
                                            this.setValue()
                                        }
                                    ).bind(this)
                            }
                        ).bind(this)
                            , m = v.show(_.id, f, y, b);
                        if (m && m.then)
                            return m.then( () => {
                                    g()
                                }
                            );
                        g()
                    },
                    setValue: function() {
                        var u = this.getState()
                            , h = u.id
                            , _ = u.columnName
                            , f = a.getColumn(_)
                            , y = d.getItem(h)
                            , v = this.getEditorConfig(_);
                        if (v) {
                            var b = y[v.map_to];
                            v.map_to == "auto" && (b = d.getItem(h)),
                                this._editor.set_value(b, h, f, this._placeholder),
                                this.focus()
                        }
                    },
                    focus: function() {
                        this._editor.focus(this._placeholder)
                    },
                    getValue: function() {
                        var u = a.getColumn(this._columnName);
                        return this._editor.get_value(this._itemId, u, this._placeholder)
                    },
                    _getItemValue: function() {
                        var u = this.getEditorConfig(this._columnName);
                        if (u) {
                            var h = t.getTask(this._itemId)[u.map_to];
                            return u.map_to == "auto" && (h = d.getItem(this._itemId)),
                                h
                        }
                    },
                    isChanged: function() {
                        var u = a.getColumn(this._columnName)
                            , h = this._getItemValue();
                        return this._editor.is_changed(h, this._itemId, u, this._placeholder)
                    },
                    hide: function() {
                        if (this._itemId) {
                            var u = this._itemId
                                , h = this._columnName
                                , _ = n.getMapping();
                            _.onHide && _.onHide(this, this._placeholder, a),
                                this._itemId = null,
                                this._columnName = null,
                                this._editorType = null,
                            this._placeholder && (this._editor && this._editor.hide && this._editor.hide(this._placeholder),
                                this._editor = null,
                            this._placeholder.parentNode && this._placeholder.parentNode.removeChild(this._placeholder),
                                this._placeholder = null,
                                this.callEvent("onEditEnd", [{
                                    id: u,
                                    columnName: h
                                }]))
                        }
                    },
                    save: function() {
                        if (this.isVisible() && d.exists(this._itemId) && this.isChanged()) {
                            var u = this._itemId
                                , h = this._columnName;
                            if (d.exists(u)) {
                                var _ = d.getItem(u)
                                    , f = this.getEditorConfig(h)
                                    , y = {
                                    id: u,
                                    columnName: h,
                                    newValue: this.getValue(),
                                    oldValue: this._getItemValue()
                                };
                                if (this.callEvent("onBeforeSave", [y]) !== !1 && (!this._editor.is_valid || this._editor.is_valid(y.newValue, y.id, a.getColumn(h), this._placeholder))) {
                                    var v = f.map_to
                                        , b = y.newValue;
                                    v != "auto" ? (_[v] = b,
                                        s(_, v, t.config.inline_editors_date_processing),
                                        d.updateItem(u)) : this._editor.save(u, a.getColumn(h), this._placeholder),
                                        this.callEvent("onSave", [y])
                                }
                                this.hide()
                            }
                        } else
                            this.hide()
                    },
                    _findEditableCell: function(u, h) {
                        var _ = u
                            , f = a.getGridColumns()[_]
                            , y = f ? f.name : null;
                        if (y) {
                            for (; y && !this.getEditorConfig(y); )
                                y = this._findEditableCell(u + h, h);
                            return y
                        }
                        return null
                    },
                    getNextCell: function(u) {
                        return this._findEditableCell(a.getColumnIndex(this._columnName, !0) + u, u)
                    },
                    getFirstCell: function() {
                        return this._findEditableCell(0, 1)
                    },
                    getLastCell: function() {
                        return this._findEditableCell(a.getGridColumns().length - 1, -1)
                    },
                    editNextCell: function(u) {
                        var h = this.getNextCell(1);
                        if (h) {
                            var _ = this.getNextCell(1);
                            _ && this.getEditorConfig(_) && this.startEdit(this._itemId, _)
                        } else if (u && this.moveRow(1)) {
                            var f = this.moveRow(1);
                            (h = this.getFirstCell()) && this.getEditorConfig(h) && this.startEdit(f, h)
                        }
                    },
                    editPrevCell: function(u) {
                        var h = this.getNextCell(-1);
                        if (h) {
                            var _ = this.getNextCell(-1);
                            _ && this.getEditorConfig(_) && this.startEdit(this._itemId, _)
                        } else if (u && this.moveRow(-1)) {
                            var f = this.moveRow(-1);
                            (h = this.getLastCell()) && this.getEditorConfig(h) && this.startEdit(f, h)
                        }
                    },
                    moveRow: function(u) {
                        for (var h = u > 0 ? t.getNext : t.getPrev, _ = (h = t.bind(h, t))(this._itemId); t.isTaskExists(_) && t.isReadonly(t.getTask(_)); )
                            _ = h(_);
                        return _
                    },
                    editNextRow: function(u) {
                        var h = this.getState().id;
                        if (t.isTaskExists(h)) {
                            var _ = null;
                            _ = u ? this.moveRow(1) : t.getNext(h),
                            t.isTaskExists(_) && this.startEdit(_, this._columnName)
                        }
                    },
                    editPrevRow: function(u) {
                        var h = this.getState().id;
                        if (t.isTaskExists(h)) {
                            var _ = null;
                            _ = u ? this.moveRow(-1) : t.getPrev(h),
                            t.isTaskExists(_) && this.startEdit(_, this._columnName)
                        }
                    },
                    detachStore: function() {
                        o.forEach(function(u) {
                            d.detachEvent(u)
                        }),
                            l.forEach(function(u) {
                                t.detachEvent(u)
                            }),
                            o = [],
                            l = [],
                            d = null,
                            this.hide()
                    },
                    destructor: function() {
                        this.detachStore(),
                            this.detachAllEvents()
                    }
                };
                return O(c, n),
                    O(c, e),
                    c
            }
        };
        return O(i, n),
            O(i, e),
            i
    }
    function Ot(t, n, e, i, a) {
        if (!t.start_date || !t.end_date)
            return null;
        var r = e.getItemTop(t.id)
            , s = e.getItemHeight(t.id);
        if (r > n.y_end || r + s < n.y)
            return !1;
        var o = e.posFromDate(t.start_date)
            , l = e.posFromDate(t.end_date)
            , d = Math.min(o, l) - 200
            , c = Math.max(o, l) + 200;
        return !(d > n.x_end || c < n.x)
    }
    function Ve(t) {
        function n(r, s, o) {
            if (t._isAllowedUnscheduledTask(r) || !t._isTaskInTimelineLimits(r))
                return;
            var l = s.getItemPosition(r)
                , d = o
                , c = s.$getTemplates()
                , u = t.getTaskType(r.type)
                , h = s.getBarHeight(r.id, u == d.types.milestone)
                , _ = 0;
            u == d.types.milestone && (_ = (h - l.height) / 2);
            var f = Math.floor((s.getItemHeight(r.id) - h) / 2);
            const y = t.config.baselines && r.baselines && r.baselines.length
                , v = t.config.baselines && (t.config.baselines.render_mode == "separateRow" || t.config.baselines.render_mode == "individualRow");
            if (y && v && r.bar_height !== "full" && r.bar_height < r.row_height)
                if (u === d.types.milestone) {
                    let T = s.getBarHeight(r.id, !0)
                        , E = Math.sqrt(2 * T * T);
                    f = Math.floor((E - h) / 2) + 2
                } else
                    f = 2;
            u == d.types.milestone && (l.left -= Math.round(h / 2),
                l.width = h);
            var b = document.createElement("div")
                , g = Math.round(l.width);
            s.$config.item_attribute && (b.setAttribute(s.$config.item_attribute, r.id),
                b.setAttribute(s.$config.bind + "_id", r.id)),
            d.show_progress && u != d.types.milestone && function(T, E, C, D, A) {
                var I = 1 * T.progress || 0;
                C = Math.max(C, 0);
                var M = document.createElement("div")
                    , L = Math.round(C * I);
                L = Math.min(C, L),
                    M.style.width = L + "px",
                    M.className = "gantt_task_progress",
                    M.innerHTML = A.progress_text(T.start_date, T.end_date, T),
                D.rtl && (M.style.position = "absolute",
                    M.style.right = "0px");
                var N = document.createElement("div");
                N.className = "gantt_task_progress_wrapper",
                    N.appendChild(M),
                    E.appendChild(N);
                const P = !t.isReadonly(T)
                    , R = t.ext.dragTimeline && t.ext.dragTimeline._isDragInProgress();
                if (t.config.drag_progress && (P || R)) {
                    var B = document.createElement("div")
                        , H = L;
                    D.rtl && (H = C - L),
                        B.style.left = H + "px",
                        B.className = "gantt_task_progress_drag",
                        B.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="9" viewBox="0 0 12 9" fill="none">
<path d="M5.58397 1.52543C5.78189 1.22856 6.21811 1.22856 6.41602 1.52543L10.5475 7.72265C10.769 8.05493 10.5308 8.5 10.1315 8.5L1.86852 8.5C1.46917 8.5 1.23097 8.05493 1.45249 7.72265L5.58397 1.52543Z" fill="var(--dhx-gantt-progress-handle-background)" stroke="var(--dhx-gantt-progress-handle-border)"/>
</svg>`,
                        M.appendChild(B),
                        E.appendChild(B)
                }
            }(r, b, g, d, c);
            var m = function(T, E, C) {
                var D = document.createElement("div");
                return t.getTaskType(T.type) != t.config.types.milestone ? D.innerHTML = C.task_text(T.start_date, T.end_date, T) : t.getTaskType(T.type) == t.config.types.milestone && E && (D.style.height = D.style.width = E + "px"),
                    D.className = "gantt_task_content",
                    D
            }(r, g, c);
            b.appendChild(m);
            var p = function(T, E, C, D) {
                var A = D.$getConfig()
                    , I = [T];
                E && I.push(E);
                var M = t.getState()
                    , L = t.getTask(C);
                if (t.getTaskType(L.type) == A.types.milestone ? I.push("gantt_milestone") : t.getTaskType(L.type) == A.types.project && I.push("gantt_project"),
                    I.push("gantt_bar_" + t.getTaskType(L.type)),
                t.isSummaryTask(L) && I.push("gantt_dependent_task"),
                t.isSplitTask(L) && (A.open_split_tasks && !L.$open || !A.open_split_tasks) && I.push("gantt_split_parent"),
                A.select_task && t.isSelectedTask(C) && I.push("gantt_selected"),
                C == M.drag_id && (I.push("gantt_drag_" + M.drag_mode),
                M.touch_drag && I.push("gantt_touch_" + M.drag_mode)),
                M.link_source_id == C && (I.push("gantt_link_source"),
                    M.link_from_start ? I.push("gantt_link_from_start") : I.push("gantt_link_from_end")),
                M.link_target_id == C && I.push("gantt_link_target"),
                A.highlight_critical_path && t.isCriticalTask && t.isCriticalTask(L) && I.push("gantt_critical_task"),
                M.link_landing_area && M.link_target_id && M.link_source_id && M.link_target_id != M.link_source_id && (M.link_target_id == C || M.link_source_id == C)) {
                    var N = M.link_source_id
                        , P = M.link_from_start
                        , R = M.link_to_start
                        , B = "";
                    B = t.isLinkAllowed(N, C, P, R) ? R ? "link_start_allow" : "link_finish_allow" : R ? "link_start_deny" : "link_finish_deny",
                        I.push(B)
                }
                return I.join(" ")
            }("gantt_task_line", c.task_class(r.start_date, r.end_date, r), r.id, s);
            (r.color || r.progressColor || r.textColor) && (p += " gantt_task_inline_color"),
            l.width < 20 && (p += " gantt_thin_task"),
                b.className = p;
            var k = ["left:" + l.left + "px", "top:" + (f + l.top) + "px", "height:" + h + "px", "line-height:" + Math.max(h < 30 ? h - 2 : h, 0) + "px", "width:" + g + "px"];
            b.style.cssText = k.join(";"),
            r.color && b.style.setProperty("--dhx-gantt-task-background", r.color),
            r.textColor && b.style.setProperty("--dhx-gantt-task-color", r.textColor),
            r.progressColor && b.style.setProperty("--dhx-gantt-task-progress-color", r.progressColor);
            var w = function(T, E, C, D) {
                var A = "gantt_left " + i(!E.rtl, T)
                    , I = null;
                return D && (I = {
                    type: "marginRight",
                    value: D
                }),
                    e(T, C.leftside_text, A, I)
            }(r, d, c, _);
            w && b.appendChild(w),
                w = function(T, E, C, D) {
                    var A = "gantt_right " + i(!!E.rtl, T)
                        , I = null;
                    return D && (I = {
                        type: "marginLeft",
                        value: D
                    }),
                        e(T, C.rightside_text, A, I)
                }(r, d, c, _),
            w && b.appendChild(w),
                t._waiAria.setTaskBarAttr(r, b);
            var x = t.getState();
            const $ = !t.isReadonly(r)
                , S = t.ext.dragTimeline && t.ext.dragTimeline._isDragInProgress();
            return ($ || S) && (d.drag_resize && !t.isSummaryTask(r) && u != d.types.milestone && a(b, "gantt_task_drag", r, function(T) {
                var E = document.createElement("div");
                return E.className = T,
                    E
            }, d),
            d.drag_links && d.show_links && a(b, "gantt_link_control", r, function(T) {
                var E = document.createElement("div");
                E.className = T,
                    E.style.cssText = ["height:" + h + "px", "line-height:" + h + "px"].join(";");
                var C = document.createElement("div");
                C.className = "gantt_link_point";
                var D = !1;
                return x.link_source_id && d.touch && (D = !0),
                    C.style.display = D ? "block" : "",
                    E.appendChild(C),
                    E
            }, d, _)),
                b
        }
        function e(r, s, o, l) {
            if (!s)
                return null;
            var d = s(r.start_date, r.end_date, r);
            if (!d)
                return null;
            var c = document.createElement("div");
            return c.className = "gantt_side_content " + o,
                c.innerHTML = d,
            l && (c.style[l.type] = Math.abs(l.value) + "px"),
                c
        }
        function i(r, s) {
            var o = r ? {
                $source: [t.config.links.start_to_start],
                $target: [t.config.links.start_to_start, t.config.links.finish_to_start]
            } : {
                $source: [t.config.links.finish_to_start, t.config.links.finish_to_finish],
                $target: [t.config.links.finish_to_finish]
            };
            for (var l in o)
                for (var d = s[l], c = 0; c < d.length; c++)
                    for (var u = t.getLink(d[c]), h = 0; h < o[l].length; h++)
                        if (u.type == o[l][h])
                            return "gantt_link_crossing";
            return ""
        }
        function a(r, s, o, l, d, c) {
            var u, h = t.getState();
            +o.start_date >= +h.min_date && ((u = l([s, d.rtl ? "task_right" : "task_left", "task_start_date"].join(" "))).setAttribute("data-bind-property", "start_date"),
            c && (u.style.marginLeft = c + "px"),
                r.appendChild(u)),
            +o.end_date <= +h.max_date && ((u = l([s, d.rtl ? "task_left" : "task_right", "task_end_date"].join(" "))).setAttribute("data-bind-property", "end_date"),
            c && (u.style.marginRight = c + "px"),
                r.appendChild(u))
        }
        return function(r, s, o) {
            var l = (o = s.$getConfig()).type_renderers[t.getTaskType(r.type)]
                , d = n;
            return l ? l.call(t, r, function(c) {
                return d.call(t, c, s, o)
            }, s) : d.call(t, r, s, o)
        }
    }
    function cr(t, n, e, i, a) {
        if (!(t.start_date && t.end_date || t.$auto_start_date && t.$auto_end_date))
            return null;
        var r = e.getItemTop(t.id)
            , s = e.getItemHeight(t.id);
        if (r > n.y_end || r + s < n.y)
            return !1;
        const o = [];
        t.start_date && o.push(e.posFromDate(t.start_date)),
        t.end_date && o.push(e.posFromDate(t.end_date)),
        t.$auto_start_date && o.push(e.posFromDate(t.$auto_start_date)),
        t.$auto_end_date && o.push(e.posFromDate(t.$auto_end_date));
        var l = Math.min(...o) - 200
            , d = Math.max(...o) + 200;
        return !(l > n.x_end || d < n.x)
    }
    function ur(t) {
        function n(r, s, o) {
            if (t._isAllowedUnscheduledTask(r) || !t._isTaskInTimelineLimits(r))
                return;
            var l = s.getItemPosition(r)
                , d = o
                , c = s.$getTemplates()
                , u = t.getTaskType(r.type)
                , h = s.getBarHeight(r.id, u == d.types.milestone)
                , _ = 0;
            u == d.types.milestone && (_ = (h - l.height) / 2);
            var f = Math.floor((s.getItemHeight(r.id) - h) / 2);
            const y = t.config.baselines && r.baselines && r.baselines.length
                , v = t.config.baselines && (t.config.baselines.render_mode == "separateRow" || t.config.baselines.render_mode == "individualRow");
            if (y && v && r.bar_height !== "full" && r.bar_height < r.row_height)
                if (u === d.types.milestone) {
                    let T = s.getBarHeight(r.id, !0)
                        , E = Math.sqrt(2 * T * T);
                    f = Math.floor((E - h) / 2) + 2
                } else
                    f = 2;
            var b = document.createElement("div")
                , g = Math.round(l.width);
            s.$config.item_attribute && (b.setAttribute(s.$config.item_attribute, r.id),
                b.setAttribute(s.$config.bind + "_id", r.id));
            const m = document.createElement("div");
            m.classList.add("gantt_task_line_planned", "gantt_task_line", "gantt_project");
            const p = s.getItemPosition(r, r.start_date, r.end_date);
            m.style.cssText = ["position:absolute", "left:" + p.left + "px", "top:" + (f / 2 + 1) + "px", "height:5px", "width:" + p.width + "px"].join(";"),
                m.style.setProperty("--dhx-gantt-scheduled-summary-bracket-size", "10px"),
                b.appendChild(m);
            const k = document.createElement("div")
                , w = s.getItemPosition(r, r.$auto_start_date || r.start_date, r.$auto_end_date || r.end_date);
            k.classList.add("gantt_task_line_actual", "gantt_task_line", "gantt_project"),
                k.style.cssText = ["position:absolute", "left:" + w.left + "px", "top:16px", "height:8px", "width:" + w.width + "px"].join(";"),
                b.appendChild(k),
            d.show_progress && u != d.types.milestone && function(T, E, C, D, A) {
                var I = 1 * T.progress || 0;
                C = Math.max(C - 2, 0);
                var M = document.createElement("div")
                    , L = Math.round(C * I);
                L = Math.min(C, L),
                T.progressColor && (M.style.backgroundColor = T.progressColor,
                    M.style.opacity = 1),
                    M.style.width = L + "px",
                    M.className = "gantt_task_progress",
                    M.innerHTML = A.progress_text(T.start_date, T.end_date, T),
                D.rtl && (M.style.position = "absolute",
                    M.style.right = "0px");
                var N = document.createElement("div");
                if (N.className = "gantt_task_progress_wrapper",
                    N.appendChild(M),
                    E.appendChild(N),
                t.config.drag_progress && !t.isReadonly(T)) {
                    var P = document.createElement("div")
                        , R = L;
                    D.rtl && (R = C - L),
                        P.style.left = R + "px",
                        P.className = "gantt_task_progress_drag",
                        M.appendChild(P),
                        E.appendChild(P)
                }
            }(r, k, g, d, c);
            var x = function(T, E, C, D) {
                var A = D.$getConfig()
                    , I = [T];
                E && I.push(E);
                var M = t.getState()
                    , L = t.getTask(C);
                if (t.getTaskType(L.type) == A.types.milestone ? I.push("gantt_milestone") : t.getTaskType(L.type) == A.types.project && I.push("gantt_project"),
                    I.push("gantt_bar_" + t.getTaskType(L.type)),
                t.isSummaryTask(L) && I.push("gantt_dependent_task"),
                t.isSplitTask(L) && (A.open_split_tasks && !L.$open || !A.open_split_tasks) && I.push("gantt_split_parent"),
                A.select_task && t.isSelectedTask(C) && I.push("gantt_selected"),
                C == M.drag_id && (I.push("gantt_drag_" + M.drag_mode),
                M.touch_drag && I.push("gantt_touch_" + M.drag_mode)),
                M.link_source_id == C && I.push("gantt_link_source"),
                M.link_target_id == C && I.push("gantt_link_target"),
                A.highlight_critical_path && t.isCriticalTask && t.isCriticalTask(L) && I.push("gantt_critical_task"),
                M.link_landing_area && M.link_target_id && M.link_source_id && M.link_target_id != M.link_source_id && (M.link_target_id == C || M.link_source_id == C)) {
                    var N = M.link_source_id
                        , P = M.link_from_start
                        , R = M.link_to_start
                        , B = "";
                    B = t.isLinkAllowed(N, C, P, R) ? R ? "link_start_allow" : "link_finish_allow" : R ? "link_start_deny" : "link_finish_deny",
                        I.push(B)
                }
                return I.join(" ")
            }("gantt_task_line", c.task_class(r.$auto_start_date || r.start_date, r.$auto_end_date || r.end_date, r), r.id, s);
            (r.color || r.progressColor || r.textColor) && (x += " gantt_task_inline_color"),
            l.width < 20 && (x += " gantt_thin_task"),
            (r.start_date > r.$auto_start_date || r.end_date < r.$auto_end_date) && (x += " gantt_project_scheduling_conflict"),
                b.className = x,
                b.style.top = f + l.top + "px",
                b.style.height = (u == d.types.milestone ? l.height : h) + "px",
            r.color && b.style.setProperty("--dhx-gantt-task-background", r.color),
            r.textColor && b.style.setProperty("--dhx-gantt-task-color", r.textColor),
            r.progressColor && b.style.setProperty("--dhx-gantt-task-progress-color", r.progressColor);
            var $ = function(T, E, C, D) {
                var A = "gantt_left " + i(!E.rtl, T)
                    , I = null;
                return D && (I = {
                    type: "marginRight",
                    value: D
                }),
                    e(T, C.leftside_text, A, I)
            }(r, d, c, _);
            $ && m.appendChild($),
                $ = function(T, E, C, D) {
                    var A = "gantt_right " + i(!!E.rtl, T)
                        , I = null;
                    return D && (I = {
                        type: "marginLeft",
                        value: D
                    }),
                        e(T, C.rightside_text, A, I)
                }(r, d, c, _),
            $ && m.appendChild($),
                t._waiAria.setTaskBarAttr(r, b);
            var S = t.getState();
            return t.isReadonly(r) || (d.drag_resize && a(m, "gantt_task_drag", r, function(T) {
                var E = document.createElement("div");
                return E.className = T,
                    E
            }, d),
            d.drag_links && d.show_links && a(m, "gantt_link_control", r, function(T) {
                var E = document.createElement("div");
                E.className = T,
                    E.style.cssText = ["height:" + h + "px", "line-height:" + h + "px"].join(";");
                var C = document.createElement("div");
                C.className = "gantt_link_point";
                var D = !1;
                return S.link_source_id && d.touch && (D = !0),
                    C.style.display = D ? "block" : "",
                    E.appendChild(C),
                    E
            }, d, _)),
                b
        }
        function e(r, s, o, l) {
            if (!s)
                return null;
            var d = s(r.start_date, r.end_date, r);
            if (!d)
                return null;
            var c = document.createElement("div");
            return c.className = "gantt_side_content " + o,
                c.innerHTML = d,
            l && (c.style[l.type] = Math.abs(l.value) + "px"),
                c
        }
        function i(r, s) {
            var o = r ? {
                $source: [t.config.links.start_to_start],
                $target: [t.config.links.start_to_start, t.config.links.finish_to_start]
            } : {
                $source: [t.config.links.finish_to_start, t.config.links.finish_to_finish],
                $target: [t.config.links.finish_to_finish]
            };
            for (var l in o)
                for (var d = s[l], c = 0; c < d.length; c++)
                    for (var u = t.getLink(d[c]), h = 0; h < o[l].length; h++)
                        if (u.type == o[l][h])
                            return "gantt_link_crossing";
            return ""
        }
        function a(r, s, o, l, d, c) {
            var u, h = t.getState();
            +o.start_date >= +h.min_date && ((u = l([s, d.rtl ? "task_right" : "task_left", "task_start_date"].join(" "))).setAttribute("data-bind-property", "start_date"),
            c && (u.style.marginLeft = c + "px"),
                r.appendChild(u)),
            +o.end_date <= +h.max_date && ((u = l([s, d.rtl ? "task_left" : "task_right", "task_end_date"].join(" "))).setAttribute("data-bind-property", "end_date"),
            c && (u.style.marginRight = c + "px"),
                r.appendChild(u))
        }
        return function(r, s, o) {
            var l = (o = s.$getConfig()).type_renderers[t.getTaskType(r.type)]
                , d = n;
            return l ? l.call(t, r, function(c) {
                return d.call(t, c, s, o)
            }, s) : d.call(t, r, s, o)
        }
    }
    function hr(t, n, e, i, a) {
        if (!a.isSplitTask(t))
            return !1;
        var r = a.getSubtaskDates(t.id);
        return Ot({
            id: t.id,
            start_date: r.start_date,
            end_date: r.end_date,
            parent: t.parent
        }, n, e)
    }
    function Ue(t, n, e) {
        return {
            top: n.getItemTop(t.id),
            height: n.getItemHeight(t.id),
            left: 0,
            right: 1 / 0
        }
    }
    function Dt(t, n) {
        var e = 0
            , i = t.left.length - 1;
        if (n)
            for (var a = 0; a < t.left.length; a++) {
                var r = t.left[a];
                if (r < n.x && (e = a),
                r > n.x_end) {
                    i = a;
                    break
                }
            }
        return {
            start: e,
            end: i
        }
    }
    function Ut(t, n, e, i) {
        var a = n.width[t];
        if (a <= 0)
            return !1;
        if (!i.config.smart_rendering || Vt(i))
            return !0;
        var r = n.left[t] - a
            , s = n.left[t] + a;
        return r <= e.x_end && s >= e.x
    }
    function _r(t, n) {
        var e = n.config.timeline_placeholder;
        if (t = t || [],
        e && t.filter(l => l.id === "timeline_placeholder_task").length === 0) {
            var i = n.getState()
                , a = null
                , r = i.min_date
                , s = i.max_date;
            t.length && (a = t[t.length - 1].id);
            var o = {
                start_date: r,
                end_date: s,
                row_height: e.height || 0,
                id: "timeline_placeholder_task",
                unscheduled: !0,
                lastTaskId: a,
                calendar_id: e.calendar || "global",
                $source: [],
                $target: []
            };
            t.push(o)
        }
    }
    function gr(t) {
        var n = {
            current_pos: null,
            dirs: {
                left: "left",
                right: "right",
                up: "up",
                down: "down"
            },
            path: [],
            clear: function() {
                this.current_pos = null,
                    this.path = []
            },
            point: function(a) {
                this.current_pos = t.copy(a)
            },
            get_lines: function(a) {
                this.clear(),
                    this.point(a[0]);
                for (var r = 1; r < a.length; r++)
                    this.line_to(a[r]);
                return this.get_path()
            },
            line_to: function(a) {
                var r = t.copy(a)
                    , s = this.current_pos
                    , o = this._get_line(s, r);
                this.path.push(o),
                    this.current_pos = r
            },
            get_path: function() {
                return this.path
            },
            get_wrapper_sizes: function(a, r, s) {
                var o, l = r.$getConfig().link_wrapper_width, d = a.y - l / 2;
                switch (a.direction) {
                    case this.dirs.left:
                        o = {
                            top: d,
                            height: l,
                            lineHeight: l,
                            left: a.x - a.size - l / 2,
                            width: a.size + l
                        };
                        break;
                    case this.dirs.right:
                        o = {
                            top: d,
                            lineHeight: l,
                            height: l,
                            left: a.x - l / 2,
                            width: a.size + l
                        };
                        break;
                    case this.dirs.up:
                        o = {
                            top: d - a.size,
                            lineHeight: a.size + l,
                            height: a.size + l,
                            left: a.x - l / 2,
                            width: l
                        };
                        break;
                    case this.dirs.down:
                        o = {
                            top: d,
                            lineHeight: a.size + l,
                            height: a.size + l,
                            left: a.x - l / 2,
                            width: l
                        }
                }
                return o
            },
            get_line_sizes: function(a, r) {
                var s, o = r.$getConfig(), l = o.link_line_width, d = o.link_wrapper_width, c = a.size + l;
                switch (a.direction) {
                    case this.dirs.left:
                    case this.dirs.right:
                        s = {
                            height: l,
                            width: c,
                            marginTop: (d - l) / 2,
                            marginLeft: (d - l) / 2
                        };
                        break;
                    case this.dirs.up:
                    case this.dirs.down:
                        s = {
                            height: c,
                            width: l,
                            marginTop: (d - l) / 2,
                            marginLeft: (d - l) / 2
                        }
                }
                return s
            },
            render_line: function(a, r, s, o) {
                var l = this.get_wrapper_sizes(a, s, o)
                    , d = document.createElement("div");
                d.style.cssText = ["top:" + l.top + "px", "left:" + l.left + "px", "height:" + l.height + "px", "width:" + l.width + "px"].join(";"),
                    d.className = "gantt_line_wrapper";
                var c = this.get_line_sizes(a, s)
                    , u = document.createElement("div");
                return u.style.cssText = ["height:" + c.height + "px", "width:" + c.width + "px", "margin-top:" + c.marginTop + "px", "margin-left:" + c.marginLeft + "px"].join(";"),
                    u.className = "gantt_link_line_" + a.direction,
                    d.appendChild(u),
                    d
            },
            render_corner: function(a, r) {
                const s = a.radius
                    , o = r.$getConfig()
                    , l = o.link_line_width || 2
                    , d = document.createElement("div");
                let c, u;
                return d.classList.add("gantt_link_corner"),
                    d.classList.add(`gantt_link_corner_${a.direction.from}_${a.direction.to}`),
                    d.style.width = `${s}px`,
                    d.style.height = `${s}px`,
                    a.direction.from === "right" && a.direction.to === "down" ? (c = "Right",
                        u = "Top",
                        d.style.left = a.x - o.link_line_width / 2 + "px",
                        d.style.top = `${a.y}px`) : a.direction.from === "down" && a.direction.to === "right" ? (c = "Left",
                        u = "Bottom",
                        d.style.left = a.x - o.link_line_width / 2 + "px",
                        d.style.top = `${a.y}px`) : a.direction.from === "right" && a.direction.to === "up" ? (c = "Right",
                        u = "Bottom",
                        d.style.left = a.x - o.link_line_width / 2 + "px",
                        d.style.top = a.y - s + "px") : a.direction.from === "up" && a.direction.to === "right" ? (c = "Left",
                        u = "Top",
                        d.style.left = a.x - o.link_line_width / 2 + "px",
                        d.style.top = a.y - s + "px") : a.direction.from === "left" && a.direction.to === "down" ? (c = "Left",
                        u = "Top",
                        d.style.left = a.x - s - o.link_line_width / 2 + "px",
                        d.style.top = `${a.y}px`) : a.direction.from === "down" && a.direction.to === "left" ? (c = "Right",
                        u = "Bottom",
                        d.style.left = a.x - s - o.link_line_width / 2 + "px",
                        d.style.top = `${a.y}px`) : a.direction.from === "left" && a.direction.to === "up" ? (c = "Left",
                        u = "Bottom",
                        d.style.left = a.x - s - o.link_line_width / 2 + "px",
                        d.style.top = a.y - s + "px") : a.direction.from === "up" && a.direction.to === "left" && (c = "Right",
                        u = "Top",
                        d.style.left = a.x - s - o.link_line_width / 2 + "px",
                        d.style.top = a.y - s + "px"),
                    d.style[`border${u}Width`] = `${l}px`,
                    d.style[`border${c}Width`] = `${l}px`,
                    d.style[`border${c}Style`] = "solid",
                    d.style[`border${u}Style`] = "solid",
                    d.style[`border${u}${c}Radius`] = `${s}px`,
                    d
            },
            render_arrow(a, r) {
                var s = document.createElement("div")
                    , o = a.y
                    , l = a.x
                    , d = r.link_arrow_size;
                s.style.setProperty("--dhx-gantt-icon-size", `${d}px`);
                var c = "gantt_link_arrow gantt_link_arrow_" + a.direction;
                return s.style.top = o + "px",
                    s.style.left = l + "px",
                    s.className = c,
                    s
            },
            _get_line: function(a, r) {
                var s = this.get_direction(a, r)
                    , o = {
                    x: a.x,
                    y: a.y,
                    direction: this.get_direction(a, r)
                };
                return s == this.dirs.left || s == this.dirs.right ? o.size = Math.abs(a.x - r.x) : o.size = Math.abs(a.y - r.y),
                    o
            },
            get_direction: function(a, r) {
                return r.x < a.x ? this.dirs.left : r.x > a.x ? this.dirs.right : r.y > a.y ? this.dirs.down : this.dirs.up
            }
        }
            , e = {
            path: [],
            clear: function() {
                this.path = []
            },
            current: function() {
                return this.path[this.path.length - 1]
            },
            point: function(a) {
                return a ? (this.path.push(t.copy(a)),
                    a) : this.current()
            },
            point_to: function(a, r, s) {
                s = s ? {
                    x: s.x,
                    y: s.y
                } : t.copy(this.point());
                var o = n.dirs;
                switch (a) {
                    case o.left:
                        s.x -= r;
                        break;
                    case o.right:
                        s.x += r;
                        break;
                    case o.up:
                        s.y -= r;
                        break;
                    case o.down:
                        s.y += r
                }
                return this.point(s)
            },
            get_points: function(a, r, s, o) {
                var l = this.get_endpoint(a, r, s, o)
                    , d = t.config
                    , c = l.e_y - l.y
                    , u = l.e_x - l.x
                    , h = n.dirs
                    , _ = r.getItemHeight(a.source);
                this.clear(),
                    this.point({
                        x: l.x,
                        y: l.y
                    });
                var f = 2 * d.link_arrow_size
                    , y = this.get_line_type(a, r.$getConfig())
                    , v = l.e_x > l.x;
                if (y.from_start && y.to_start)
                    this.point_to(h.left, f),
                        v ? (this.point_to(h.down, c),
                            this.point_to(h.right, u)) : (this.point_to(h.right, u),
                            this.point_to(h.down, c)),
                        this.point_to(h.right, f);
                else if (!y.from_start && y.to_start)
                    if (c !== 0 && (v = l.e_x > l.x + 2 * f),
                        this.point_to(h.right, f),
                        v)
                        u -= f,
                            this.point_to(h.down, c),
                            this.point_to(h.right, u);
                    else {
                        u -= 2 * f;
                        var b = c > 0 ? 1 : -1;
                        this.point_to(h.down, b * (_ / 2)),
                            this.point_to(h.right, u),
                            this.point_to(h.down, b * (Math.abs(c) - _ / 2)),
                            this.point_to(h.right, f)
                    }
                else
                    y.from_start || y.to_start ? y.from_start && !y.to_start && (c !== 0 && (v = l.e_x > l.x - 2 * f),
                        this.point_to(h.left, f),
                        v ? (u += 2 * f,
                            b = c > 0 ? 1 : -1,
                            this.point_to(h.down, b * (_ / 2)),
                            this.point_to(h.right, u),
                            this.point_to(h.down, b * (Math.abs(c) - _ / 2)),
                            this.point_to(h.left, f)) : (u += f,
                            this.point_to(h.down, c),
                            this.point_to(h.right, u))) : (this.point_to(h.right, f),
                        v ? (this.point_to(h.right, u),
                            this.point_to(h.down, c)) : (this.point_to(h.down, c),
                            this.point_to(h.right, u)),
                        this.point_to(h.left, f));
                return this.path
            },
            get_line_type: function(a, r) {
                var s = r.links
                    , o = !1
                    , l = !1;
                return a.type == s.start_to_start ? o = l = !0 : a.type == s.finish_to_finish ? o = l = !1 : a.type == s.finish_to_start ? (o = !1,
                    l = !0) : a.type == s.start_to_finish ? (o = !0,
                    l = !1) : t.assert(!1, "Invalid link type"),
                r.rtl && (o = !o,
                    l = !l),
                    {
                        from_start: o,
                        to_start: l
                    }
            },
            get_endpoint: function(a, r, s, o) {
                var l = r.$getConfig()
                    , d = this.get_line_type(a, l)
                    , c = d.from_start
                    , u = d.to_start
                    , h = i(s, r, l)
                    , _ = i(o, r, l);
                return {
                    x: c ? h.left : h.left + h.width,
                    e_x: u ? _.left : _.left + _.width,
                    y: h.top + h.rowHeight / 2 - 1,
                    e_y: _.top + _.rowHeight / 2 - 1
                }
            }
        };
        function i(a, r, s) {
            var o = r.getItemPosition(a);
            let l = ee(t, r, a)
                , d = l.maxHeight
                , c = l.splitChild;
            const u = t.config.baselines && (t.config.baselines.render_mode == "separateRow" || t.config.baselines.render_mode == "individualRow") && a.baselines && a.baselines.length;
            let h;
            l.shrinkHeight && (o.rowHeight = d);
            let _ = t.getTaskType(a.type) == s.types.milestone;
            if (_) {
                let f = r.getBarHeight(a.id, !0);
                h = Math.sqrt(2 * f * f),
                l.shrinkHeight && d < f && (f = d,
                    h = d),
                    o.left -= h / 2,
                    o.width = h
            }
            if (c)
                if (d >= o.height) {
                    const f = Ft(t, a.parent);
                    u || f ? _ ? (o.rowHeight = o.height + 4,
                        o.left += (o.width - o.rowHeight + 4) / 2,
                        o.width = o.rowHeight - 3) : o.rowHeight = o.height + 6 : _ && (o.left += (h - o.height) / 2)
                } else
                    o.rowHeight = d + 2,
                    _ && (o.left += (o.width - o.rowHeight + 4) / 2,
                        o.width = o.rowHeight - 3);
            else
                u && (o.rowHeight = o.height + 4);
            return o
        }
        return {
            render: function(a, r, s) {
                var o = t.getTask(a.source);
                if (o.hide_bar)
                    return;
                var l = t.getTask(a.target);
                if (l.hide_bar)
                    return;
                var d = e.get_endpoint(a, r, o, l)
                    , c = d.e_y - d.y;
                if (!(d.e_x - d.x) && !c)
                    return null;
                var u = e.get_points(a, r, o, l);
                const h = function(v, b) {
                    const g = b.link_radius || 4
                        , m = b.link_arrow_size || 6
                        , p = [];
                    for (let w = 0; w < v.length; w++) {
                        const x = v[w]
                            , $ = v[w + 1];
                        if (!$ || b.link_radius <= 1)
                            p.push({
                                type: "line",
                                data: x
                            });
                        else if (x.direction !== $.direction) {
                            if (x.size < g || $.size < g) {
                                p.push({
                                    type: "line",
                                    data: x
                                });
                                continue
                            }
                            x.size -= g,
                                p.push({
                                    type: "line",
                                    data: x
                                });
                            let S = x.x
                                , T = x.y - b.link_line_width / 2;
                            switch (x.direction) {
                                case "right":
                                    S += x.size;
                                    break;
                                case "left":
                                    S -= x.size;
                                    break;
                                case "down":
                                    T += x.size;
                                    break;
                                case "up":
                                    T -= x.size
                            }
                            const E = {
                                x: S,
                                y: T,
                                direction: {
                                    from: x.direction,
                                    to: $.direction
                                },
                                radius: g
                            };
                            switch (p.push({
                                type: "corner",
                                data: E
                            }),
                                $.direction) {
                                case "right":
                                    $.x += g,
                                        $.size -= g;
                                    break;
                                case "left":
                                    $.x -= g,
                                        $.size -= g;
                                    break;
                                case "down":
                                    $.y += g,
                                        $.size -= g;
                                    break;
                                case "up":
                                    $.y -= g,
                                        $.size -= g
                            }
                        } else
                            p.push({
                                type: "line",
                                data: x
                            })
                    }
                    const k = v[v.length - 1];
                    if (k.direction === "right" || k.direction === "left") {
                        k.size -= 3 * m / 4;
                        let w = k.direction === "right" ? k.x + k.size : k.x - k.size - m / 2
                            , x = k.y - b.link_line_width / 2 - m / 2 + 1;
                        k.direction === "left" ? (x -= 1,
                            w -= 2) : w -= 1;
                        const $ = {
                            x: w,
                            y: x,
                            size: m,
                            direction: k.direction
                        };
                        p.push({
                            type: "line",
                            data: k
                        }),
                            p.push({
                                type: "arrow",
                                data: $
                            })
                    } else
                        p.push({
                            type: "line",
                            data: k
                        });
                    return p
                }(n.get_lines(u, r).filter(v => v.size > 0), s)
                    , _ = function(v, b, g, m) {
                    const p = document.createElement("div");
                    return v.forEach(k => {
                            let w;
                            k.type === "line" ? w = n.render_line(k.data, null, b, g.source) : k.type === "corner" ? w = n.render_corner(k.data, b) : k.type === "arrow" && (w = n.render_arrow(k.data, m)),
                                p.appendChild(w)
                        }
                    ),
                        p
                }(h, r, a, s);
                var f = "gantt_task_link";
                a.color && (f += " gantt_link_inline_color");
                var y = t.templates.link_class ? t.templates.link_class(a) : "";
                return y && (f += " " + y),
                s.highlight_critical_path && t.isCriticalLink && t.isCriticalLink(a) && (f += " gantt_critical_link"),
                    _.className = f,
                r.$config.link_attribute && (_.setAttribute(r.$config.link_attribute, a.id),
                    _.setAttribute("link_id", a.id)),
                a.color && _.style.setProperty("--dhx-gantt-link-background", a.color),
                    t._waiAria.linkAttr(a, _),
                    _
            },
            update: null,
            isInViewPort: qn,
            getVisibleRange: Gn()
        }
    }
    function fr(t, n, e, i, a) {
        if (a.$ui.getView("grid") && (a.config.keyboard_navigation && a.getSelectedId() || a.ext.inlineEditors && a.ext.inlineEditors.getState().id))
            return !!t.$expanded_branch;
        var r = e.getItemTop(t.id)
            , s = e.getItemHeight(t.id);
        return !(r > n.y_end || r + s < n.y)
    }
    function Kn(t) {
        let n = {};
        return t.$data.tasksStore.attachEvent("onStoreUpdated", function() {
            n = {}
        }),
            function(e, i, a, r) {
                const s = e.id + "_" + i + "_" + a.unit + "_" + a.step;
                let o;
                return o = n[s] ? n[s] : n[s] = function(l, d, c, u) {
                    let h, _ = !1, f = {};
                    t.config.process_resource_assignments && d === t.config.resource_property ? (h = l.$role == "task" ? t.getResourceAssignments(l.$resource_id, l.$task_id) : t.getResourceAssignments(l.id),
                        _ = !0) : h = l.$role == "task" ? [] : t.getTaskBy(d, l.id),
                        f = function($, S, T) {
                            const E = S.unit
                                , C = S.step
                                , D = {}
                                , A = {};
                            for (let I = 0; I < $.length; I++) {
                                const M = $[I];
                                let L = M;
                                if (T && (L = t.getTask(M.task_id)),
                                    L.unscheduled)
                                    continue;
                                let N = M.start_date || L.start_date
                                    , P = M.end_date || L.end_date;
                                T && (M.start_date && (N = new Date(Math.max(M.start_date.valueOf(), L.start_date.valueOf()))),
                                M.end_date && (P = new Date(Math.min(M.end_date.valueOf(), L.end_date.valueOf()))),
                                M.mode && M.mode == "fixedDates" && (N = M.start_date,
                                    P = M.end_date));
                                let R = Bt(S.trace_x, N.valueOf())
                                    , B = new Date(S.trace_x[R] || t.date[E + "_start"](new Date(N)))
                                    , H = new Date(Math.min(N.valueOf(), B.valueOf()))
                                    , F = t.config.work_time ? t.getTaskCalendar(L) : t;
                                for (A[F.id] = {}; H < P; ) {
                                    const G = A[F.id]
                                        , j = H.valueOf();
                                    H = t.date.add(H, C, E),
                                    G[j] !== !1 && (D[j] || (D[j] = {
                                        tasks: [],
                                        assignments: []
                                    }),
                                        D[j].tasks.push(L),
                                    T && D[j].assignments.push(M))
                                }
                            }
                            return D
                        }(h, c, _);
                    const y = c.unit
                        , v = c.step
                        , b = [];
                    let g, m, p, k, w;
                    const x = u.$getConfig();
                    for (let $ = 0; $ < c.trace_x.length; $++)
                        g = new Date(c.trace_x[$]),
                            m = t.date.add(g, v, y),
                            w = f[g.valueOf()] || {},
                            p = w.tasks || [],
                            k = w.assignments || [],
                            p.length || x.resource_render_empty_cells ? b.push({
                                start_date: g,
                                end_date: m,
                                tasks: p,
                                assignments: k
                            }) : b.push(null);
                    return b
                }(e, i, a, r),
                    o
            }
    }
    function pr(t, n, e, i) {
        var a = 100 * (1 - (1 * t || 0))
            , r = i.posFromDate(n)
            , s = i.posFromDate(e)
            , o = document.createElement("div");
        return o.className = "gantt_histogram_hor_bar",
            o.style.top = a + "%",
            o.style.left = r + "px",
            o.style.width = s - r + 1 + "px",
            o
    }
    function mr(t, n, e) {
        if (t === n)
            return null;
        var i = 1 - Math.max(t, n)
            , a = Math.abs(t - n)
            , r = document.createElement("div");
        return r.className = "gantt_histogram_vert_bar",
            r.style.top = 100 * i + "%",
            r.style.height = 100 * a + "%",
            r.style.left = e + "px",
            r
    }
    function vr(t) {
        var n = Kn(t)
            , e = {}
            , i = {}
            , a = {};
        function r(l, d) {
            var c = e[l];
            c && c[d] && c[d].parentNode && c[d].parentNode.removeChild(c[d])
        }
        function s(l, d, c, u, h, _, f) {
            var y = a[l.id];
            y && y.parentNode && y.parentNode.removeChild(y);
            var v = function(b, g, m, p) {
                for (var k = g.getScale(), w = document.createElement("div"), x = Dt(k, p), $ = x.start; $ <= x.end; $++) {
                    var S = k.trace_x[$]
                        , T = k.trace_x[$ + 1] || t.date.add(S, k.step, k.unit)
                        , E = k.trace_x[$].valueOf()
                        , C = Math.min(b[E] / m, 1) || 0;
                    if (C < 0)
                        return null;
                    var D = Math.min(b[T.valueOf()] / m, 1) || 0
                        , A = pr(C, S, T, g);
                    A && w.appendChild(A);
                    var I = mr(C, D, g.posFromDate(T));
                    I && w.appendChild(I)
                }
                return w
            }(c, h, _, f);
            return v && d && (v.setAttribute("data-resource-id", l.id),
                v.setAttribute(h.$config.item_attribute, l.id),
                v.style.position = "absolute",
                v.style.top = d.top + 1 + "px",
                v.style.height = h.getItemHeight(l.id) - 1 + "px",
                v.style.left = 0),
                v
        }
        function o(l, d, c, u, h, _, f) {
            var y = h.histogram_cell_class(_.start_date, _.end_date, l, _.tasks, _.assignments)
                , v = h.histogram_cell_label(_.start_date, _.end_date, l, _.tasks, _.assignments)
                , b = h.histogram_cell_allocated(_.start_date, _.end_date, l, _.tasks, _.assignments)
                , g = f.getItemHeight(l.id) - 1;
            if (y || v) {
                var m = document.createElement("div");
                return m.className = ["gantt_histogram_cell", y].join(" "),
                    m.setAttribute(f.$config.item_attribute, l.id),
                    m.style.cssText = ["left:" + d.left + "px", "width:" + d.width + "px", "height:" + g + "px", "line-height:" + g + "px", "top:" + (d.top + 1) + "px"].join(";"),
                v && (v = "<div class='gantt_histogram_label'>" + v + "</div>"),
                b && (v = "<div class='gantt_histogram_fill' style='height:" + 100 * Math.min(b / c || 0, 1) + "%;'></div>" + v),
                v && (m.innerHTML = v),
                    m
            }
            return null
        }
        return {
            render: function(l, d, c, u) {
                var h = d.$getTemplates()
                    , _ = d.getScale()
                    , f = n(l, c.resource_property, _, d)
                    , y = []
                    , v = {}
                    , b = l.capacity || d.$config.capacity || 24;
                e[l.id] = {},
                    i[l.id] = null,
                    a[l.id] = null;
                for (var g = !!u, m = Dt(_, u), p = m.start; p <= m.end; p++) {
                    var k = f[p];
                    if (k && (!g || Ut(p, _, u, t))) {
                        var w = h.histogram_cell_capacity(k.start_date, k.end_date, l, k.tasks, k.assignments);
                        v[k.start_date.valueOf()] = w || 0;
                        var x = d.getItemPosition(l, k.start_date, k.end_date)
                            , $ = o(l, x, b, 0, h, k, d);
                        $ && (y.push($),
                            e[l.id][p] = $)
                    }
                }
                var S = null;
                if (y.length) {
                    S = document.createElement("div");
                    for (var T = 0; T < y.length; T++)
                        S.appendChild(y[T]);
                    var E = s(l, x, v, 0, d, b, u);
                    E && (S.appendChild(E),
                        a[l.id] = E),
                        i[l.id] = S
                }
                return S
            },
            update: function(l, d, c, u, h) {
                var _ = c.$getTemplates()
                    , f = c.getScale()
                    , y = n(l, u.resource_property, f, c)
                    , v = l.capacity || c.$config.capacity || 24
                    , b = {}
                    , g = !!h
                    , m = Dt(f, h)
                    , p = {};
                if (e && e[l.id])
                    for (var k in e[l.id])
                        p[k] = k;
                for (var w = m.start; w <= m.end; w++) {
                    var x = y[w];
                    if (p[w] = !1,
                        x) {
                        var $ = _.histogram_cell_capacity(x.start_date, x.end_date, l, x.tasks, x.assignments);
                        b[x.start_date.valueOf()] = $ || 0;
                        var S = c.getItemPosition(l, x.start_date, x.end_date);
                        if (!g || Ut(w, f, h, t)) {
                            var T = e[l.id];
                            if (T && T[w])
                                T && T[w] && !T[w].parentNode && d.appendChild(T[w]);
                            else {
                                var E = o(l, S, v, 0, _, x, c);
                                E && (d.appendChild(E),
                                    e[l.id][w] = E)
                            }
                        } else
                            r(l.id, w)
                    }
                }
                for (var k in p)
                    p[k] !== !1 && r(l.id, k);
                var C = s(l, S, b, 0, c, v, h);
                C && (d.appendChild(C),
                    a[l.id] = C)
            },
            getRectangle: Ue,
            getVisibleRange: et
        }
    }
    function Ge(t, n, e, i, a, r) {
        const s = {
            id: t.id,
            parent: t.id
        };
        function o(c) {
            if (!(c[r.start_date] && c[r.end_date]))
                return !1;
            for (let u = 0; u < r.length; u++)
                if (!c[r[u]])
                    return !1;
            return !0
        }
        const l = o(t);
        let d = !1;
        return l && (s.start_date = t[r.start_date],
            s.end_date = t[r.end_date]),
        t.render == "split" && a.eachTask(function(c) {
            o(c) && (d = !0,
                s.start_date = s.start_date || c[r.start_date],
                s.end_date = s.end_date || c[r.end_date],
            s.start_date < c[r.start_date] && (s.start_date = c[r.start_date]),
            s.end_date > c[r.end_date] && (s.end_date = c[r.end_date]))
        }),
        !(!l && !d) && Ot(s, n, e)
    }
    function kr(t, n, e, i, a) {
        return a.config.auto_scheduling && a.config.auto_scheduling.show_constraints !== !1 ? Ge(t, n, e, 0, a, {
            start_date: "constraint_date",
            end_date: "constraint_date",
            additional_properties: ["constraint_type"]
        }) : !1
    }
    function yr(t) {
        const n = {};
        for (let i in t.config.constraint_types)
            n[t.config.constraint_types[i]] = i;
        function e(i, a, r) {
            const s = function(_) {
                const f = t.getConstraintType(_);
                return n[f].toLowerCase()
            }(i);
            if (s == "asap" || s == "alap")
                return !1;
            const o = document.createElement("div")
                , l = t.getTaskPosition(i, i.constraint_date, i.constraint_date);
            let {height: d, marginTop: c} = Ln(t, a, l, 30, i, r)
                , u = d
                , h = 0;
            switch (s) {
                case "snet":
                case "fnet":
                case "mso":
                    h = t.config.rtl ? 1 : -u - 1;
                    break;
                case "snlt":
                case "fnlt":
                case "mfo":
                    h = t.config.rtl ? -u - 1 : 1
            }
            switch (i.type === t.config.types.milestone && (c -= 1),
                o.style.height = d + "px",
                o.style.width = u + "px",
                o.style.left = l.left + "px",
                o.style.top = l.top + "px",
                o.style.marginLeft = h + "px",
                o.style.marginTop = c + "px",
                o.className = "gantt_constraint_marker gantt_constraint_marker_" + s,
                s) {
                case "snet":
                case "snlt":
                case "fnet":
                case "fnlt":
                    o.innerHTML = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Start No Later Than">
<line id="Line 3" x1="30.5" y1="6.92097e-08" x2="30.5" y2="32" stroke="#555D63" stroke-width="3" stroke-dasharray="3 3"/>
<path id="Vector" d="m 18.3979,23.5 v -6 H 3.05161 L 3,14.485 H 18.3979 V 8.5 L 27,16 Z" fill="#555D63"/>
</g>
</svg>
`;
                    break;
                case "mfo":
                case "mso":
                    o.innerHTML = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Must Start On ">
<path id="Vector" d="m 18.3979,23.5 v -6 H 3.05161 L 3,14.485 H 18.3979 V 8.5 L 27,16 Z" fill="#555D63"/>
<line id="line" x1="30.5" y1="-6.55671e-08" x2="30.5" y2="32" stroke="black" stroke-opacity="0.7" stroke-width="3"/>
</g>
</svg>
`
            }
            return o.setAttribute("data-task-id", i.id),
                o
        }
        return {
            render: function(i, a, r, s) {
                if (!t.config.auto_scheduling_compatibility && t.config.auto_scheduling && t.config.auto_scheduling.show_constraints !== !1) {
                    const o = document.createElement("div");
                    if (o.className = "gantt_constraint_nodes",
                        o.setAttribute("data-task-row-id", i.id),
                    i.constraint_date && i.constraint_type) {
                        const l = e(i, a);
                        l && o.appendChild(l)
                    }
                    if (ft(i)) {
                        const l = Ft(t, i.id);
                        t.eachTask(function(d) {
                            if (d.constraint_date && d.constraint_type) {
                                const c = e(d, a, l);
                                c && o.appendChild(c)
                            }
                        }, i.id)
                    }
                    if (o.childNodes.length)
                        return o
                }
            },
            isInViewPort: kr,
            getVisibleRange: et
        }
    }
    function br(t, n, e, i, a) {
        return Ge(t, n, e, 0, a, {
            start_date: "deadline",
            end_date: "deadline"
        })
    }
    function $r(t, n, e, i, a) {
        let r = !1;
        const s = {
            start_date: "start_date",
            end_date: "end_date"
        };
        return t.type == a.config.types.milestone && (s.end_date = s.start_date),
        t.baselines && (r = Xn(t, n, e, i, a, s)),
        ft(t) && a.eachTask(function(o) {
            r || o.baselines && o.baselines.length && (o.type == a.config.types.milestone && (s.end_date = s.start_date),
            Xn(o, n, e, i, a, s) && (r = !0))
        }, t.id),
            r
    }
    function Xn(t, n, e, i, a, r) {
        for (var s = 0; s < t.baselines.length; s++)
            if (Ge({
                id: t.id,
                parent: t.parent,
                start_date: t.baselines[s].start_date,
                end_date: t.baselines[s].end_date
            }, n, e, 0, a, r))
                return !0
    }
    const xr = {
        init: function(t, n) {
            var e = t.$services.getService("dnd");
            if (n.$config.bind && t.getDatastore(n.$config.bind)) {
                var i = new e(n.$grid_data,{
                    updates_per_second: 60
                });
                t.defined(n.$getConfig().dnd_sensitivity) && (i.config.sensitivity = n.$getConfig().dnd_sensitivity),
                    i.attachEvent("onBeforeDragStart", t.bind(function(o, l) {
                        var d = a(l);
                        if (!d || (t.hideQuickInfo && t.hideQuickInfo(),
                            dt(l.target, ".gantt_grid_editor_placeholder")))
                            return !1;
                        var c = d.getAttribute(n.$config.item_attribute);
                        if (s(c))
                            return !1;
                        var u = r().getItem(c);
                        return !t.isReadonly(u) && (i.config.initial_open_state = u.$open,
                        !!t.callEvent("onRowDragStart", [c, l.target || l.srcElement, l]) && void 0)
                    }, t)),
                    i.attachEvent("onAfterDragStart", t.bind(function(o, l) {
                        var d = a(l);
                        i.config.marker.innerHTML = d.outerHTML;
                        var c = i.config.marker.firstChild;
                        c && (c.style.position = "static"),
                            i.config.id = d.getAttribute(n.$config.item_attribute);
                        var u = r()
                            , h = u.getItem(i.config.id);
                        i.config.index = u.getBranchIndex(i.config.id),
                            i.config.parent = h.parent,
                            h.$open = !1,
                            h.$transparent = !0,
                            this.refreshData()
                    }, t)),
                    i.lastTaskOfLevel = function(o) {
                        for (var l = null, d = r().getItems(), c = 0, u = d.length; c < u; c++)
                            d[c].$level == o && (l = d[c]);
                        return l ? l.id : null
                    }
                    ,
                    i._getGridPos = t.bind(function(o) {
                        var l = Y(n.$grid_data)
                            , d = l.x + n.$grid.scrollLeft
                            , c = o.pos.y - 10
                            , u = n.getItemHeight(i.config.id);
                        c < l.y && (c = l.y);
                        var h = n.getTotalHeight();
                        c > l.y + h - u && (c = l.y + h - u);
                        const _ = l.y + l.height;
                        return c > _ - u && (c = _ - u),
                            l.x = d,
                            l.y = c,
                            l
                    }, t),
                    i._getTargetY = t.bind(function(o) {
                        var l = Y(n.$grid_data)
                            , d = n.$state.scrollTop || 0
                            , c = t.$grid_data.getBoundingClientRect().height + d
                            , u = o.pageY - l.y + d;
                        return u > c ? u = c : u < d && (u = d),
                            u
                    }, t),
                    i._getTaskByY = t.bind(function(o, l) {
                        var d = r();
                        o = o || 0;
                        var c = n.getItemIndexByTopPosition(o);
                        return (c = l < c ? c - 1 : c) > d.countVisible() - 1 ? null : d.getIdByIndex(c)
                    }, t),
                    i.attachEvent("onDragMove", t.bind(function(o, l) {
                        var d = t.$grid_data.getBoundingClientRect()
                            , c = d.height + d.y + (n.$state.scrollTop || 0) + window.scrollY
                            , u = i.config
                            , h = i._getGridPos(l);
                        t._waiAria.reorderMarkerAttr(u.marker);
                        var _ = n.$getConfig()
                            , f = r();
                        h.y < c ? u.marker.style.top = h.y + "px" : u.marker.style.top = c + "px",
                            u.marker.style.left = h.x + 10 + "px";
                        const y = Y(t.$root);
                        h.width > y.width && (u.marker.style.width = y.width - 10 - 2 + "px",
                            u.marker.style.overflow = "hidden");
                        var v = f.getItem(i.config.id)
                            , b = i._getTargetY(l)
                            , g = i._getTaskByY(b, f.getIndexById(v.id));
                        function m(D, A) {
                            return !f.isChildOf(p.id, A.id) && (D.$level == A.$level || _.order_branch_free)
                        }
                        if (f.exists(g) || (g = i.lastTaskOfLevel(_.order_branch_free ? v.$level : 0)) == i.config.id && (g = null),
                            f.exists(g)) {
                            var p = f.getItem(g)
                                , k = n.getItemTop(p.id)
                                , w = n.getItemHeight(p.id);
                            if (k + w / 2 < b) {
                                var x = f.getIndexById(p.id)
                                    , $ = f.getNext(p.id)
                                    , S = f.getItem($);
                                if (s($)) {
                                    var T = f.getPrev(S.id);
                                    S = f.getItem(T)
                                }
                                if (S) {
                                    if (S.id == v.id)
                                        return _.order_branch_free && f.isChildOf(v.id, p.id) && f.getChildren(p.id).length == 1 ? void f.move(v.id, f.getBranchIndex(p.id) + 1, f.getParent(p.id)) : void 0;
                                    p = S
                                } else if ($ = f.getIdByIndex(x),
                                    S = f.getItem($),
                                s($) && (T = f.getPrev(S.id),
                                    S = f.getItem(T)),
                                m(S, v) && S.id != v.id)
                                    return void f.move(v.id, -1, f.getParent(S.id))
                            } else if (_.order_branch_free && p.id != v.id && m(p, v) && !s(p.id)) {
                                if (!f.hasChild(p.id))
                                    return p.$open = !0,
                                        void f.move(v.id, -1, p.id);
                                if (f.getIndexById(p.id) || w / 3 < b)
                                    return
                            }
                            x = f.getIndexById(p.id),
                                T = f.getIdByIndex(x - 1);
                            for (var E = f.getItem(T), C = 1; (!E || E.id == p.id) && x - C >= 0; )
                                T = f.getIdByIndex(x - C),
                                    E = f.getItem(T),
                                    C++;
                            if (v.id == p.id || s(p.id))
                                return;
                            m(p, v) && v.id != p.id ? f.move(v.id, 0, 0, p.id) : p.$level != v.$level - 1 || f.getChildren(p.id).length ? E && m(E, v) && v.id != E.id && f.move(v.id, -1, f.getParent(E.id)) : f.move(v.id, 0, p.id)
                        }
                        return !0
                    }, t)),
                    i.attachEvent("onDragEnd", t.bind(function() {
                        var o = r()
                            , l = o.getItem(i.config.id);
                        l.$transparent = !1,
                            l.$open = i.config.initial_open_state,
                            this.callEvent("onBeforeRowDragEnd", [i.config.id, i.config.parent, i.config.index]) === !1 ? (o.move(i.config.id, i.config.index, i.config.parent),
                                l.$drop_target = null) : this.callEvent("onRowDragEnd", [i.config.id, l.$drop_target]),
                            t.render(),
                            this.refreshData()
                    }, t))
            }
            function a(o) {
                return Q(o, n.$config.item_attribute)
            }
            function r() {
                return t.getDatastore(n.$config.bind)
            }
            function s(o) {
                return jt(o, t, r())
            }
        }
    }
        , at = {
        createDropTargetObject: function(t) {
            var n = {
                targetParent: null,
                targetIndex: 0,
                targetId: null,
                child: !1,
                nextSibling: !1,
                prevSibling: !1
            };
            return t && O(n, t, !0),
                n
        },
        nextSiblingTarget: function(t, n, e) {
            var i = this.createDropTargetObject();
            return i.targetId = n,
                i.nextSibling = !0,
                i.targetParent = e.getParent(i.targetId),
                i.targetIndex = e.getBranchIndex(i.targetId),
            (e.getParent(t) != i.targetParent || i.targetIndex < e.getBranchIndex(t)) && (i.targetIndex += 1),
                i
        },
        prevSiblingTarget: function(t, n, e) {
            var i = this.createDropTargetObject();
            return i.targetId = n,
                i.prevSibling = !0,
                i.targetParent = e.getParent(i.targetId),
                i.targetIndex = e.getBranchIndex(i.targetId),
            e.getParent(t) == i.targetParent && i.targetIndex > e.getBranchIndex(t) && (i.targetIndex -= 1),
                i
        },
        firstChildTarget: function(t, n, e) {
            var i = this.createDropTargetObject();
            return i.targetId = n,
                i.targetParent = i.targetId,
                i.targetIndex = 0,
                i.child = !0,
                i
        },
        lastChildTarget: function(t, n, e) {
            var i = e.getChildren(n)
                , a = this.createDropTargetObject();
            return a.targetId = i[i.length - 1],
                a.targetParent = n,
                a.targetIndex = i.length,
                a.nextSibling = !0,
                a
        }
    };
    function Zn(t, n, e, i, a) {
        for (var r = n; i.exists(r); ) {
            var s = i.calculateItemLevel(i.getItem(r));
            if ((s === e || s === e - 1) && i.getBranchIndex(r) > -1)
                break;
            r = a ? i.getPrev(r) : i.getNext(r)
        }
        return i.exists(r) ? i.calculateItemLevel(i.getItem(r)) === e ? a ? at.nextSiblingTarget(t, r, i) : at.prevSiblingTarget(t, r, i) : at.firstChildTarget(t, r, i) : null
    }
    function qe(t, n, e, i) {
        return Zn(t, n, e, i, !0)
    }
    function Qn(t, n, e, i) {
        return Zn(t, n, e, i, !1)
    }
    function ti(t, n, e, i, a, r) {
        var s;
        if (n !== a.$getRootId()) {
            var o = a.getItem(n)
                , l = a.calculateItemLevel(o);
            if (l === r) {
                var d = a.getPrevSibling(n);
                e < .5 && !d ? s = at.prevSiblingTarget(t, n, a) : (e < .5 && (n = d),
                    s = at.nextSiblingTarget(t, n, a))
            } else if (l > r)
                a.eachParent(function(f) {
                    a.calculateItemLevel(f) === r && (n = f.id)
                }, o),
                    s = qe(t, n, r, a);
            else {
                var c = qe(t, n, r, a)
                    , u = Qn(t, n, r, a);
                s = e < .5 ? c : u
            }
        } else {
            var h = a.$getRootId()
                , _ = a.getChildren(h);
            s = at.createDropTargetObject(),
                s = _.length && i >= 0 ? qe(t, function(f) {
                    for (var y = f.getNext(); f.exists(y); ) {
                        var v = f.getNext(y);
                        if (!f.exists(v))
                            return y;
                        y = v
                    }
                    return null
                }(a), r, a) : Qn(t, h, r, a)
        }
        return s
    }
    function ei(t, n) {
        var e = Y(n.$grid_data);
        return t.x += e.x + n.$grid.scrollLeft,
            t.y += e.y - n.$grid_data.scrollTop,
            t
    }
    function Ye(t, n, e=0) {
        const i = Y(t.$root);
        return n > i.width && (n = i.width - e - 2),
            n
    }
    const ni = {
        removeLineHighlight: function(t) {
            t.markerLine && t.markerLine.parentNode && t.markerLine.parentNode.removeChild(t.markerLine),
                t.markerLine = null
        },
        highlightPosition: function(t, n, e) {
            var i = function(r, s) {
                var o = Y(s.$grid_data)
                    , l = lt(r, s.$grid_data)
                    , d = o.x + s.$grid.scrollLeft
                    , c = l.y - 10
                    , u = s.getItemHeight(r.targetId);
                c < o.y && (c = o.y);
                var h = s.getTotalHeight();
                return c > o.y + h - u && (c = o.y + h - u),
                    o.x = d,
                    o.y = c,
                    o.width = Ye(s.$gantt, o.width, 9),
                    o
            }(t, e);
            n.marker.style.left = i.x + 9 + "px",
                n.marker.style.width = i.width + "px",
                n.marker.style.overflow = "hidden";
            var a = n.markerLine;
            a || ((a = document.createElement("div")).className = "gantt_drag_marker gantt_grid_dnd_marker",
                a.innerHTML = "<div class='gantt_grid_dnd_marker_line'></div>",
                a.style.pointerEvents = "none"),
                t.child ? function(r, s, o) {
                    var l = r.targetParent
                        , d = ei({
                        x: 0,
                        y: o.getItemTop(l)
                    }, o)
                        , c = o.$grid_data.getBoundingClientRect().bottom + window.scrollY;
                    let u = Ye(o.$gantt, o.$grid_data.offsetWidth);
                    s.innerHTML = "<div class='gantt_grid_dnd_marker_folder'></div>",
                        s.style.width = u + "px",
                        s.style.top = d.y + "px",
                        s.style.left = d.x + "px",
                        s.style.height = o.getItemHeight(l) + "px",
                    d.y > c && (s.style.top = c + "px")
                }(t, a, e) : function(r, s, o) {
                    var l = function(u, h) {
                        var _ = h.$config.rowStore
                            , f = {
                            x: 0,
                            y: 0
                        }
                            , y = h.$grid_data.querySelector(".gantt_tree_indent")
                            , v = 15
                            , b = 0;
                        y && (v = y.offsetWidth);
                        var g = 40;
                        if (u.targetId !== _.$getRootId()) {
                            var m = h.getItemTop(u.targetId)
                                , p = h.getItemHeight(u.targetId);
                            if (b = _.exists(u.targetId) ? _.calculateItemLevel(_.getItem(u.targetId)) : 0,
                                u.prevSibling)
                                f.y = m;
                            else if (u.nextSibling) {
                                var k = 0;
                                _.eachItem(function(w) {
                                    _.getIndexById(w.id) !== -1 && k++
                                }, u.targetId),
                                    f.y = m + p + k * p
                            } else
                                f.y = m + p,
                                    b += 1
                        }
                        return f.x = g + b * v,
                            f.width = Ye(h.$gantt, Math.max(h.$grid_data.offsetWidth - f.x, 0), f.x),
                            ei(f, h)
                    }(r, o)
                        , d = o.$grid_data.getBoundingClientRect().bottom + window.scrollY;
                    s.innerHTML = "<div class='gantt_grid_dnd_marker_line'></div>",
                        s.style.left = l.x + "px",
                        s.style.height = "4px";
                    var c = l.y - 2;
                    s.style.top = c + "px",
                        s.style.width = l.width + "px",
                    c > d && (s.style.top = d + "px")
                }(t, a, e),
            n.markerLine || (document.body.appendChild(a),
                n.markerLine = a)
        }
    }
        , wr = {
        init: function(t, n) {
            var e = t.$services.getService("dnd");
            if (n.$config.bind && t.getDatastore(n.$config.bind)) {
                var i = new e(n.$grid_data,{
                    updates_per_second: 60
                });
                t.defined(n.$getConfig().dnd_sensitivity) && (i.config.sensitivity = n.$getConfig().dnd_sensitivity),
                    i.attachEvent("onBeforeDragStart", t.bind(function(o, l) {
                        var d = a(l);
                        if (!d || (t.hideQuickInfo && t.hideQuickInfo(),
                            dt(l.target, ".gantt_grid_editor_placeholder")))
                            return !1;
                        var c = d.getAttribute(n.$config.item_attribute)
                            , u = n.$config.rowStore.getItem(c);
                        return !t.isReadonly(u) && !r(c) && (i.config.initial_open_state = u.$open,
                        !!t.callEvent("onRowDragStart", [c, l.target || l.srcElement, l]) && void 0)
                    }, t)),
                    i.attachEvent("onAfterDragStart", t.bind(function(o, l) {
                        var d = a(l);
                        i.config.marker.innerHTML = d.outerHTML;
                        var c = i.config.marker.firstChild;
                        c && (i.config.marker.style.opacity = .4,
                            c.style.position = "static",
                            c.style.pointerEvents = "none"),
                            i.config.id = d.getAttribute(n.$config.item_attribute);
                        var u = n.$config.rowStore
                            , h = u.getItem(i.config.id);
                        i.config.level = u.calculateItemLevel(h),
                            i.config.drop_target = at.createDropTargetObject({
                                targetParent: u.getParent(h.id),
                                targetIndex: u.getBranchIndex(h.id),
                                targetId: h.id,
                                nextSibling: !0
                            }),
                            h.$open = !1,
                            h.$transparent = !0,
                            this.refreshData()
                    }, t)),
                    i.attachEvent("onDragMove", t.bind(function(o, l) {
                        var d = s(l);
                        return d && t.callEvent("onBeforeRowDragMove", [i.config.id, d.targetParent, d.targetIndex]) !== !1 || (d = at.createDropTargetObject(i.config.drop_target)),
                            ni.highlightPosition(d, i.config, n),
                            i.config.drop_target = d,
                            t._waiAria.reorderMarkerAttr(i.config.marker),
                            this.callEvent("onRowDragMove", [i.config.id, d.targetParent, d.targetIndex]),
                            !0
                    }, t)),
                    i.attachEvent("onDragEnd", t.bind(function() {
                        var o = n.$config.rowStore
                            , l = o.getItem(i.config.id);
                        ni.removeLineHighlight(i.config),
                            l.$transparent = !1,
                            l.$open = i.config.initial_open_state;
                        var d = i.config.drop_target;
                        this.callEvent("onBeforeRowDragEnd", [i.config.id, d.targetParent, d.targetIndex]) === !1 ? l.$drop_target = null : (o.move(i.config.id, d.targetIndex, d.targetParent),
                            t.render(),
                            this.callEvent("onRowDragEnd", [i.config.id, d.targetParent, d.targetIndex])),
                            o.refresh(l.id)
                    }, t))
            }
            function a(o) {
                return Q(o, n.$config.item_attribute)
            }
            function r(o) {
                return jt(o, t, t.getDatastore(n.$config.bind))
            }
            function s(o) {
                var l, d = function(f) {
                    var y = lt(f, n.$grid_data).y
                        , v = n.$config.rowStore;
                    document.doctype || (y += window.scrollY),
                        y = y || 0;
                    var b = n.$state.scrollTop || 0
                        , g = t.$grid_data.getBoundingClientRect().height + b + window.scrollY
                        , m = b
                        , p = n.getItemIndexByTopPosition(n.$state.scrollTop);
                    if (v.exists(p) || (p = v.countVisible() - 1),
                    p < 0)
                        return v.$getRootId();
                    var k = v.getIdByIndex(p)
                        , w = n.$state.scrollTop / n.getItemHeight(k)
                        , x = w - Math.floor(w);
                    x > .1 && x < .9 && (g -= n.getItemHeight(k) * x,
                        m += n.getItemHeight(k) * (1 - x));
                    const $ = Y(n.$grid_data)
                        , S = $.y + $.height
                        , T = i.config.marker.offsetHeight;
                    y + T + window.scrollY >= g && (i.config.marker.style.top = S - T + "px"),
                        y >= g ? y = g : y <= m && (y = m,
                            i.config.marker.style.top = $.y + "px");
                    var E = n.getItemIndexByTopPosition(y);
                    if (E > v.countVisible() - 1 || E < 0)
                        return v.$getRootId();
                    var C = v.getIdByIndex(E);
                    return r(C) ? v.getPrevSibling(C) : v.getIdByIndex(E)
                }(o), c = null, u = n.$config.rowStore, h = !n.$getConfig().order_branch_free, _ = lt(o, n.$grid_data).y;
                return document.doctype || (_ += window.scrollY),
                d !== u.$getRootId() && (c = (_ - n.getItemTop(d)) / n.getItemHeight(d)),
                    h ? (l = ti(i.config.id, d, c, _, u, i.config.level)) && l.targetParent && r(l.targetParent) && (d = u.getPrevSibling(l.targetParent),
                        l = ti(i.config.id, d, c, _, u, i.config.level)) : l = function(f, y, v, b, g) {
                        var m;
                        if (y !== g.$getRootId())
                            m = v < .25 ? at.prevSiblingTarget(f, y, g) : !(v > .6) || g.hasChild(y) && g.getItem(y).$open ? at.firstChildTarget(f, y, g) : at.nextSiblingTarget(f, y, g);
                        else {
                            var p = g.$getRootId();
                            m = g.hasChild(p) && b >= 0 ? at.lastChildTarget(f, p, g) : at.firstChildTarget(f, p, g)
                        }
                        return m
                    }(i.config.id, d, c, _, u),
                    l
            }
        }
    };
    var Sr = function(t) {
        return {
            onCreated: function(n) {
                n.$config = O(n.$config, {
                    bind: "task"
                }),
                n.$config.id == "grid" && (this.extendGantt(n),
                    t.ext.inlineEditors = t.ext._inlineEditors.createEditors(n),
                    t.ext.inlineEditors.init()),
                    this._mouseDelegates = Pe(t)
            },
            onInitialized: function(n) {
                var e = n.$getConfig();
                e.order_branch && (e.order_branch == "marker" ? wr.init(n.$gantt, n) : xr.init(n.$gantt, n)),
                    this.initEvents(n, t),
                n.$config.id == "grid" && this.extendDom(n)
            },
            onDestroyed: function(n) {
                n.$config.id == "grid" && t.ext.inlineEditors.detachStore(),
                    this.clearEvents(n, t)
            },
            initEvents: function(n, e) {
                this._mouseDelegates.delegate("click", "gantt_row", e.bind(function(i, a, r) {
                    const s = n.$getConfig();
                    if (a !== null) {
                        const o = this.getTask(a);
                        if (s.scroll_on_click) {
                            const l = !e._is_icon_open_click(i)
                                , d = e.$ui.getView("timeline");
                            l && d && this.showDate(o.start_date)
                        }
                        e.callEvent("onTaskRowClick", [a, r])
                    }
                }, e), n.$grid),
                    this._mouseDelegates.delegate("click", "gantt_grid_head_cell", e.bind(function(i, a, r) {
                        var s = r.getAttribute("data-column-id");
                        if (e.callEvent("onGridHeaderClick", [s, i])) {
                            var o = n.$getConfig();
                            if (s != "add") {
                                if (o.sort && s) {
                                    for (var l, d = s, c = 0; c < o.columns.length; c++)
                                        if (o.columns[c].name == s) {
                                            l = o.columns[c];
                                            break
                                        }
                                    if (l && l.sort !== void 0 && l.sort !== !0 && !(d = l.sort))
                                        return;
                                    var u = this._sort && this._sort.direction && this._sort.name == s ? this._sort.direction : "desc";
                                    u = u == "desc" ? "asc" : "desc",
                                        this._sort = {
                                            name: s,
                                            direction: u
                                        },
                                        this.sort(d, u == "desc")
                                }
                            } else
                                e.$services.getService("mouseEvents").callHandler("click", "gantt_add", n.$grid, [i, o.root_id])
                        }
                    }, e), n.$grid),
                    this._mouseDelegates.delegate("click", "gantt_add", e.bind(function(i, a, r) {
                        if (!n.$getConfig().readonly)
                            return this.createTask({}, a || e.config.root_id),
                                !1
                    }, e), n.$grid)
            },
            clearEvents: function(n, e) {
                this._mouseDelegates.destructor(),
                    this._mouseDelegates = null
            },
            extendDom: function(n) {
                t.$grid = n.$grid,
                    t.$grid_scale = n.$grid_scale,
                    t.$grid_data = n.$grid_data
            },
            extendGantt: function(n) {
                t.getGridColumns = t.bind(n.getGridColumns, n),
                    n.attachEvent("onColumnResizeStart", function() {
                        return t.callEvent("onColumnResizeStart", arguments)
                    }),
                    n.attachEvent("onColumnResize", function() {
                        return t.callEvent("onColumnResize", arguments)
                    }),
                    n.attachEvent("onColumnResizeEnd", function() {
                        return t.callEvent("onColumnResizeEnd", arguments)
                    }),
                    n.attachEvent("onColumnResizeComplete", function(e, i) {
                        t.config.grid_width = i
                    }),
                    n.attachEvent("onBeforeRowResize", function() {
                        return t.callEvent("onBeforeRowResize", arguments)
                    }),
                    n.attachEvent("onRowResize", function() {
                        return t.callEvent("onRowResize", arguments)
                    }),
                    n.attachEvent("onBeforeRowResizeEnd", function() {
                        return t.callEvent("onBeforeRowResizeEnd", arguments)
                    }),
                    n.attachEvent("onAfterRowResize", function() {
                        return t.callEvent("onAfterRowResize", arguments)
                    })
            }
        }
    };
    const Tr = {
        createTaskDND: function() {
            var t;
            return {
                extend: function(n) {
                    n.roundTaskDates = function(e) {
                        t.round_task_dates(e)
                    }
                },
                init: function(n, e) {
                    return t = function(i, a) {
                        var r = a.$services;
                        return {
                            drag: null,
                            dragMultiple: {},
                            _events: {
                                before_start: {},
                                before_finish: {},
                                after_finish: {}
                            },
                            _handlers: {},
                            init: function() {
                                this._domEvents = a._createDomEventScope(),
                                    this.clear_drag_state();
                                var s = a.config.drag_mode;
                                this.set_actions(),
                                    r.getService("state").registerProvider("tasksDnd", z(function() {
                                        return {
                                            drag_id: this.drag ? this.drag.id : void 0,
                                            drag_mode: this.drag ? this.drag.mode : void 0,
                                            drag_from_start: this.drag ? this.drag.left : void 0
                                        }
                                    }, this));
                                var o = {
                                    before_start: "onBeforeTaskDrag",
                                    before_finish: "onBeforeTaskChanged",
                                    after_finish: "onAfterTaskDrag"
                                };
                                for (var l in this._events)
                                    for (var d in s)
                                        this._events[l][d] = o[l];
                                this._handlers[s.move] = this._move,
                                    this._handlers[s.resize] = this._resize,
                                    this._handlers[s.progress] = this._resize_progress
                            },
                            set_actions: function() {
                                var s = i.$task_data;
                                this._domEvents.attach(s, "mousemove", a.bind(function(o) {
                                    this.on_mouse_move(o)
                                }, this)),
                                    this._domEvents.attach(s, "mousedown", a.bind(function(o) {
                                        this.on_mouse_down(o)
                                    }, this)),
                                    this._domEvents.attach(document.body, "mouseup", a.bind(function(o) {
                                        this.on_mouse_up(o)
                                    }, this))
                            },
                            clear_drag_state: function() {
                                this.drag = {
                                    id: null,
                                    mode: null,
                                    pos: null,
                                    start_x: null,
                                    start_y: null,
                                    obj: null,
                                    left: null
                                },
                                    this.dragMultiple = {}
                            },
                            _resize: function(s, o, l) {
                                var d = i.$getConfig()
                                    , c = this._drag_task_coords(s, l);
                                l.left ? (s.start_date = a.dateFromPos(c.start + o),
                                s.start_date || (s.start_date = new Date(a.getState().min_date))) : (s.end_date = a.dateFromPos(c.end + o),
                                s.end_date || (s.end_date = new Date(a.getState().max_date)));
                                var u = this._calculateMinDuration(d.min_duration, d.duration_unit);
                                s.end_date - s.start_date < d.min_duration && (l.left ? s.start_date = a.calculateEndDate(s.end_date, -u, d.duration_unit, s) : s.end_date = a.calculateEndDate(s.start_date, u, d.duration_unit, s)),
                                    a._init_task_timing(s)
                            },
                            _calculateMinDuration: function(s, o) {
                                return Math.ceil(s / {
                                    minute: 6e4,
                                    hour: 36e5,
                                    day: 864e5,
                                    week: 6048e5,
                                    month: 24192e5,
                                    year: 31356e6
                                }[o])
                            },
                            _resize_progress: function(s, o, l) {
                                var d = this._drag_task_coords(s, l)
                                    , c = i.$getConfig().rtl ? d.start - l.pos.x : l.pos.x - d.start
                                    , u = Math.max(0, c);
                                s.progress = Math.min(1, u / Math.abs(d.end - d.start))
                            },
                            _find_max_shift: function(s, o) {
                                var l;
                                for (var d in s) {
                                    var c = s[d]
                                        , u = a.getTask(c.id);
                                    if (!u.unscheduled) {
                                        var h = this._drag_task_coords(u, c)
                                            , _ = a.posFromDate(new Date(a.getState().min_date))
                                            , f = a.posFromDate(new Date(a.getState().max_date));
                                        if (h.end + o > f) {
                                            var y = f - h.end;
                                            (y < l || l === void 0) && (l = y)
                                        } else if (h.start + o < _) {
                                            var v = _ - h.start;
                                            (v > l || l === void 0) && (l = v)
                                        }
                                    }
                                }
                                return l
                            },
                            _move: function(s, o, l, d) {
                                var c = this._drag_task_coords(s, l)
                                    , u = null
                                    , h = null;
                                d ? (u = new Date(+l.obj.start_date + d),
                                    h = new Date(+l.obj.end_date + d)) : (u = a.dateFromPos(c.start + o),
                                    h = a.dateFromPos(c.end + o)),
                                    u ? h ? (s.start_date = u,
                                        s.end_date = h) : (s.end_date = new Date(a.getState().max_date),
                                        s.start_date = a.dateFromPos(a.posFromDate(s.end_date) - (c.end - c.start))) : (s.start_date = new Date(a.getState().min_date),
                                        s.end_date = a.dateFromPos(a.posFromDate(s.start_date) + (c.end - c.start)))
                            },
                            _drag_task_coords: function(s, o) {
                                return {
                                    start: o.obj_s_x = o.obj_s_x || a.posFromDate(s.start_date),
                                    end: o.obj_e_x = o.obj_e_x || a.posFromDate(s.end_date)
                                }
                            },
                            _mouse_position_change: function(s, o) {
                                var l = s.x - o.x
                                    , d = s.y - o.y;
                                return Math.sqrt(l * l + d * d)
                            },
                            _is_number: function(s) {
                                return !isNaN(parseFloat(s)) && isFinite(s)
                            },
                            on_mouse_move: function(s) {
                                if (this.drag.start_drag) {
                                    var o = lt(s, a.$task_data)
                                        , l = this.drag.start_drag.start_x
                                        , d = this.drag.start_drag.start_y;
                                    (Date.now() - this.drag.timestamp > 50 || this._is_number(l) && this._is_number(d) && this._mouse_position_change({
                                        x: l,
                                        y: d
                                    }, o) > 20) && this._start_dnd(s)
                                }
                                if (this.drag.mode) {
                                    if (!Sn(this, 40))
                                        return;
                                    this._update_on_move(s)
                                }
                            },
                            _update_item_on_move: function(s, o, l, d, c, u) {
                                var h = a.getTask(o)
                                    , _ = a.mixin({}, h)
                                    , f = a.mixin({}, h);
                                this._handlers[l].apply(this, [f, s, d, u]),
                                    a.mixin(h, f, !0),
                                    a.callEvent("onTaskDrag", [h.id, l, f, _, c]),
                                    a.mixin(h, f, !0),
                                    a.refreshTask(o)
                            },
                            _update_on_move: function(s) {
                                var o = this.drag
                                    , l = i.$getConfig();
                                if (o.mode) {
                                    var d = lt(s, i.$task_data);
                                    if (o.pos && o.pos.x == d.x)
                                        return;
                                    o.pos = d;
                                    var c = a.dateFromPos(d.x);
                                    if (!c || isNaN(c.getTime()))
                                        return;
                                    var u = d.x - o.start_x
                                        , h = a.getTask(o.id);
                                    if (this._handlers[o.mode]) {
                                        if (o.mode === l.drag_mode.move) {
                                            var _ = {};
                                            this._isMultiselect() && a.getSelectedTasks().indexOf(o.id) >= 0 && (_ = this.dragMultiple);
                                            var f = !1;
                                            if (a.isSummaryTask(h) && a.config.drag_project) {
                                                var y = {};
                                                y[o.id] = X(o),
                                                    f = !0,
                                                    _ = O(y, this.dragMultiple)
                                            }
                                            var v = this._find_max_shift(_, u);
                                            let m;
                                            if (v !== void 0 && (u = v),
                                                this._update_item_on_move(u, o.id, o.mode, o, s),
                                            v === void 0) {
                                                const p = a.posFromDate(o.obj.start_date)
                                                    , k = a.posFromDate(o.obj.end_date);
                                                if (o.handle_offset === void 0) {
                                                    const x = k - p
                                                        , $ = o.start_x - p;
                                                    o.handle_offset = $ / x
                                                }
                                                let w = p + Math.abs(k - p) * o.handle_offset;
                                                m = c - a.dateFromPos(w)
                                            }
                                            for (var b in _) {
                                                var g = _[b];
                                                f && g.id != o.id && (a._bulk_dnd = !0),
                                                    this._update_item_on_move(u, g.id, g.mode, g, s, m)
                                            }
                                            a._bulk_dnd = !1
                                        } else
                                            this._update_item_on_move(u, o.id, o.mode, o, s);
                                        a._update_parents(o.id)
                                    }
                                }
                            },
                            on_mouse_down: function(s, o) {
                                if (s.button != 2 || s.button === void 0) {
                                    var l = i.$getConfig()
                                        , d = a.locate(s)
                                        , c = null;
                                    if (a.isTaskExists(d) && (c = a.getTask(d)),
                                    !a.isReadonly(c) && !this.drag.mode) {
                                        this.clear_drag_state();
                                        var u = it(o = o || s.target || s.srcElement)
                                            , h = this._get_drag_mode(u, o);
                                        if (!u || !h)
                                            return o.parentNode ? this.on_mouse_down(s, o.parentNode) : void 0;
                                        if (h)
                                            if (h.mode && h.mode != l.drag_mode.ignore && l["drag_" + h.mode]) {
                                                if (d = a.locate(o),
                                                    c = a.copy(a.getTask(d) || {}),
                                                    a.isReadonly(c))
                                                    return this.clear_drag_state(),
                                                        !1;
                                                if (a.isSummaryTask(c) && c.auto_scheduling !== !1 && !l.drag_project && h.mode != l.drag_mode.progress)
                                                    return void this.clear_drag_state();
                                                h.id = d;
                                                var _ = lt(s, a.$task_data);
                                                h.start_x = _.x,
                                                    h.start_y = _.y,
                                                    h.obj = c,
                                                    this.drag.start_drag = h,
                                                    this.drag.timestamp = Date.now()
                                            } else
                                                this.clear_drag_state();
                                        else if (a.checkEvent("onMouseDown") && a.callEvent("onMouseDown", [u.split(" ")[0]]) && o.parentNode)
                                            return this.on_mouse_down(s, o.parentNode)
                                    }
                                }
                            },
                            _fix_dnd_scale_time: function(s, o) {
                                var l = i.$getConfig()
                                    , d = a.getScale().unit
                                    , c = a.getScale().step;
                                function u(h) {
                                    if (a.config.correct_work_time) {
                                        var _ = i.$getConfig();
                                        a.isWorkTime(h.start_date, void 0, h) || (h.start_date = a.calculateEndDate({
                                            start_date: h.start_date,
                                            duration: -1,
                                            unit: _.duration_unit,
                                            task: h
                                        }))
                                    }
                                }
                                l.round_dnd_dates || (d = "minute",
                                    c = l.time_step),
                                    o.mode == l.drag_mode.resize ? o.left ? (s.start_date = a.roundDate({
                                        date: s.start_date,
                                        unit: d,
                                        step: c
                                    }),
                                        u(s)) : (s.end_date = a.roundDate({
                                        date: s.end_date,
                                        unit: d,
                                        step: c
                                    }),
                                        function(h) {
                                            if (a.config.correct_work_time) {
                                                var _ = i.$getConfig();
                                                a.isWorkTime(new Date(h.end_date - 1), void 0, h) || (h.end_date = a.calculateEndDate({
                                                    start_date: h.end_date,
                                                    duration: 1,
                                                    unit: _.duration_unit,
                                                    task: h
                                                }))
                                            }
                                        }(s)) : o.mode == l.drag_mode.move && (s.start_date = a.roundDate({
                                        date: s.start_date,
                                        unit: d,
                                        step: c
                                    }),
                                        u(s),
                                        s.end_date = a.calculateEndDate(s))
                            },
                            _fix_working_times: function(s, o) {
                                var l = i.$getConfig();
                                (o = o || {
                                    mode: l.drag_mode.move
                                }).mode == l.drag_mode.resize ? o.left ? s.start_date = a.getClosestWorkTime({
                                    date: s.start_date,
                                    dir: "future",
                                    task: s
                                }) : s.end_date = a.getClosestWorkTime({
                                    date: s.end_date,
                                    dir: "past",
                                    task: s
                                }) : o.mode == l.drag_mode.move && a.correctTaskWorkTime(s)
                            },
                            _finalize_mouse_up: function(s, o, l, d) {
                                var c = a.getTask(s);
                                if (o.work_time && o.correct_work_time && this._fix_working_times(c, l),
                                    this._fix_dnd_scale_time(c, l),
                                    this._fireEvent("before_finish", l.mode, [s, l.mode, a.copy(l.obj), d])) {
                                    var u = s;
                                    a._init_task_timing(c),
                                        this.clear_drag_state(),
                                        a.updateTask(c.id),
                                        this._fireEvent("after_finish", l.mode, [u, l.mode, d])
                                } else if (this.clear_drag_state(),
                                s == l.id && (l.obj._dhx_changed = !1,
                                    a.mixin(c, l.obj, !0)),
                                    a.refreshTask(c.id),
                                c.$level > 100) {
                                    let h = !1;
                                    a.eachParent(function(_) {
                                        if (!h && _.type === a.config.types.project) {
                                            const f = {
                                                start_date: _.start_date,
                                                end_date: _.end_date
                                            };
                                            a.resetProjectDates(_),
                                            +f.start_date == +_.start_date && +f.end_date == +_.end_date || (h = !0)
                                        }
                                    }, c.id),
                                    h && a.refreshData()
                                } else
                                    a.eachParent(function(h) {
                                        if (h.type === a.config.types.project) {
                                            const _ = {
                                                start_date: h.start_date,
                                                end_date: h.end_date
                                            };
                                            a.resetProjectDates(h),
                                            +_.start_date == +h.start_date && +_.end_date == +h.end_date || a.refreshTask(h.id)
                                        }
                                    }, c.id)
                            },
                            on_mouse_up: function(s) {
                                var o = this.drag;
                                if (o.mode && o.id) {
                                    var l = i.$getConfig()
                                        , d = a.getTask(o.id)
                                        , c = this.dragMultiple
                                        , u = !1
                                        , h = 0;
                                    o.mode === l.drag_mode.move && (a.isSummaryTask(d) && l.drag_project || this._isMultiselect()) && (u = !0,
                                        h = Object.keys(c).length);
                                    var _ = function() {
                                        if (u)
                                            for (var f in c)
                                                c[f].id != o.id && this._finalize_mouse_up(c[f].id, l, c[f], s);
                                        this._finalize_mouse_up(o.id, l, o, s)
                                    };
                                    u && h > 10 ? a.batchUpdate((function() {
                                            _.call(this)
                                        }
                                    ).bind(this)) : _.call(this)
                                }
                                this.clear_drag_state()
                            },
                            _get_drag_mode: function(s, o) {
                                var l = i.$getConfig().drag_mode
                                    , d = {
                                    mode: null,
                                    left: null
                                };
                                switch ((s || "").split(" ")[0]) {
                                    case "gantt_task_line":
                                    case "gantt_task_content":
                                        d.mode = l.move;
                                        break;
                                    case "gantt_task_drag":
                                        d.mode = l.resize;
                                        var c = o.getAttribute("data-bind-property");
                                        d.left = c == "start_date";
                                        break;
                                    case "gantt_task_progress_drag":
                                        d.mode = l.progress;
                                        break;
                                    case "gantt_link_control":
                                    case "gantt_link_point":
                                        d.mode = l.ignore;
                                        break;
                                    default:
                                        d = null
                                }
                                return d
                            },
                            _start_dnd: function(s) {
                                var o = this.drag = this.drag.start_drag;
                                delete o.start_drag;
                                var l = i.$getConfig()
                                    , d = o.id;
                                if (l["drag_" + o.mode] && a.callEvent("onBeforeDrag", [d, o.mode, s]) && this._fireEvent("before_start", o.mode, [d, o.mode, s])) {
                                    delete o.start_drag;
                                    var c = a.getTask(d);
                                    if (a.isReadonly(c))
                                        return void this.clear_drag_state();
                                    if (this._isMultiselect()) {
                                        var u = a.getSelectedTasks();
                                        u.indexOf(o.id) >= 0 && st(u, a.bind(function(h) {
                                            var _ = a.getTask(h);
                                            a.isSummaryTask(_) && a.config.drag_project && o.mode == l.drag_mode.move && this._addSubtasksToDragMultiple(_.id),
                                                this.dragMultiple[h] = a.mixin({
                                                    id: _.id,
                                                    obj: a.copy(_)
                                                }, this.drag)
                                        }, this))
                                    }
                                    a.isSummaryTask(c) && a.config.drag_project && o.mode == l.drag_mode.move && this._addSubtasksToDragMultiple(c.id),
                                        a.callEvent("onTaskDragStart", [])
                                } else
                                    this.clear_drag_state()
                            },
                            _fireEvent: function(s, o, l) {
                                a.assert(this._events[s], "Invalid stage:{" + s + "}");
                                var d = this._events[s][o];
                                return a.assert(d, "Unknown after drop mode:{" + o + "}"),
                                    a.assert(l, "Invalid event arguments"),
                                !a.checkEvent(d) || a.callEvent(d, l)
                            },
                            round_task_dates: function(s) {
                                var o = this.drag
                                    , l = i.$getConfig();
                                o || (o = {
                                    mode: l.drag_mode.move
                                }),
                                    this._fix_dnd_scale_time(s, o)
                            },
                            destructor: function() {
                                this._domEvents.detachAll()
                            },
                            _isMultiselect: function() {
                                return a.config.drag_multiple && !!(a.getSelectedTasks && a.getSelectedTasks().length > 0)
                            },
                            _addSubtasksToDragMultiple: function(s) {
                                a.eachTask(function(o) {
                                    this.dragMultiple[o.id] = a.mixin({
                                        id: o.id,
                                        obj: a.copy(o)
                                    }, this.drag)
                                }, s, this)
                            }
                        }
                    }(n, e),
                        n._tasks_dnd = t,
                        t.init(e)
                },
                destructor: function() {
                    t && (t.destructor(),
                        t = null)
                }
            }
        }
    };
    var Er = function(t, n) {
        var e, i, a, r, s;
        function o() {
            return {
                link_source_id: r,
                link_target_id: i,
                link_from_start: s,
                link_to_start: a,
                link_landing_area: e
            }
        }
        var l = n.$services
            , d = l.getService("state")
            , c = l.getService("dnd");
        d.registerProvider("linksDnD", o);
        var u = "gantt_link_point"
            , h = "gantt_link_control"
            , _ = new c(t.$task_bars,{
            sensitivity: 0,
            updates_per_second: 60,
            mousemoveContainer: n.$root,
            selector: "." + u,
            preventDefault: !0
        });
        function f(m, p) {
            var k, w = _.getPosition(m), x = function(A) {
                var I = 0
                    , M = 0;
                return A && (I = A.offsetWidth || 0,
                    M = A.offsetHeight || 0),
                    {
                        width: I,
                        height: M
                    }
            }(p), $ = {
                right: (k = n.$root).offsetWidth,
                bottom: k.offsetHeight
            }, S = n.config.tooltip_offset_x || 10, T = n.config.tooltip_offset_y || 10, E = n.config.scroll_size || 18, C = n.$container.getBoundingClientRect().y + window.scrollY, D = {
                y: w.y + T,
                x: w.x + S,
                bottom: w.y + x.height + T + E,
                right: w.x + x.width + S + E
            };
            return D.bottom > $.bottom + C && (D.y = $.bottom + C - x.height - T),
            D.right > $.right && (D.x = $.right - x.width - S),
                D
        }
        function y(m) {
            var p = o();
            p.link_source_id && p.link_target_id && n.isLinkAllowed(p.link_source_id, p.link_target_id, p.link_from_start, p.link_to_start);
            var k = "<div class='" + n.templates.drag_link_class(p.link_source_id, p.link_from_start, p.link_target_id, p.link_to_start) + "'>" + n.templates.drag_link(p.link_source_id, p.link_from_start, p.link_target_id, p.link_to_start) + "</div>";
            m.innerHTML = k
        }
        function v() {
            r = s = i = null,
                a = !0
        }
        function b(m, p, k, w) {
            var x = function() {
                return _._direction && _._direction.parentNode || (_._direction = document.createElement("div"),
                    t.$task_links.appendChild(_._direction)),
                    _._direction
            }()
                , $ = o()
                , S = ["gantt_link_direction"];
            n.templates.link_direction_class && S.push(n.templates.link_direction_class($.link_source_id, $.link_from_start, $.link_target_id, $.link_to_start));
            var T = Math.sqrt(Math.pow(k - m, 2) + Math.pow(w - p, 2));
            if (T = Math.max(0, T - 3)) {
                x.className = S.join(" ");
                var E = (w - p) / (k - m)
                    , C = Math.atan(E);
                g(m, k, p, w) == 2 ? C += Math.PI : g(m, k, p, w) == 3 && (C -= Math.PI);
                var D = Math.sin(C)
                    , A = Math.cos(C)
                    , I = Math.round(p)
                    , M = Math.round(m)
                    , L = ["-webkit-transform: rotate(" + C + "rad)", "-moz-transform: rotate(" + C + "rad)", "-ms-transform: rotate(" + C + "rad)", "-o-transform: rotate(" + C + "rad)", "transform: rotate(" + C + "rad)", "width:" + Math.round(T) + "px"];
                if (window.navigator.userAgent.indexOf("MSIE 8.0") != -1) {
                    L.push('-ms-filter: "' + function(R, B) {
                        return "progid:DXImageTransform.Microsoft.Matrix(M11 = " + B + ",M12 = -" + R + ",M21 = " + R + ",M22 = " + B + ",SizingMethod = 'auto expand')"
                    }(D, A) + '"');
                    var N = Math.abs(Math.round(m - k))
                        , P = Math.abs(Math.round(w - p));
                    switch (g(m, k, p, w)) {
                        case 1:
                            I -= P;
                            break;
                        case 2:
                            M -= N,
                                I -= P;
                            break;
                        case 3:
                            M -= N
                    }
                }
                L.push("top:" + I + "px"),
                    L.push("left:" + M + "px"),
                    x.style.cssText = L.join(";")
            }
        }
        function g(m, p, k, w) {
            return p >= m ? w <= k ? 1 : 4 : w <= k ? 2 : 3
        }
        _.attachEvent("onBeforeDragStart", n.bind(function(m, p) {
            var k = p.target || p.srcElement;
            if (v(),
                n.getState("tasksDnd").drag_id)
                return !1;
            if (mt(k, u)) {
                mt(k, "task_start_date") && (s = !0);
                var w = n.locate(p);
                r = w;
                var x = n.getTask(w);
                return n.isReadonly(x) ? (v(),
                    !1) : (this._dir_start = {
                    x: _.config.original_element_sizes.x + _.config.original_element_sizes.width / 2,
                    y: _.config.original_element_sizes.y + _.config.original_element_sizes.height / 2
                },
                    !0)
            }
            return !1
        }, this)),
            _.attachEvent("onAfterDragStart", n.bind(function(m, p) {
                n.config.touch && n.refreshData(),
                    y(_.config.marker)
            }, this)),
            _.attachEvent("onDragMove", n.bind(function(m, p) {
                var k = _.config
                    , w = f(p, k.marker);
                (function(A, I) {
                        A.style.left = I.x + "px",
                            A.style.top = I.y + "px"
                    }
                )(k.marker, w);
                var x = !!mt(p, h)
                    , $ = i
                    , S = e
                    , T = a
                    , E = n.locate(p)
                    , C = !0;
                if (tt(Et(p), n.$root) || (x = !1,
                    E = null),
                x && (C = !mt(p, "task_end_date"),
                    x = !!E),
                    i = E,
                    e = x,
                    a = C,
                    x) {
                    const A = mt(p, h).querySelector(`.${u}`);
                    if (A) {
                        const I = un(A, t.$task_bg);
                        this._dir_end = {
                            x: I.x + A.offsetWidth / 2,
                            y: I.y + A.offsetHeight / 2
                        }
                    }
                } else
                    this._dir_end = lt(p, t.$task_data),
                    n.env.isEdge && (this._dir_end.y += window.scrollY);
                var D = !(S == x && $ == E && T == C);
                return D && ($ && n.refreshTask($, !1),
                E && n.refreshTask(E, !1)),
                D && y(k.marker),
                    b(this._dir_start.x, this._dir_start.y, this._dir_end.x, this._dir_end.y),
                    !0
            }, this)),
            _.attachEvent("onDragEnd", n.bind(function() {
                var m = o();
                if (m.link_source_id && m.link_target_id && m.link_source_id != m.link_target_id) {
                    var p = n._get_link_type(m.link_from_start, m.link_to_start)
                        , k = {
                        source: m.link_source_id,
                        target: m.link_target_id,
                        type: p
                    };
                    k.type && n.isLinkAllowed(k) && n.callEvent("onLinkCreated", [k]) && n.addLink(k)
                }
                v(),
                    n.config.touch ? n.refreshData() : (m.link_source_id && n.refreshTask(m.link_source_id, !1),
                    m.link_target_id && n.refreshTask(m.link_target_id, !1)),
                _._direction && (_._direction.parentNode && _._direction.parentNode.removeChild(_._direction),
                    _._direction = null)
            }, this)),
            n.attachEvent("onGanttRender", n.bind(function() {
                _._direction && b(this._dir_start.x, this._dir_start.y, this._dir_end.x, this._dir_end.y)
            }, this))
    };
    const Cr = function() {
        return {
            init: Er
        }
    };
    var Dr = function(t) {
        var n = t.$services;
        return {
            onCreated: function(e) {
                var i = e.$config;
                i.bind = U(i.bind) ? i.bind : "task",
                    i.bindLinks = U(i.bindLinks) ? i.bindLinks : "link",
                    e._linksDnD = Cr(),
                    e._tasksDnD = Tr.createTaskDND(),
                    e._tasksDnD.extend(e),
                    this._mouseDelegates = Pe(t)
            },
            onInitialized: function(e) {
                this._attachDomEvents(t),
                    this._attachStateProvider(t, e),
                    e._tasksDnD.init(e, t),
                    e._linksDnD.init(e, t),
                e.$config.id == "timeline" && this.extendDom(e)
            },
            onDestroyed: function(e) {
                this._clearDomEvents(t),
                    this._clearStateProvider(t),
                e._tasksDnD && e._tasksDnD.destructor()
            },
            extendDom: function(e) {
                t.$task = e.$task,
                    t.$task_scale = e.$task_scale,
                    t.$task_data = e.$task_data,
                    t.$task_bg = e.$task_bg,
                    t.$task_links = e.$task_links,
                    t.$task_bars = e.$task_bars
            },
            _clearDomEvents: function() {
                this._mouseDelegates.destructor(),
                    this._mouseDelegates = null
            },
            _attachDomEvents: function(e) {
                function i(a, r) {
                    if (a && this.callEvent("onLinkDblClick", [a, r])) {
                        var s = this.getLink(a);
                        if (this.isReadonly(s))
                            return;
                        var o = this.locale.labels.link + " " + this.templates.link_description(this.getLink(a)) + " " + this.locale.labels.confirm_link_deleting;
                        window.setTimeout(function() {
                            e._delete_link_confirm({
                                link: s,
                                message: o,
                                title: "",
                                callback: function() {
                                    e.deleteLink(a)
                                }
                            })
                        }, this.config.touch ? 300 : 1)
                    }
                }
                this._mouseDelegates.delegate("click", "gantt_task_link", e.bind(function(a, r) {
                    var s = this.locate(a, this.config.link_attribute);
                    s && this.callEvent("onLinkClick", [s, a])
                }, e), this.$task),
                    this._mouseDelegates.delegate("click", "gantt_scale_cell", e.bind(function(a, r) {
                        var s = lt(a, e.$task_data)
                            , o = e.dateFromPos(s.x)
                            , l = Math.floor(e.columnIndexByDate(o))
                            , d = e.getScale().trace_x[l];
                        e.callEvent("onScaleClick", [a, d])
                    }, e), this.$task),
                    this._mouseDelegates.delegate("doubleclick", "gantt_task_link", e.bind(function(a, r, s) {
                        r = this.locate(a, e.config.link_attribute),
                            i.call(this, r, a)
                    }, e), this.$task),
                    this._mouseDelegates.delegate("doubleclick", "gantt_link_point", e.bind(function(a, r, s) {
                        r = this.locate(a);
                        var o = this.getTask(r)
                            , l = null;
                        return s.parentNode && it(s.parentNode) && (l = it(s.parentNode).indexOf("_left") > -1 ? o.$target[0] : o.$source[0]),
                        l && i.call(this, l, a),
                            !1
                    }, e), this.$task)
            },
            _attachStateProvider: function(e, i) {
                var a = i;
                n.getService("state").registerProvider("tasksTimeline", function() {
                    return {
                        scale_unit: a._tasks ? a._tasks.unit : void 0,
                        scale_step: a._tasks ? a._tasks.step : void 0
                    }
                })
            },
            _clearStateProvider: function() {
                n.getService("state").unregisterProvider("tasksTimeline")
            }
        }
    }
        , Ar = function(t) {
        return {
            getVerticalScrollbar: function() {
                return t.$ui.getView("scrollVer")
            },
            getHorizontalScrollbar: function() {
                return t.$ui.getView("scrollHor")
            },
            _legacyGridResizerClass: function(n) {
                for (var e = n.getCellsByType("resizer"), i = 0; i < e.length; i++) {
                    var a = e[i]
                        , r = !1
                        , s = a.$parent.getPrevSibling(a.$id);
                    if (s && s.$config && s.$config.id === "grid")
                        r = !0;
                    else {
                        var o = a.$parent.getNextSibling(a.$id);
                        o && o.$config && o.$config.id === "grid" && (r = !0)
                    }
                    r && (a.$config.css = (a.$config.css ? a.$config.css + " " : "") + "gantt_grid_resize_wrap")
                }
            },
            onCreated: function(n) {
                var e = !0;
                this._legacyGridResizerClass(n),
                    n.attachEvent("onBeforeResize", function() {
                        var i = t.$ui.getView("timeline");
                        i && (i.$config.hidden = i.$parent.$config.hidden = !t.config.show_chart);
                        var a = t.$ui.getView("grid");
                        if (a) {
                            var r = a._getColsTotalWidth()
                                , s = !t.config.show_grid || !t.config.grid_width || r === 0;
                            if (e && !s && r !== !1 && (t.config.grid_width = r),
                                a.$config.hidden = a.$parent.$config.hidden = s,
                                !a.$config.hidden) {
                                var o = a._getGridWidthLimits();
                                if (o[0] && t.config.grid_width < o[0] && (t.config.grid_width = o[0]),
                                o[1] && t.config.grid_width > o[1] && (t.config.grid_width = o[1]),
                                i && t.config.show_chart) {
                                    if (a.$config.width = t.config.grid_width - 1,
                                    !a.$config.scrollable && a.$config.scrollY && t.$root.offsetWidth) {
                                        var l = a.$gantt.$layout.$container.offsetWidth
                                            , d = t.$ui.getView(a.$config.scrollY).$config.width
                                            , c = l - (a.$config.width + d) - 4;
                                        c < 0 && (a.$config.width += c,
                                            t.config.grid_width += c)
                                    }
                                    if (e)
                                        a.$parent.$config.width = t.config.grid_width,
                                        a.$parent.$config.group && t.$layout._syncCellSizes(a.$parent.$config.group, {
                                            value: a.$parent.$config.width,
                                            isGravity: !1
                                        });
                                    else if (i && !tt(i.$task, n.$view)) {
                                        if (!a.$config.original_grid_width) {
                                            var u = t.skins[t.skin];
                                            u && u.config && u.config.grid_width ? a.$config.original_grid_width = u.config.grid_width : a.$config.original_grid_width = 0
                                        }
                                        t.config.grid_width = a.$config.original_grid_width,
                                            a.$parent.$config.width = t.config.grid_width
                                    } else
                                        a.$parent._setContentSize(a.$config.width, null),
                                            t.$layout._syncCellSizes(a.$parent.$config.group, {
                                                value: t.config.grid_width,
                                                isGravity: !1
                                            })
                                } else
                                    i && tt(i.$task, n.$view) && (a.$config.original_grid_width = t.config.grid_width),
                                    e || (a.$parent.$config.width = 0)
                            }
                            e = !1
                        }
                    }),
                    this._initScrollStateEvents(n)
            },
            _initScrollStateEvents: function(n) {
                t._getVerticalScrollbar = this.getVerticalScrollbar,
                    t._getHorizontalScrollbar = this.getHorizontalScrollbar;
                var e = this.getVerticalScrollbar()
                    , i = this.getHorizontalScrollbar();
                e && e.attachEvent("onScroll", function(a, r, s) {
                    var o = t.getScrollState();
                    t.callEvent("onGanttScroll", [o.x, a, o.x, r])
                }),
                i && i.attachEvent("onScroll", function(a, r, s) {
                    var o = t.getScrollState();
                    t.callEvent("onGanttScroll", [a, o.y, r, o.y]);
                    var l = t.$ui.getView("grid");
                    l && l.$grid_data && !l.$config.scrollable && (l.$grid_data.style.left = l.$grid.scrollLeft + "px",
                        l.$grid_data.scrollLeft = l.$grid.scrollLeft)
                }),
                    n.attachEvent("onResize", function() {
                        e && !t.$scroll_ver && (t.$scroll_ver = e.$scroll_ver),
                        i && !t.$scroll_hor && (t.$scroll_hor = i.$scroll_hor)
                    })
            },
            _findGridResizer: function(n, e) {
                for (var i, a = n.getCellsByType("resizer"), r = !0, s = 0; s < a.length; s++) {
                    var o = a[s];
                    o._getSiblings();
                    var l = o._behind
                        , d = o._front;
                    if (l && l.$content === e || l.isChild && l.isChild(e)) {
                        i = o,
                            r = !0;
                        break
                    }
                    if (d && d.$content === e || d.isChild && d.isChild(e)) {
                        i = o,
                            r = !1;
                        break
                    }
                }
                return {
                    resizer: i,
                    gridFirst: r
                }
            },
            onInitialized: function(n) {
                var e = t.$ui.getView("grid")
                    , i = this._findGridResizer(n, e);
                if (i.resizer) {
                    var a, r = i.gridFirst, s = i.resizer;
                    if (s.$config.mode !== "x")
                        return;
                    s.attachEvent("onResizeStart", function(o, l) {
                        var d = t.$ui.getView("grid")
                            , c = d ? d.$parent : null;
                        if (c) {
                            var u = d._getGridWidthLimits();
                            d.$config.scrollable || (c.$config.minWidth = u[0]),
                                c.$config.maxWidth = u[1]
                        }
                        return a = r ? o : l,
                            t.callEvent("onGridResizeStart", [a])
                    }),
                        s.attachEvent("onResize", function(o, l) {
                            var d = r ? o : l;
                            return t.callEvent("onGridResize", [a, d])
                        }),
                        s.attachEvent("onResizeEnd", function(o, l, d, c) {
                            var u = r ? o : l
                                , h = r ? d : c
                                , _ = t.$ui.getView("grid")
                                , f = _ ? _.$parent : null;
                            f && (f.$config.minWidth = void 0);
                            var y = t.callEvent("onGridResizeEnd", [u, h]);
                            return y && h !== 0 && (t.config.grid_width = h),
                                y
                        })
                }
            },
            onDestroyed: function(n) {}
        }
    };
    const Mr = {
        init: function(t) {
            function n(r, s) {
                var o = s(t);
                o.onCreated && o.onCreated(r),
                    r.attachEvent("onReady", function() {
                        o.onInitialized && o.onInitialized(r)
                    }),
                    r.attachEvent("onDestroy", function() {
                        o.onDestroyed && o.onDestroyed(r)
                    })
            }
            var e = za(t);
            e.registerView("cell", xt),
                e.registerView("resizer", qa),
                e.registerView("scrollbar", Ya),
                e.registerView("layout", Yn, function(r) {
                    (r.$config ? r.$config.id : null) === "main" && n(r, Ar)
                }),
                e.registerView("viewcell", Ga),
                e.registerView("multiview", Ua),
                e.registerView("timeline", je, function(r) {
                    (r.$config ? r.$config.id : null) !== "timeline" && r.$config.bind != "task" || n(r, Dr)
                }),
                e.registerView("grid", ne, function(r) {
                    (r.$config ? r.$config.id : null) !== "grid" && r.$config.bind != "task" || n(r, Sr)
                }),
                e.registerView("resourceGrid", Xa),
                e.registerView("resourceTimeline", Jn),
                e.registerView("resourceHistogram", Za);
            var i = function(r) {
                var s = Wa(r);
                return {
                    getDataRender: function(o) {
                        return r.$services.getService("layer:" + o) || null
                    },
                    createDataRender: function(o) {
                        var l = o.name
                            , d = o.defaultContainer
                            , c = o.defaultContainerSibling
                            , u = s.createGroup(d, c, function(h, _) {
                            if (!u.filters)
                                return !0;
                            for (var f = 0; f < u.filters.length; f++)
                                if (u.filters[f](h, _) === !1)
                                    return !1
                        }, Va);
                        return r.$services.setService("layer:" + l, function() {
                            return u
                        }),
                            r.attachEvent("onGanttReady", function() {
                                u.addLayer()
                            }),
                            u
                    },
                    init: function() {
                        var o = this.createDataRender({
                            name: "task",
                            defaultContainer: function() {
                                return r.$task_data ? r.$task_data : r.$ui.getView("timeline") ? r.$ui.getView("timeline").$task_data : void 0
                            },
                            defaultContainerSibling: function() {
                                return r.$task_links ? r.$task_links : r.$ui.getView("timeline") ? r.$ui.getView("timeline").$task_links : void 0
                            },
                            filter: function(d) {}
                        }, r)
                            , l = this.createDataRender({
                            name: "link",
                            defaultContainer: function() {
                                return r.$task_data ? r.$task_data : r.$ui.getView("timeline") ? r.$ui.getView("timeline").$task_data : void 0
                            }
                        }, r);
                        return {
                            addTaskLayer: function(d) {
                                const c = et;
                                return typeof d == "function" ? d = {
                                    renderer: {
                                        render: d,
                                        getVisibleRange: c
                                    }
                                } : d.renderer && !d.renderer.getVisibleRange && (d.renderer.getVisibleRange = c),
                                    d.view = "timeline",
                                    o.addLayer(d)
                            },
                            _getTaskLayers: function() {
                                return o.getLayers()
                            },
                            removeTaskLayer: function(d) {
                                o.removeLayer(d)
                            },
                            _clearTaskLayers: function() {
                                o.clear()
                            },
                            addLinkLayer: function(d) {
                                const c = Gn();
                                return typeof d == "function" ? d = {
                                    renderer: {
                                        render: d,
                                        getVisibleRange: c
                                    }
                                } : d.renderer && !d.renderer.getVisibleRange && (d.renderer.getVisibleRange = c),
                                    d.view = "timeline",
                                d && d.renderer && (d.renderer.getRectangle || d.renderer.isInViewPort || (d.renderer.isInViewPort = qn)),
                                    l.addLayer(d)
                            },
                            _getLinkLayers: function() {
                                return l.getLayers()
                            },
                            removeLinkLayer: function(d) {
                                l.removeLayer(d)
                            },
                            _clearLinkLayers: function() {
                                l.clear()
                            }
                        }
                    }
                }
            }(t)
                , a = dr(t);
            return t.ext.inlineEditors = a,
                t.ext._inlineEditors = a,
                a.init(t),
                {
                    factory: e,
                    mouseEvents: Fa.init(t),
                    layersApi: i.init(),
                    render: {
                        gridLine: function() {
                            return function(r) {
                                return {
                                    render: function(s, o, l, d) {
                                        for (var c = o.getGridColumns(), u = o.$getTemplates(), h = o.$config.rowStore, _ = [], f = 0; f < c.length; f++) {
                                            var y, v, b, g = f == c.length - 1, m = c[f];
                                            m.name == "add" ? (v = "<div " + (S = r._waiAria.gridAddButtonAttrString(m)) + " class='gantt_add'></div>",
                                                b = "") : (nt(v = m.template ? m.template(s) : s[m.name]) && (v = u.date_grid(v, s, m.name)),
                                            v == null && (v = ""),
                                                b = v,
                                                v = "<div class='gantt_tree_content'>" + v + "</div>");
                                            var p = "gantt_cell" + (g ? " gantt_last_cell" : "")
                                                , k = [];
                                            if (m.tree) {
                                                p += " gantt_cell_tree";
                                                for (var w = 0; w < s.$level; w++)
                                                    k.push(u.grid_indent(s));
                                                !h.hasChild(s.id) || r.isSplitTask(s) && !r.config.open_split_tasks ? (k.push(u.grid_blank(s)),
                                                    k.push(u.grid_file(s))) : (k.push(u.grid_open(s)),
                                                    k.push(u.grid_folder(s)))
                                            }
                                            var x = "width:" + (m.width - (g ? 1 : 0)) + "px;";
                                            if (this.defined(m.align)) {
                                                var $ = {
                                                    right: "flex-end",
                                                    left: "flex-start",
                                                    center: "center"
                                                }[m.align];
                                                x += "text-align:" + m.align + ";justify-content:" + $ + ";"
                                            }
                                            var S = r._waiAria.gridCellAttrString(m, b, s);
                                            k.push(v),
                                                y = "<div class='" + p + "' data-column-index='" + f + "' data-column-name='" + m.name + "' style='" + x + "' " + S + ">" + k.join("") + "</div>",
                                                _.push(y)
                                        }
                                        switch (p = "",
                                            h.$config.name) {
                                            case "task":
                                                p = r.getGlobalTaskIndex(s.id) % 2 == 0 ? "" : " odd";
                                                break;
                                            case "resource":
                                                p = h.visibleOrder.indexOf(s.id) % 2 == 0 ? "" : " odd"
                                        }
                                        if (p += s.$transparent ? " gantt_transparent" : "",
                                            p += s.$dataprocessor_class ? " " + s.$dataprocessor_class : "",
                                            u.grid_row_class) {
                                            var T = u.grid_row_class.call(r, s.start_date, s.end_date, s);
                                            T && (p += " " + T)
                                        }
                                        h.isSelected(s.id) && (p += " gantt_selected");
                                        var E = document.createElement("div");
                                        E.className = "gantt_row" + p + " gantt_row_" + r.getTaskType(s.type);
                                        var C = o.getItemHeight(s.id);
                                        return E.style.height = C + "px",
                                            E.style.lineHeight = C + "px",
                                        l.smart_rendering && (E.style.position = "absolute",
                                            E.style.left = "0px",
                                            E.style.top = o.getItemTop(s.id) + "px"),
                                        o.$config.item_attribute && (E.setAttribute(o.$config.item_attribute, s.id),
                                            E.setAttribute(o.$config.bind + "_id", s.id)),
                                            r._waiAria.taskRowAttr(s, E),
                                            E.innerHTML = _.join(""),
                                            E
                                    },
                                    update: null,
                                    getRectangle: ae,
                                    isInViewPort: fr,
                                    getVisibleRange: et,
                                    onrender: function(s, o, l) {
                                        for (var d = l.getGridColumns(), c = 0; c < d.length; c++) {
                                            var u = d[c];
                                            if (u.onrender) {
                                                var h = o.querySelector(`[data-column-name="${u.name}"]`);
                                                if (h) {
                                                    var _ = u.onrender(s, h);
                                                    if (_ && typeof _ == "string")
                                                        h.innerHTML = _;
                                                    else if (_ && typeof _ == "object" && r.config.external_render) {
                                                        var f = r.config.external_render;
                                                        f.isElement(_) && f.renderElement(_, h)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }(t)
                        },
                        taskBg: function() {
                            return function(r) {
                                var s = {}
                                    , o = {};
                                function l(_, f) {
                                    return !(!s[_.id][f] || !s[_.id][f].parentNode)
                                }
                                function d(_, f) {
                                    s[_] && s[_][f] && s[_][f].parentNode && s[_][f].parentNode.removeChild(s[_][f])
                                }
                                function c(_) {
                                    var f, y = _.$getTemplates();
                                    return y.task_cell_class !== void 0 ? (f = y.task_cell_class,
                                        (console.warn || console.log)("gantt.templates.task_cell_class template is deprecated and will be removed soon. Please use gantt.templates.timeline_cell_class instead.")) : f = y.timeline_cell_class,
                                        f
                                }
                                function u(_) {
                                    return _.$getTemplates().timeline_cell_content
                                }
                                function h(_, f, y, v, b, g, m, p) {
                                    var k = _.width[f]
                                        , w = "";
                                    if (Ut(f, _, v, r)) {
                                        var x = g(y, _.trace_x[f])
                                            , $ = "";
                                        if (m && ($ = m(y, _.trace_x[f])),
                                            p.static_background) {
                                            var S = !(!x && !$);
                                            if (!p.static_background_cells || !S)
                                                return null
                                        }
                                        if (s[y.id][f])
                                            return o[y.id][f] = f,
                                                s[y.id][f];
                                        var T = document.createElement("div");
                                        return T.style.width = k + "px",
                                            w = "gantt_task_cell" + (f == b - 1 ? " gantt_last_cell" : ""),
                                        x && (w += " " + x),
                                            T.className = w,
                                        $ && (T.innerHTML = $),
                                            T.style.position = "absolute",
                                            T.style.left = _.left[f] + "px",
                                            s[y.id][f] = T,
                                            o[y.id][f] = f,
                                            T
                                    }
                                    return null
                                }
                                return {
                                    render: function(_, f, y, v) {
                                        var b = f.$getTemplates()
                                            , g = f.getScale()
                                            , m = g.count;
                                        if (y.static_background && !y.static_background_cells)
                                            return null;
                                        var p, k = document.createElement("div"), w = c(f), x = u(f);
                                        if (p = v && y.smart_rendering && !Vt(r) ? Dt(g, v.x) : {
                                            start: 0,
                                            end: m - 1
                                        },
                                            y.show_task_cells) {
                                            s[_.id] = {},
                                                o[_.id] = {};
                                            for (var $ = p.start; $ <= p.end; $++) {
                                                var S = h(g, $, _, v, m, w, x, y);
                                                S && k.appendChild(S)
                                            }
                                        }
                                        const T = f.$config.rowStore
                                            , E = T.getIndexById(_.id) % 2 != 0;
                                        var C = b.task_row_class(_.start_date, _.end_date, _)
                                            , D = "gantt_task_row" + (E ? " odd" : "") + (C ? " " + C : "");
                                        if (T.isSelected(_.id) && (D += " gantt_selected"),
                                            k.className = D,
                                            y.smart_rendering ? (k.style.position = "absolute",
                                                k.style.top = f.getItemTop(_.id) + "px",
                                                k.style.width = "100%") : k.style.position = "relative",
                                            k.style.height = f.getItemHeight(_.id) + "px",
                                        _.id == "timeline_placeholder_task") {
                                            var A = 0;
                                            _.lastTaskId && (A = f.getItemTop(_.lastTaskId) + f.getItemHeight(_.lastTaskId));
                                            var I = (_.row_height || f.$task_data.offsetHeight) - A;
                                            I < 0 && (I = 0),
                                            y.smart_rendering && (k.style.top = A + "px"),
                                                k.style.height = I + "px"
                                        }
                                        return f.$config.item_attribute && (k.setAttribute(f.$config.item_attribute, _.id),
                                            k.setAttribute(f.$config.bind + "_id", _.id)),
                                            k
                                    },
                                    update: function(_, f, y, v, b) {
                                        var g = y.getScale()
                                            , m = g.count
                                            , p = c(y)
                                            , k = u(y);
                                        if (v.show_task_cells) {
                                            s[_.id] || (s[_.id] = {}),
                                            o[_.id] || (o[_.id] = {});
                                            var w = Dt(g, b);
                                            for (var x in o[_.id]) {
                                                var $ = o[_.id][x];
                                                (Number($) < w.start || Number($) > w.end) && d(_.id, $)
                                            }
                                            o[_.id] = {};
                                            for (var S = w.start; S <= w.end; S++) {
                                                var T = h(g, S, _, b, m, p, k, v);
                                                !T && l(_, S) ? d(_.id, S) : T && !T.parentNode && f.appendChild(T)
                                            }
                                        }
                                    },
                                    getRectangle: Ue,
                                    getVisibleRange: et,
                                    prepareData: _r
                                }
                            }(t)
                        },
                        taskBar: function() {
                            return function(r) {
                                return {
                                    render: Ve(r),
                                    update: null,
                                    isInViewPort: Ot,
                                    getVisibleRange: et
                                }
                            }(t)
                        },
                        timedProjectBar: function() {
                            return function(r) {
                                return {
                                    render: ur(r),
                                    update: null,
                                    isInViewPort: cr,
                                    getVisibleRange: et
                                }
                            }(t)
                        },
                        taskRollupBar: function() {
                            return function(r) {
                                const s = Ve(r)
                                    , o = {};
                                function l(u, h, _, f, y) {
                                    let v = !0;
                                    return f.smart_rendering && (v = Ot(u, h, _)),
                                        v
                                }
                                function d(u, h, _, f) {
                                    const y = r.copy(r.getTask(h.id));
                                    if (y.$rendered_at = u.id,
                                    r.callEvent("onBeforeRollupTaskDisplay", [y.id, y, u.id]) === !1)
                                        return;
                                    const v = s(y, _);
                                    if (!v)
                                        return;
                                    const b = _.getBarHeight(u.id, h.type == r.config.types.milestone)
                                        , g = Math.floor((_.getItemHeight(u.id) - b) / 2);
                                    return v.style.top = f.top + g + "px",
                                        v.classList.add("gantt_rollup_child"),
                                        v.setAttribute("data-rollup-parent-id", u.id),
                                        v
                                }
                                function c(u, h) {
                                    return u + "_" + h
                                }
                                return {
                                    render: function(u, h, _, f) {
                                        if (u.rollup !== !1 && u.$rollup && u.$rollup.length) {
                                            const y = document.createElement("div")
                                                , v = r.getTaskPosition(u);
                                            return f && (f.y = 0,
                                                f.y_end = r.$task_bg.scrollHeight),
                                                u.$rollup.forEach(function(b) {
                                                    if (!r.isTaskExists(b))
                                                        return;
                                                    const g = r.getTask(b);
                                                    if (!l(g, f, h, _))
                                                        return;
                                                    const m = d(u, g, h, v);
                                                    m ? (o[c(g.id, u.id)] = m,
                                                        y.appendChild(m)) : o[c(g.id, u.id)] = !1
                                                }),
                                                y
                                        }
                                        return !1
                                    },
                                    update: function(u, h, _, f, y) {
                                        const v = document.createElement("div")
                                            , b = r.getTaskPosition(u);
                                        y.y = 0,
                                            y.y_end = r.$task_bg.scrollHeight,
                                            u.$rollup.forEach(function(g) {
                                                const m = r.getTask(g)
                                                    , p = c(m.id, u.id);
                                                let k = l(m, y, _, f);
                                                if (k !== !!o[p])
                                                    if (k) {
                                                        const w = d(u, m, _, b);
                                                        o[p] = w || !1
                                                    } else
                                                        o[p] = !1;
                                                o[p] && v.appendChild(o[p]),
                                                    h.innerHTML = "",
                                                    h.appendChild(v)
                                            })
                                    },
                                    isInViewPort: Ot,
                                    getVisibleRange: et
                                }
                            }(t)
                        },
                        taskSplitBar: function() {
                            return function(r) {
                                const s = Ve(r)
                                    , o = {};
                                function l(h, _, f, y, v) {
                                    let b = !h.hide_bar;
                                    return y.smart_rendering && b && (b = Ot(h, _, f)),
                                        b
                                }
                                function d(h, _, f, y, v) {
                                    if (_.hide_bar)
                                        return;
                                    const b = r.isSummaryTask(_);
                                    b && r.resetProjectDates(_);
                                    const g = r.copy(r.getTask(_.id));
                                    if (g.$rendered_at = h.id,
                                    r.callEvent("onBeforeSplitTaskDisplay", [g.id, g, h.id]) === !1)
                                        return;
                                    const m = s(g, f);
                                    if (!m)
                                        return;
                                    const p = _.type === r.config.types.milestone;
                                    let k;
                                    const w = y.rowHeight
                                        , x = f.getBarHeight(g.id, p);
                                    let $ = Math.floor((f.getItemHeight(h.id) - x) / 2);
                                    p && (k = Mn(x)),
                                    v && ($ = p ? Math.floor((k - x) / 2) + 2 : 2);
                                    const S = m.querySelector(".gantt_link_control.task_start_date")
                                        , T = m.querySelector(".gantt_link_control.task_end_date");
                                    if (p) {
                                        if (k > w) {
                                            $ = 2,
                                                m.style.height = w - $ + "px";
                                            const E = In(w)
                                                , C = (E - w) / 2
                                                , D = m.querySelector(".gantt_task_content");
                                            $ = Math.abs(C),
                                                S.style.marginLeft = C + "px",
                                                T.style.marginRight = C + "px",
                                                S.style.height = T.style.height = E + "px",
                                                m.style.width = D.style.height = D.style.width = E + "px",
                                                m.style.left = f.getItemPosition(g).left - E / 2 + "px"
                                        }
                                    } else
                                        x + $ > w && ($ = 0,
                                            m.style.height = m.style.lineHeight = S.style.height = T.style.height = w + "px");
                                    return m.style.top = y.top + $ + "px",
                                        m.classList.add("gantt_split_child"),
                                    b && m.classList.add("gantt_split_subproject"),
                                        m
                                }
                                function c(h, _) {
                                    return h + "_" + _
                                }
                                function u(h, _) {
                                    return r.isSplitTask(h) && (_.open_split_tasks && !h.$open || !_.open_split_tasks) && r.hasChild(h.id)
                                }
                                return {
                                    render: function(h, _, f, y) {
                                        if (u(h, f)) {
                                            const v = document.createElement("div")
                                                , b = r.getTaskPosition(h)
                                                , g = Ft(r, h.id);
                                            return r.hasChild(h.id) && r.eachTask(function(m) {
                                                if (!l(m, y, _, f))
                                                    return;
                                                const p = d(h, m, _, b, g);
                                                p ? (o[c(m.id, h.id)] = p,
                                                    v.appendChild(p)) : o[c(m.id, h.id)] = !1
                                            }, h.id),
                                                v
                                        }
                                        return !1
                                    },
                                    update: function(h, _, f, y, v) {
                                        if (u(h, y)) {
                                            const b = document.createElement("div")
                                                , g = r.getTaskPosition(h)
                                                , m = Ft(r, h.id);
                                            r.eachTask(function(p) {
                                                const k = c(p.id, h.id);
                                                let w = l(p, v, f, y);
                                                if (w !== !!o[k])
                                                    if (w) {
                                                        const x = d(h, p, f, g, m);
                                                        o[k] = x || !1
                                                    } else
                                                        o[k] = !1;
                                                o[k] && b.appendChild(o[k]),
                                                    _.innerHTML = "",
                                                    _.appendChild(b)
                                            }, h.id)
                                        }
                                    },
                                    isInViewPort: hr,
                                    getVisibleRange: et
                                }
                            }(t)
                        },
                        taskConstraints: function() {
                            return yr(t)
                        },
                        taskDeadline: function() {
                            return function(r) {
                                function s(o, l, d) {
                                    const c = document.createElement("div")
                                        , u = r.getTaskPosition(o, o.deadline, o.deadline)
                                        , {height: h, marginTop: _} = Ln(r, l, u, 20, o, d);
                                    let f = h;
                                    return r.config.rtl && (u.left += f),
                                        c.style.left = u.left - f + "px",
                                        c.style.top = u.top + "px",
                                        c.style.marginTop = _ + "px",
                                        c.style.width = f + "px",
                                        c.style.height = h + "px",
                                        c.style.fontSize = h + "px",
                                        c.className = "gantt_task_deadline",
                                        c.setAttribute("data-task-id", o.id),
                                        c
                                }
                                return {
                                    render: function(o, l, d, c) {
                                        const u = document.createElement("div");
                                        if (u.className = "gantt_deadline_nodes",
                                            u.setAttribute("data-task-row-id", o.id),
                                            o.deadline) {
                                            const h = s(o, l);
                                            u.appendChild(h)
                                        }
                                        if (ft(o)) {
                                            const h = Ft(r, o.id);
                                            r.eachTask(function(_) {
                                                if (_.deadline) {
                                                    const f = s(_, l, h);
                                                    u.appendChild(f)
                                                }
                                            }, o.id)
                                        }
                                        if (u.childNodes.length)
                                            return u
                                    },
                                    isInViewPort: br,
                                    getVisibleRange: et
                                }
                            }(t)
                        },
                        taskBaselines: function() {
                            return function(r) {
                                function s(o, l, d, c, u) {
                                    const h = document.createElement("div");
                                    let _ = l.end_date
                                        , f = o.type === r.config.types.milestone;
                                    f && (_ = l.start_date);
                                    const y = r.getTaskPosition(o, l.start_date, _);
                                    let v, b = 0;
                                    if (f) {
                                        let T = c.getBarHeight(o.id, !0);
                                        v = Mn(T),
                                            b = Math.floor((v - T) / 4)
                                    }
                                    let g = ee(r, c, o, y.rowHeight).maxHeight
                                        , m = y.top + 1 + b
                                        , p = c.getBarHeight(o.id, o.type);
                                    const k = r.config.baselines.row_height
                                        , w = r.config.baselines.bar_height;
                                    let x, $;
                                    switch (r.config.baselines.render_mode) {
                                        case "separateRow":
                                            m += y.height + (k - w) / 2,
                                                p = w;
                                            break;
                                        case "individualRow":
                                            x = k * d,
                                                m += y.height + x + (k - w) / 2,
                                                p = w;
                                            break;
                                        default:
                                            $ = 1,
                                                u ? (g = ee(r, c, o).maxHeight,
                                                    b ? g >= v ? $ = (g - p) / 2 - 1 - b : (p = In(g),
                                                        m = y.top,
                                                        $ = Math.abs(p - g) / 2,
                                                        b = 0) : (g > p && ($ = (g - p) / 2 - 1),
                                                        $ -= b),
                                                o.bar_height || ($ -= 1)) : (o.bar_height && y.rowHeight >= o.bar_height && ($ = (y.rowHeight - o.bar_height) / 2 - 1),
                                                    $ += b,
                                                o.bar_height || ($ += 2),
                                                f && ($ += 1))
                                    }
                                    let S = y.top + g + 1 - b;
                                    return !(m + p > S && (p -= m + p - S,
                                    p <= 0)) && (h.style.left = y.left + "px",
                                        h.style.width = y.width + "px",
                                        h.style.top = m + "px",
                                        h.style.height = Math.floor(p) + "px",
                                    $ && (h.style.marginTop = $ + "px"),
                                        h.className = `gantt_task_baseline gantt_task_baseline_${d} ${l.className || ""}`,
                                        f ? (h.className += " gantt_milestone_baseline",
                                            h.style.width = h.style.height = p + "px",
                                            h.style.marginLeft = Math.floor(-p / 2) + "px") : h.innerHTML = r.templates.baseline_text(o, l, d),
                                        h.setAttribute("data-task-id", o.id),
                                        h.setAttribute("data-baseline-id", l.id),
                                        h)
                                }
                                return {
                                    render: function(o, l, d, c) {
                                        if (!r.config.baselines.render_mode)
                                            return;
                                        const u = document.createElement("div");
                                        return u.className = "gantt_baseline_nodes",
                                            u.setAttribute("data-task-row-id", o.id),
                                        o.baselines && o.baselines.length && o.baselines.forEach(function(h, _) {
                                            const f = s(o, h, _, l);
                                            f && u.appendChild(f)
                                        }),
                                        ft(o) && r.eachTask(function(h) {
                                            h.baselines && h.baselines.length && h.baselines.forEach(function(_, f) {
                                                const y = s(h, _, f, l, !0);
                                                y && u.appendChild(y)
                                            })
                                        }, o.id),
                                            u.childNodes.length ? u : void 0
                                    },
                                    isInViewPort: $r,
                                    getVisibleRange: et
                                }
                            }(t)
                        },
                        link: function() {
                            return gr(t)
                        },
                        resourceRow: function() {
                            return function(r) {
                                var s = Kn(r)
                                    , o = {};
                                function l(c, u, h, _, f) {
                                    var y = h.resource_cell_class(u.start_date, u.end_date, c, u.tasks, u.assignments)
                                        , v = h.resource_cell_value(u.start_date, u.end_date, c, u.tasks, u.assignments)
                                        , b = f.getItemHeight(c.id) - 1;
                                    if (y || v) {
                                        var g = f.getItemPosition(c, u.start_date, u.end_date)
                                            , m = document.createElement("div");
                                        return m.setAttribute(f.$config.item_attribute, c.id),
                                            m.className = ["gantt_resource_marker", y].join(" "),
                                            m.style.cssText = ["left:" + g.left + "px", "width:" + g.width + "px", "height:" + b + "px", "line-height:" + b + "px", "top:" + g.top + "px"].join(";"),
                                        v && (m.innerHTML = v),
                                            m
                                    }
                                    return null
                                }
                                function d(c, u) {
                                    o[c] && o[c][u] && o[c][u].parentNode && o[c][u].parentNode.removeChild(o[c][u])
                                }
                                return {
                                    render: function(c, u, h, _) {
                                        var f = u.$getTemplates()
                                            , y = u.getScale()
                                            , v = s(c, h.resource_property, u.getScale(), u)
                                            , b = !!_
                                            , g = [];
                                        o[c.id] = {};
                                        for (var m = Dt(y, _), p = m.start; p <= m.end; p++) {
                                            var k = v[p];
                                            if (k && (!b || Ut(p, y, _, r))) {
                                                var w = l(c, k, f, 0, u);
                                                w && (g.push(w),
                                                    o[c.id][p] = w)
                                            }
                                        }
                                        var x = null;
                                        if (g.length) {
                                            x = document.createElement("div");
                                            for (var $ = 0; $ < g.length; $++)
                                                x.appendChild(g[$])
                                        }
                                        return x
                                    },
                                    update: function(c, u, h, _, f) {
                                        var y = h.$getTemplates()
                                            , v = h.getScale()
                                            , b = s(c, _.resource_property, h.getScale(), h)
                                            , g = Dt(v, f)
                                            , m = {};
                                        if (o && o[c.id])
                                            for (var p in o[c.id])
                                                m[p] = p;
                                        for (var k = g.start; k <= g.end; k++) {
                                            var w = b[k];
                                            if (m[k] = !1,
                                                w)
                                                if (Ut(k, v, f, r))
                                                    if (o[c.id] && o[c.id][k])
                                                        o[c.id] && o[c.id][k] && !o[c.id][k].parentNode && u.appendChild(o[c.id][k]);
                                                    else {
                                                        var x = l(c, w, y, 0, h);
                                                        x && (u.appendChild(x),
                                                            o[c.id][k] = x)
                                                    }
                                                else
                                                    d(c.id, k)
                                        }
                                        for (var p in m)
                                            m[p] !== !1 && d(c.id, p)
                                    },
                                    getRectangle: Ue,
                                    getVisibleRange: et
                                }
                            }(t)
                        },
                        resourceHistogram: function() {
                            return vr(t)
                        },
                        gridTaskRowResizer: function() {
                            return function(r) {
                                return {
                                    render: function(s, o, l) {
                                        var d = o.$getConfig()
                                            , c = document.createElement("div");
                                        return c.className = "gantt_task_grid_row_resize_wrap",
                                            c.style.top = o.getItemTop(s.id) + o.getItemHeight(s.id) + "px",
                                            c.innerHTML = "<div class='gantt_task_grid_row_resize' role='cell'></div>",
                                            c.setAttribute(d.task_grid_row_resizer_attribute, s.id),
                                            r._waiAria.rowResizerAttr(c),
                                            c
                                    },
                                    update: null,
                                    getRectangle: ae,
                                    getVisibleRange: et
                                }
                            }(t)
                        }
                    },
                    layersService: {
                        getDataRender: function(r) {
                            return i.getDataRender(r, t)
                        },
                        createDataRender: function(r) {
                            return i.createDataRender(r, t)
                        }
                    }
                }
        }
    };
    function Je(t, n) {
        const e = getComputedStyle(n.$root).getPropertyValue("--dhx-gantt-theme");
        let i, a = !!e;
        if (a)
            i = e;
        else {
            var r = n.skin;
            if (i = r,
            !r || t)
                for (var s = document.getElementsByTagName("link"), o = 0; o < s.length; o++) {
                    var l = s[o].href.match("dhtmlxgantt_([a-z_]+).css");
                    if (l && (n.skins[l[1]] || !r)) {
                        i = l[1];
                        break
                    }
                }
        }
        n._theme_info = {
            theme: i,
            cssVarTheme: a
        },
            n.skin = i || "terrace";
        var d = n.skins[n.skin] || n.skins.terrace;
        (function(h, _, f) {
                for (var y in _)
                    (h[y] === void 0 || f) && (h[y] = _[y])
            }
        )(n.config, d.config, t),
        a || (n.config.link_radius = 1);
        var c = n.getGridColumns();
        for (c[1] && !n.defined(c[1].width) && (c[1].width = d._second_column_width),
             c[2] && !n.defined(c[2].width) && (c[2].width = d._third_column_width),
                 o = 0; o < c.length; o++) {
            var u = c[o];
            u.name == "add" && (u.width || (u.width = 44),
            n.defined(u.min_width) && n.defined(u.max_width) || (u.min_width = u.min_width || u.width,
                u.max_width = u.max_width || u.width),
            u.min_width && (u.min_width = +u.min_width),
            u.max_width && (u.max_width = +u.max_width),
            u.width && (u.width = +u.width,
                u.width = u.min_width && u.min_width > u.width ? u.min_width : u.width,
                u.width = u.max_width && u.max_width < u.width ? u.max_width : u.width))
        }
        d.config.task_height && (n.config.task_height = d.config.task_height || "full"),
        d.config.bar_height && (n.config.bar_height = d.config.bar_height || "full"),
        d._lightbox_template && (n._lightbox_template = d._lightbox_template),
        d._redefine_lightbox_buttons && (n.config.buttons_right = d._redefine_lightbox_buttons.buttons_right,
            n.config.buttons_left = d._redefine_lightbox_buttons.buttons_left),
            n.resetLightbox()
    }
    function Ir(t) {
        var n = null
            , e = !1
            , i = null
            , a = {
            started: !1
        }
            , r = {};
        function s(_) {
            return _ && tt(_, t.$root) && _.offsetHeight
        }
        function o() {
            var _ = !!document.querySelector(".gantt_drag_marker")
                , f = !!document.querySelector(".gantt_drag_marker.gantt_grid_resize_area") || !!document.querySelector(".gantt_drag_marker.gantt_row_grid_resize_area")
                , y = !!document.querySelector(".gantt_link_direction")
                , v = t.getState()
                , b = v.autoscroll;
            return e = _ && !f && !y,
            !(!v.drag_mode && !_ || f) || b
        }
        function l(_) {
            if (i && (clearTimeout(i),
                i = null),
                _) {
                var f = t.config.autoscroll_speed;
                f && f < 10 && (f = 10),
                    i = setTimeout(function() {
                        n = setInterval(u, f || 50)
                    }, t.config.autoscroll_delay || 10)
            }
        }
        function d(_) {
            _ ? (l(!0),
            a.started || (a.x = r.x,
                a.y = r.y,
                a.started = !0)) : (n && (clearInterval(n),
                n = null),
                l(!1),
                a.started = !1)
        }
        function c(_) {
            var f = o();
            if (!n && !i || f || d(!1),
            !t.config.autoscroll || !f)
                return !1;
            r = {
                x: _.clientX,
                y: _.clientY
            },
            _.type == "touchmove" && (r.x = _.targetTouches[0].clientX,
                r.y = _.targetTouches[0].clientY),
            !n && f && d(!0)
        }
        function u() {
            if (!o())
                return d(!1),
                    !1;
            var _ = s(t.$task) ? t.$task : s(t.$grid) ? t.$grid : t.$root;
            if (_) {
                var f = !1;
                [".gantt_drag_marker.gantt_grid_resize_area", ".gantt_drag_marker .gantt_row.gantt_row_task", ".gantt_drag_marker.gantt_grid_dnd_marker"].forEach(function(C) {
                    f = f || !!document.querySelector(C)
                }),
                f && (_ = t.$grid);
                var y = Y(_)
                    , v = r.x - y.x
                    , b = r.y - y.y + window.scrollY
                    , g = e ? 0 : h(v, y.width, a.x - y.x)
                    , m = h(b, y.height, a.y - y.y + window.scrollY)
                    , p = t.getScrollState()
                    , k = p.y
                    , w = p.inner_height
                    , x = p.height
                    , $ = p.x
                    , S = p.inner_width
                    , T = p.width;
                (m && !w || m < 0 && !k || m > 0 && k + w >= x + 2) && (m = 0),
                (g && !S || g < 0 && !$ || g > 0 && $ + S >= T) && (g = 0);
                var E = t.config.autoscroll_step;
                E && E < 2 && (E = 2),
                    m *= E || 30,
                ((g *= E || 30) || m) && function(C, D) {
                    var A = t.getScrollState()
                        , I = null
                        , M = null;
                    C && (I = A.x + C,
                        I = Math.min(A.width, I),
                        I = Math.max(0, I)),
                    D && (M = A.y + D,
                        M = Math.min(A.height, M),
                        M = Math.max(0, M)),
                        t.scrollTo(I, M)
                }(g, m)
            }
        }
        function h(_, f, y) {
            return _ - 50 < 0 && _ < y ? -1 : _ > f - 50 && _ > y ? 1 : 0
        }
        t.attachEvent("onGanttReady", function() {
            if (!K(t)) {
                var _ = Ct(t.$root) || document.body;
                t.eventRemove(_, "mousemove", c),
                    t.event(_, "mousemove", c),
                    t.eventRemove(_, "touchmove", c),
                    t.event(_, "touchmove", c),
                    t.eventRemove(_, "pointermove", c),
                    t.event(_, "pointermove", c)
            }
        }),
            t.attachEvent("onDestroy", function() {
                d(!1)
            })
    }
    var Ke, Xe;
    typeof window < "u" && window.jQuery && (Ke = window.jQuery,
            Xe = [],
            Ke.fn.dhx_gantt = function(t) {
                if (typeof (t = t || {}) != "string") {
                    var n = [];
                    return this.each(function() {
                        if (this && this.getAttribute)
                            if (this.gantt || window.gantt.$root == this)
                                n.push(typeof this.gantt == "object" ? this.gantt : window.gantt);
                            else {
                                var e = window.gantt.$container && window.Gantt ? window.Gantt.getGanttInstance() : window.gantt;
                                for (var i in t)
                                    i != "data" && (e.config[i] = t[i]);
                                e.init(this),
                                t.data && e.parse(t.data),
                                    n.push(e)
                            }
                    }),
                        n.length === 1 ? n[0] : n
                }
                if (Xe[t])
                    return Xe[t].apply(this, []);
                Ke.error("Method " + t + " does not exist on jQuery.dhx_gantt")
            }
    ),
    typeof window < "u" && window.dhtmlx && (window.dhtmlx.attaches || (window.dhtmlx.attaches = {}),
            window.dhtmlx.attaches.attachGantt = function(t, n, e) {
                var i = document.createElement("DIV");
                e = e || window.gantt,
                    i.id = "gantt_" + e.uid(),
                    i.style.width = "100%",
                    i.style.height = "100%",
                    i.cmp = "grid",
                    document.body.appendChild(i),
                    this.attachObject(i.id),
                    this.dataType = "gantt",
                    this.dataObj = e;
                var a = this.vs[this.av];
                return a.grid = e,
                    e.init(i.id, t, n),
                    i.firstChild.style.border = "none",
                    a.gridId = i.id,
                    a.gridObj = i,
                    this.vs[this._viewRestore()].grid
            }
    ),
    typeof window < "u" && window.dhtmlXCellObject !== void 0 && (window.dhtmlXCellObject.prototype.attachGantt = function(t, n, e) {
            e = e || window.gantt;
            var i = document.createElement("DIV");
            return i.id = "gantt_" + e.uid(),
                i.style.width = "100%",
                i.style.height = "100%",
                i.cmp = "grid",
                document.body.appendChild(i),
                this.attachObject(i.id),
                this.dataType = "gantt",
                this.dataObj = e,
                e.init(i.id, t, n),
                i.firstChild.style.border = "none",
                i = null,
                this.callEvent("_onContentAttach", []),
                this.dataObj
        }
    );
    const Lr = ["ctrlKey", "altKey", "shiftKey", "metaKey"]
        , Nr = [[{
        unit: "month",
        date: "%M",
        step: 1
    }, {
        unit: "day",
        date: "%d",
        step: 1
    }], [{
        unit: "day",
        date: "%d %M",
        step: 1
    }], [{
        unit: "day",
        date: "%d %M",
        step: 1
    }, {
        unit: "hour",
        date: "%H:00",
        step: 8
    }], [{
        unit: "day",
        date: "%d %M",
        step: 1
    }, {
        unit: "hour",
        date: "%H:00",
        step: 1
    }]];
    class Pr {
        constructor(n) {
            this.zoomIn = () => {
                const e = this.getCurrentLevel() - 1;
                e < 0 || this.setLevel(e)
            }
                ,
                this.zoomOut = () => {
                    const e = this.getCurrentLevel() + 1;
                    e > this._levels.length - 1 || this.setLevel(e)
                }
                ,
                this.getCurrentLevel = () => this._activeLevelIndex,
                this.getLevels = () => this._levels,
                this.setLevel = e => {
                    const i = this._getZoomIndexByName(e);
                    i === -1 && this.$gantt.assert(i !== -1, "Invalid zoom level for gantt.ext.zoom.setLevel. " + e + " is not an expected value."),
                        this._setLevel(i, 0)
                }
                ,
                this._getZoomIndexByName = e => {
                    let i = -1;
                    if (typeof e == "string") {
                        if (!isNaN(Number(e)) && this._levels[Number(e)])
                            i = Number(e);
                        else
                            for (let a = 0; a < this._levels.length; a++)
                                if (this._levels[a].name === e) {
                                    i = a;
                                    break
                                }
                    } else
                        i = e;
                    return i
                }
                ,
                this._getVisibleDate = () => {
                    if (!this.$gantt.$task)
                        return null;
                    const e = this.$gantt.getScrollState().x
                        , i = this.$gantt.$task.offsetWidth;
                    this._visibleDate = this.$gantt.dateFromPos(e + i / 2)
                }
                ,
                this._setLevel = (e, i) => {
                    this._activeLevelIndex = e;
                    const a = this.$gantt
                        , r = a.copy(this._levels[this._activeLevelIndex])
                        , s = a.copy(r);
                    if (delete s.name,
                        a.mixin(a.config, s, !0),
                        ["resourceTimeline", "resourceHistogram"].forEach(function(o) {
                            const l = a.$ui.getView(o);
                            if (l) {
                                const d = l.$getConfig();
                                d.fixed_scales || a.mixin(d, s, !0)
                            }
                        }),
                    a.$root && a.$task) {
                        if (i) {
                            const o = this.$gantt.dateFromPos(i + this.$gantt.getScrollState().x);
                            this.$gantt.render();
                            const l = this.$gantt.posFromDate(o);
                            this.$gantt.scrollTo(l - i)
                        } else {
                            const o = this.$gantt.$task.offsetWidth;
                            this._visibleDate || this._getVisibleDate();
                            const l = this._visibleDate;
                            this.$gantt.render();
                            const d = this.$gantt.posFromDate(l);
                            this.$gantt.scrollTo(d - o / 2)
                        }
                        this.callEvent("onAfterZoom", [this._activeLevelIndex, r])
                    }
                }
                ,
                this._attachWheelEvent = e => {
                    const i = kt.isFF ? "wheel" : "mousewheel";
                    let a;
                    a = typeof e.element == "function" ? e.element() : e.element,
                    a && this._domEvents.attach(a, i, this.$gantt.bind(function(r) {
                        if (this._useKey && (Lr.indexOf(this._useKey) < 0 || !r[this._useKey]))
                            return !1;
                        if (typeof this._handler == "function")
                            return this._handler.apply(this, [r]),
                                !0
                    }, this), {
                        passive: !1
                    })
                }
                ,
                this._defaultHandler = e => {
                    const i = this.$gantt.$task.getBoundingClientRect().x
                        , a = e.clientX - i;
                    let r = !1;
                    (this.$gantt.env.isFF ? -40 * e.deltaY : e.wheelDelta) > 0 && (r = !0),
                        e.preventDefault(),
                        e.stopPropagation(),
                        this._setScaleSettings(r, a)
                }
                ,
                this._setScaleDates = () => {
                    this._initialStartDate && this._initialEndDate && (this.$gantt.config.start_date = this._initialStartDate,
                        this.$gantt.config.end_date = this._initialEndDate)
                }
                ,
                this.$gantt = n,
                this._domEvents = this.$gantt._createDomEventScope()
        }
        init(n) {
            this.$gantt.env.isNode || (this._initialStartDate = n.startDate,
                this._initialEndDate = n.endDate,
                this._activeLevelIndex = n.activeLevelIndex ? n.activeLevelIndex : 0,
                this._levels = this._mapScales(n.levels || Nr),
                this._handler = n.handler || this._defaultHandler,
                this._minColumnWidth = n.minColumnWidth || 60,
                this._maxColumnWidth = n.maxColumnWidth || 240,
                this._widthStep = n.widthStep || 3 / 8 * n.minColumnWidth,
                this._useKey = n.useKey,
            this._initialized || (ct(this),
                this.$gantt.attachEvent("onGanttScroll", () => {
                        this._getVisibleDate()
                    }
                )),
                this._domEvents.detachAll(),
            n.trigger === "wheel" && (this.$gantt.$root ? this._attachWheelEvent(n) : this.$gantt.attachEvent("onGanttLayoutReady", () => {
                    this.$gantt.attachEvent("onGanttRender", () => {
                            this._attachWheelEvent(n)
                        }
                        , {
                            once: !0
                        })
                }
            )),
                this._initialized = !0,
                this.setLevel(this._activeLevelIndex))
        }
        _mapScales(n) {
            return n.map(e => Array.isArray(e) ? {
                scales: e
            } : e)
        }
        _setScaleSettings(n, e) {
            n ? this._stepUp(e) : this._stepDown(e)
        }
        _stepUp(n) {
            if (this._activeLevelIndex >= this._levels.length - 1)
                return;
            let e = this._activeLevelIndex;
            if (this._setScaleDates(),
                this._widthStep) {
                let i = this.$gantt.config.min_column_width + this._widthStep;
                i > this._maxColumnWidth && (i = this._minColumnWidth,
                    e++),
                    this.$gantt.config.min_column_width = i
            } else
                e++;
            this._setLevel(e, n)
        }
        _stepDown(n) {
            if (this._activeLevelIndex < 1)
                return;
            let e = this._activeLevelIndex;
            if (this._setScaleDates(),
                this._widthStep) {
                let i = this.$gantt.config.min_column_width - this._widthStep;
                i < this._minColumnWidth && (i = this._maxColumnWidth,
                    e--),
                    this.$gantt.config.min_column_width = i
            } else
                e--;
            this._setLevel(e, n)
        }
    }
    function Rr(t) {
        function n() {
            if (t.config.touch != "force" && (t.config.touch = t.config.touch && (navigator.userAgent.indexOf("Mobile") != -1 || navigator.userAgent.indexOf("iPad") != -1 || navigator.userAgent.indexOf("Android") != -1 || navigator.userAgent.indexOf("Touch") != -1) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1),
                t.config.touch) {
                var r = !0;
                try {
                    document.createEvent("TouchEvent")
                } catch {
                    r = !1
                }
                r ? t._touch_events(["touchmove", "touchstart", "touchend"], function(s) {
                    return s.touches && s.touches.length > 1 ? null : s.touches[0] ? {
                        target: s.target,
                        pageX: s.touches[0].pageX,
                        pageY: s.touches[0].pageY,
                        clientX: s.touches[0].clientX,
                        clientY: s.touches[0].clientY
                    } : s
                }, function(s) {
                    return s.defaultPrevented
                }) : window.navigator.pointerEnabled ? t._touch_events(["pointermove", "pointerdown", "pointerup"], function(s) {
                    return s.pointerType == "mouse" ? null : s
                }, function(s) {
                    return !s || s.pointerType == "mouse"
                }) : window.navigator.msPointerEnabled && t._touch_events(["MSPointerMove", "MSPointerDown", "MSPointerUp"], function(s) {
                    return s.pointerType == s.MSPOINTER_TYPE_MOUSE ? null : s
                }, function(s) {
                    return !s || s.pointerType == s.MSPOINTER_TYPE_MOUSE
                })
            }
        }
        function e(r) {
            var s = r.$config.scrollX ? t.$ui.getView(r.$config.scrollX) : null
                , o = r.$config.scrollY ? t.$ui.getView(r.$config.scrollY) : null
                , l = {
                x: null,
                y: null
            };
            return s && s.getScrollState().visible && (l.x = s.$view.scrollLeft),
            o && o.getScrollState().visible && (l.y = o.$view.scrollTop),
                l
        }
        function i() {
            var r;
            return t.$ui.getView("timeline") && (r = t.$ui.getView("timeline")._tasks_dnd),
                r
        }
        t.config.touch_drag = 75,
            t.config.touch = !0,
            t.config.touch_feedback = !0,
            t.config.touch_feedback_duration = 1,
            t._prevent_touch_scroll = !1,
            t._touch_feedback = function() {
                t.config.touch_feedback && navigator.vibrate && navigator.vibrate(t.config.touch_feedback_duration)
            }
            ,
            t.attachEvent("onGanttReady", function() {
                t.$container && n()
            }),
            t.attachEvent("onGanttLayoutReady", function() {
                t.$container && t.attachEvent("onGanttRender", n, {
                    once: !0
                })
            });
        var a = [];
        t._touch_events = function(r, s, o) {
            var l, d = 0, c = !1, u = !1, h = null, _ = null, f = null, y = [], v = null;
            let b = {};
            for (var g = 0; g < a.length; g++)
                t.eventRemove(a[g][0], a[g][1], a[g][2]);
            (a = []).push([t.$container, r[0], function(p) {
                var k = i();
                if (!o(p) && c) {
                    _ && clearTimeout(_);
                    var w = s(p);
                    if (k && (k.drag.id || k.drag.start_drag))
                        return k.on_mouse_move(w),
                        p.preventDefault && p.preventDefault(),
                            p.cancelBubble = !0,
                            !1;
                    if (!t._prevent_touch_scroll) {
                        if (w && h) {
                            var x = h.pageX - w.pageX
                                , $ = h.pageY - w.pageY;
                            if (!u && (Math.abs(x) > 5 || Math.abs($) > 5) && (u = !0,
                                d = 0,
                                l = v ? e(v) : t.getScrollState()),
                                u) {
                                var S, T = l.x + x, E = l.y + $;
                                if (v ? (function(C, D, A) {
                                    var I = C.$config.scrollX ? t.$ui.getView(C.$config.scrollX) : null
                                        , M = C.$config.scrollY ? t.$ui.getView(C.$config.scrollY) : null;
                                    I && I.scrollTo(D, null),
                                    M && M.scrollTo(null, A)
                                }(v, T, E),
                                    S = e(v)) : (t.scrollTo(T, E),
                                    S = t.getScrollState()),
                                l.x != S.x && $ > 2 * x || l.y != S.y && x > 2 * $)
                                    return m(p)
                            }
                        }
                        return m(p)
                    }
                    return !0
                }
            }
            ]);
            try {
                document.addEventListener("touchmove", function(p) {
                    t._touch_drag && m(p)
                }, {
                    passive: !1
                })
            } catch {
                console.warn("Cannot prevent touch event for the page drag")
            }
            for (a.push([this.$container, "contextmenu", function(p) {
                if (c)
                    return m(p)
            }
            ]),
                     a.push([this.$container, r[1], function(p) {
                         if (b = p.touches.length,
                         document && document.body && document.body.classList.add("gantt_touch_active"),
                             !o(p))
                             if (p.touches && p.touches.length > 1)
                                 c = !1;
                             else {
                                 h = s(p),
                                     v = function(w) {
                                         for (var x = t.$layout.getCellsByType("viewCell"), $ = 0; $ < x.length; $++) {
                                             var S = x[$].$view.getBoundingClientRect();
                                             if (w.clientX >= S.left && w.clientX <= S.right && w.clientY <= S.bottom && w.clientY >= S.top)
                                                 return x[$]
                                         }
                                     }(h),
                                 t._locate_css(h, "gantt_hor_scroll") || t._locate_css(h, "gantt_ver_scroll") || (c = !0);
                                 var k = i();
                                 _ = setTimeout(function() {
                                     var w = t.locate(h);
                                     k && w && !t._locate_css(h, "gantt_link_control") && !t._locate_css(h, "gantt_grid_data") && (k.on_mouse_down(h),
                                     k.drag && k.drag.start_drag && (function(x) {
                                         const $ = t._getTaskLayers();
                                         let S = t.getTask(x);
                                         if (S) {
                                             let T = t.isTaskVisible(x);
                                             if (T) {
                                                 f = x;
                                                 for (let E = 0; E < $.length; E++)
                                                     if (S = $[E].rendered[x],
                                                     S && S.getAttribute(t.config.task_attribute) && S.getAttribute(t.config.task_attribute) == x) {
                                                         const C = S.cloneNode(!0);
                                                         y.push(S),
                                                             $[E].rendered[x] = C,
                                                             S.style.display = "none",
                                                             C.className += " gantt_drag_move ",
                                                             S.parentNode.appendChild(C)
                                                     }
                                             } else if (S.$split_subtask) {
                                                 let E = S.$rendered_parent;
                                                 if (T = t.isTaskVisible(E),
                                                     !T)
                                                     return;
                                                 f = x;
                                                 for (let C = 0; C < $.length; C++) {
                                                     const D = $[C].rendered[E];
                                                     let A;
                                                     if (D && D.childNodes && (A = D.querySelector(`[${t.config.task_attribute}="${S.id}"]`)),
                                                         A) {
                                                         const I = A.cloneNode(!0);
                                                         A.parentNode.appendChild(I),
                                                             t.$task_bars.appendChild(A),
                                                             A.style.display = "none",
                                                             y.push(A),
                                                             A = null
                                                     }
                                                 }
                                             }
                                         }
                                     }(w),
                                         k._start_dnd(h),
                                         t._touch_drag = !0,
                                         t.refreshTask(w),
                                         t._touch_feedback())),
                                         _ = null
                                 }, t.config.touch_drag)
                             }
                     }
                     ]),
                     a.push([this.$container, r[2], function(p) {
                         if (document && document.body && document.body.classList.remove("gantt_touch_active"),
                             !o(p)) {
                             _ && clearTimeout(_),
                                 t._touch_drag = !1,
                                 c = !1;
                             var k = s(p)
                                 , w = i();
                             if (w && w.on_mouse_up(k),
                             f && t.isTaskExists(f) && (t.refreshTask(f),
                             y.length && (y.forEach(function($) {
                                 $.parentNode && $.parentNode.removeChild($)
                             }),
                                 t._touch_feedback())),
                                 c = u = !1,
                                 y = [],
                                 f = null,
                             h && d) {
                                 var x = new Date;
                                 x - d < 500 && b <= 1 ? (t.$services.getService("mouseEvents").onDoubleClick(h),
                                     m(p)) : d = x
                             } else
                                 d = new Date
                         }
                     }
                     ]),
                     g = 0; g < a.length; g++)
                t.event(a[g][0], a[g][1], a[g][2]);
            function m(p) {
                return p && p.preventDefault && p.cancelable && p.preventDefault(),
                    p.cancelBubble = !0,
                    !1
            }
        }
    }
    function re() {
        console.log("Method is not implemented.")
    }
    function Gt() {}
    function pt(t) {
        return Gt
    }
    Gt.prototype.render = re,
        Gt.prototype.set_value = re,
        Gt.prototype.get_value = re,
        Gt.prototype.focus = re;
    var se = {
        getHtmlSelect: function(t, n, e) {
            var i = ""
                , a = this;
            return st(t = t || [], function(r) {
                var s = [{
                    key: "value",
                    value: r.key
                }];
                e == r.key && (s[s.length] = {
                    key: "selected",
                    value: "selected"
                }),
                r.attributes && (s = s.concat(r.attributes)),
                    i += a.getHtmlOption({
                        innerHTML: r.label
                    }, s)
            }),
                qt("select", {
                    innerHTML: i
                }, n)
        },
        getHtmlOption: function(t, n) {
            return qt("option", t, n)
        },
        getHtmlButton: function(t, n) {
            return qt("button", t, n)
        },
        getHtmlDiv: function(t, n) {
            return qt("div", t, n)
        },
        getHtmlLabel: function(t, n) {
            return qt("label", t, n)
        },
        getHtmlInput: function(t) {
            return "<input" + ii(t || []) + ">"
        }
    };
    function qt(t, n, e) {
        return n = n || [],
        "<" + t + ii(e || []) + ">" + (n.innerHTML || "") + "</" + t + ">"
    }
    function ii(t) {
        var n = "";
        return st(t, function(e) {
            n += " " + e.key + "='" + e.value + "'"
        }),
            n
    }
    function Ze(t) {
        const n = pt();
        function e() {
            return n.apply(this, arguments) || this
        }
        return W(e, n),
            e.prototype.render = function(i) {
                const a = i.height ? `height:${i.height}px;` : "";
                let r = `<div class='gantt_cal_ltext gantt_section_${i.name}' ${a ? `style='${a}'` : ""}>`;
                return r += se.getHtmlSelect(i.options, [{
                    key: "style",
                    value: "width:100%;"
                }, {
                    key: "title",
                    value: i.name
                }]),
                    r += "</div>",
                    r
            }
            ,
            e.prototype.set_value = function(i, a, r, s) {
                var o = i.firstChild;
                !o._dhx_onchange && s.onchange && (o.onchange = s.onchange,
                    o._dhx_onchange = !0),
                a === void 0 && (a = (o.options[0] || {}).value),
                    o.value = a || ""
            }
            ,
            e.prototype.get_value = function(i) {
                return i.firstChild.value
            }
            ,
            e.prototype.focus = function(i) {
                var a = i.firstChild;
                t._focus(a, !0)
            }
            ,
            e
    }
    const _e = class _e {
            constructor() {
                this.canParse = n => !isNaN(this.parse(n)),
                    this.format = n => String(n),
                    this.parse = n => parseInt(n, 10)
            }
        }
    ;
    _e.create = (n=null) => new _e;
    let oe = _e;
    function Hr(t) {
        var n = Ze(t);
        function e() {
            return n.apply(this, arguments) || this
        }
        function i(a, r) {
            var s = []
                , o = [];
            r && (s = t.getTaskByTime(),
            a.allow_root && s.unshift({
                id: t.config.root_id,
                text: a.root_label || ""
            }),
                s = function(u, h, _) {
                    var f = h.filter || function() {
                            return !0
                        }
                    ;
                    u = u.slice(0);
                    for (var y = 0; y < u.length; y++) {
                        var v = u[y];
                        (v.id == _ || t.isChildOf(v.id, _) || f(v.id, v) === !1) && (u.splice(y, 1),
                            y--)
                    }
                    return u
                }(s, a, r),
            a.sort && s.sort(a.sort));
            for (var l = a.template || t.templates.task_text, d = 0; d < s.length; d++) {
                var c = l.apply(t, [s[d].start_date, s[d].end_date, s[d]]);
                c === void 0 && (c = ""),
                    o.push({
                        key: s[d].id,
                        label: c
                    })
            }
            return a.options = o,
                a.map_to = a.map_to || "parent",
                t.form_blocks.select.render.apply(this, arguments)
        }
        return W(e, n),
            e.prototype.render = function(a) {
                return i(a, !1)
            }
            ,
            e.prototype.set_value = function(a, r, s, o) {
                r === 0 && (r = "0"),
                !s.id && t.getState().lightbox && (s.id = t.getLightboxValues().id);
                var l = document.createElement("div");
                l.innerHTML = i(o, s.id);
                var d = l.removeChild(l.firstChild);
                return a.onselect = null,
                    a.parentNode.replaceChild(d, a),
                    t.form_blocks.select.set_value.apply(t, [d, r, s, o])
            }
            ,
            e
    }
    function Or(t) {
        const n = pt();
        var e = {
            resources: {},
            resourcesValues: {},
            filter: {},
            eventsInitialized: {}
        };
        function i() {
            return n.apply(this, arguments) || this
        }
        function a(l, d, c, u) {
            var h, _ = "";
            if (l)
                return h = [{
                    key: "data-item-id",
                    value: l.key
                }, {
                    key: "data-assignment-id",
                    value: u || ""
                }, {
                    key: "class",
                    value: "gantt_resource_amount_input"
                }],
                c && h.push({
                    key: "disabled",
                    value: "disabled"
                }),
                    l.options ? _ += se.getHtmlSelect(l.options, h, d) : (h[h.length] = {
                        key: "value",
                        value: d || ""
                    },
                        _ += se.getHtmlInput(h)),
                    _
        }
        function r(l) {
            return l === void 0 ? ".gantt_resource_amount_input" : "[data-checked='" + (l ? "true" : "false") + "'] .gantt_resource_amount_input"
        }
        function s(l) {
            return e.resources[l.id]
        }
        function o(l) {
            return e.filter[l.id]
        }
        return t.attachEvent("onAfterLightbox", function() {
            for (var l in e.filter)
                e.filter[l].checkbox.checked = !1,
                    e.filter[l].input.value = "",
                    e.filter[l].filterApplied = !1;
            e.resourcesValues = {}
        }),
            W(i, n),
            i.prototype.render = function(l) {
                var d;
                l.options || (l.options = t.serverList("resourceOptions")),
                l.map_to && l.map_to != "auto" || (l.map_to = t.config.resource_property);
                var c = t.locale.labels.resources_filter_placeholder || l.filter_placeholder || "type to filter"
                    , u = t.locale.labels.resources_filter_label || "hide empty";
                return d = "<div" + (isNaN(l.height) ? "" : " style='height: " + l.height + "px;'") + " class='gantt_section_" + l.name + "'>",
                    d += "<div class='gantt_cal_ltext gantt_resources_filter'><input type='text' class='gantt_resources_filter_input' placeholder='" + c + "'> <label><input class='switch_unsetted' type='checkbox'><span class='matherial_checkbox_icon'></span>" + u + "</label></div>",
                    d += "<div class='gantt_cal_ltext gantt_resources' data-name='" + l.name + "'></div>",
                    d += "</div>"
            }
            ,
            i.prototype.set_value = function(l, d, c, u) {
                var h, _ = function(y, v) {
                    return e.resources[v.id] || (e.resources[v.id] = y.querySelector(".gantt_resources")),
                        e.resources[v.id]
                }(l, u), f = "";
                (function(y, v) {
                        if (!e.filter[v.id]) {
                            var b = y.querySelector(".gantt_resources_filter")
                                , g = b.querySelector(".gantt_resources_filter_input")
                                , m = b.querySelector(".switch_unsetted");
                            e.filter[v.id] = {
                                container: b,
                                input: g,
                                checkbox: m,
                                filterApplied: !1
                            }
                        }
                        e.filter[v.id]
                    }
                )(l, u),
                    function(y, v, b, g) {
                        if (e.eventsInitialized[b.id])
                            return;
                        var m = function(S) {
                            var T, E, C, D, A;
                            k(b, y);
                            var I = o(b);
                            A = I.checkbox,
                                D = I.input,
                                C = A.checked,
                                E = D.value.trim(),
                                I.filterApplied = !!E,
                            t.getState().lightbox && (v = t.getLightboxValues()),
                                T = function(L, N, P, R) {
                                    var B, H;
                                    if (R) {
                                        var F = N[L.map_to] || [];
                                        if (Lt(F) || (F = [F]),
                                        (F = F.slice()).length === 0) {
                                            for (var G in F = [],
                                                (H = t.copy(L)).options = [],
                                                e.resourcesValues[L.id])
                                                (j = e.resourcesValues[L.id][G]).value !== "" && F.push({
                                                    resource_id: G,
                                                    value: j.value,
                                                    id: j.id
                                                });
                                            if (F.length === 0)
                                                return H
                                        } else
                                            for (var G in e.resourcesValues[L.id]) {
                                                var j;
                                                (j = e.resourcesValues[L.id][G]).value !== "" && (fe(F, function(At) {
                                                    return At.id == G
                                                }) || F.push({
                                                    resource_id: G,
                                                    value: j.value,
                                                    id: j.id
                                                }))
                                            }
                                        for (var _t = {}, yt = 0; yt < F.length; yt++)
                                            _t[F[yt].resource_id] = !0;
                                        B = function(q) {
                                            if (_t[String(q.key)] && (P === "" || q.label.toLowerCase().indexOf(P.toLowerCase()) >= 0))
                                                return q
                                        }
                                    } else {
                                        if (P === "")
                                            return L;
                                        B = function(q) {
                                            if (q.label.toLowerCase().indexOf(P.toLowerCase()) >= 0)
                                                return q
                                        }
                                    }
                                    return (H = t.copy(L)).options = function(q, At) {
                                        var Yt = [];
                                        if (q.filter)
                                            return q.filter(At);
                                        for (var Mt = 0; Mt < q.length; Mt++)
                                            At(q[Mt], Mt) && (Yt[Yt.length] = q[Mt]);
                                        return Yt
                                    }(H.options, B),
                                        H
                                }(b, v, E, C);
                            var M = v[b.map_to];
                            g.form_blocks.resources.set_value(y, M, v, T)
                        };
                        function p(S) {
                            var T, E = S.target;
                            if (S.target.type === "checkbox") {
                                (T = E.parentNode.querySelector(r())).disabled = !E.checked;
                                var C = T.getAttribute("data-item-id")
                                    , D = mt(S, "gantt_resource_row")
                                    , A = D.querySelector(".gantt_resource_amount_input");
                                if (D.setAttribute("data-checked", E.checked),
                                    E.checked) {
                                    T.nodeName.toLowerCase() === "select" && t.callEvent("onResourcesSelectActivated", [{
                                        target: T
                                    }]);
                                    var I = C
                                        , M = b.default_value;
                                    b.options.forEach(function(L) {
                                        L.key == I && L.default_value && (M = L.default_value)
                                    }),
                                    A && !A.value && M !== void 0 && (A.value = M,
                                        k(b, this)),
                                        A.select ? A.select() : A.focus && A.focus()
                                } else
                                    e.resourcesValues[b.id] && delete e.resourcesValues[b.id][C]
                            } else
                                S.target.type !== "text" && S.target.nodeName.toLowerCase() !== "select" || (E.parentNode.parentNode,
                                    T = S.target,
                                    k(b, this))
                        }
                        function k(S, T) {
                            var E = r()
                                , C = T.querySelectorAll(E);
                            e.resourcesValues[S.id] = e.resourcesValues[S.id] || {};
                            for (var D = 0; D < C.length; D++) {
                                var A = C[D].getAttribute("data-item-id")
                                    , I = C[D].getAttribute("data-assignment-id");
                                C[D].disabled ? delete e.resourcesValues[S.id][A] : e.resourcesValues[S.id][A] = {
                                    value: C[D].value,
                                    id: I
                                }
                            }
                        }
                        w = m,
                            x = 100,
                            $ = !1,
                            m = function() {
                                $ || (w.apply(null, arguments),
                                    $ = !0,
                                    setTimeout(function() {
                                        $ = !1
                                    }, x))
                            }
                            ,
                            o(b).container.addEventListener("keyup", m),
                            o(b).container.addEventListener("input", m, !0),
                            o(b).container.addEventListener("change", m, !0),
                            s(b).addEventListener("input", p),
                            s(b).addEventListener("change", p),
                            t.attachEvent("onResourcesSelectActivated", t.bind(p, s(b))),
                            e.eventsInitialized[b.id] = !0;
                        var w, x, $
                    }(l, c, u, this),
                    st(u.options, function(y, v) {
                        u.unassigned_value != y.key && (h = function(b, g, m) {
                            var p = {};
                            if (g) {
                                var k;
                                Lt(g) ? k = fe(g, function(w) {
                                    return w.resource_id == m.key
                                }) : g.resource_id == m.key && (k = g),
                                k && (p.value = k.value,
                                    p.id = k.id)
                            }
                            return e.resourcesValues[b.id] && e.resourcesValues[b.id][m.key] && (p.value = e.resourcesValues[b.id][m.key].value,
                                p.id = e.resourcesValues[b.id][m.key].id),
                                p
                        }(u, d, y),
                            f += ["<label class='gantt_resource_row' data-item-id='" + y.key + "' data-checked=" + (h.value ? "true" : "false") + ">", "<input class='gantt_resource_toggle' type='checkbox'", h.value ? " checked='checked'" : "", "><div class='gantt_resource_cell gantt_resource_cell_checkbox'><span class='matherial_checkbox_icon'></span></div>", "<div class='gantt_resource_cell gantt_resource_cell_label'>", y.label, "</div>", "<div class='gantt_resource_cell gantt_resource_cell_value'>", a(y, h.value, !h.value, h.id), "</div>", "<div class='gantt_resource_cell gantt_resource_cell_unit'>", y.unit, "</div>", "</label>"].join(""))
                    }),
                    _.innerHTML = f,
                    _.style.zoom = "1",
                    _._offsetSizes = _.offsetHeight,
                    _.style.zoom = "",
                    t._center_lightbox(t.getLightbox())
            }
            ,
            i.prototype.get_value = function(l, d, c) {
                for (var u = s(c), h = [], _ = r(!0), f = r(!1), y = o(c), v = t.copy(e.resourcesValues[c.id]) || {}, b = u.querySelectorAll(_), g = u.querySelectorAll(f), m = 0; m < g.length; m++)
                    delete v[g[m].getAttribute("data-item-id")];
                for (m = 0; m < b.length; m++) {
                    var p = b[m].getAttribute("data-assignment-id")
                        , k = b[m].getAttribute("data-item-id")
                        , w = b[m].value.trim();
                    w !== "" && w !== "0" && (delete v[k],
                        h[h.length] = {
                            resource_id: k,
                            value: w
                        },
                    p && (h[h.length - 1] = {
                        ...h[h.length - 1],
                        id: p
                    }))
                }
                if (y.filterApplied)
                    for (var x in v)
                        h[h.length] = {
                            resource_id: x,
                            value: v[x].value,
                            id: v[x].id
                        };
                return h
            }
            ,
            i.prototype.focus = function(l) {
                t._focus(l.querySelector(".gantt_resources"))
            }
            ,
            i
    }
    function Br(t) {
        var n = function() {
            const g = pt();
            function m() {
                return g.apply(this, arguments) || this
            }
            return W(m, g),
                m.prototype.render = function(p) {
                    let k = p.height ? `${p.height}px` : "";
                    return `<div class='gantt_cal_ltext gantt_cal_template gantt_section_${p.name}' ${k ? `style='height:${k};'` : ""}></div>`
                }
                ,
                m.prototype.set_value = function(p, k) {
                    p.innerHTML = k || ""
                }
                ,
                m.prototype.get_value = function(p) {
                    return p.innerHTML || ""
                }
                ,
                m.prototype.focus = function() {}
                ,
                m
        }()
            , e = function(g) {
            const m = pt();
            function p() {
                return m.apply(this, arguments) || this
            }
            return W(p, m),
                p.prototype.render = function(k) {
                    const w = (k.height || "130") + "px"
                        , x = k.placeholder ? `placeholder='${k.placeholder}'` : "";
                    return `<div class='gantt_cal_ltext gantt_section_${k.name}' style='height:${w};' ${x}><textarea></textarea></div>`
                }
                ,
                p.prototype.set_value = function(k, w) {
                    g.form_blocks.textarea._get_input(k).value = w || ""
                }
                ,
                p.prototype.get_value = function(k) {
                    return g.form_blocks.textarea._get_input(k).value
                }
                ,
                p.prototype.focus = function(k) {
                    var w = g.form_blocks.textarea._get_input(k);
                    g._focus(w, !0)
                }
                ,
                p.prototype._get_input = function(k) {
                    return k.querySelector("textarea")
                }
                ,
                p
        }(t)
            , i = function(g) {
            const m = pt();
            function p() {
                return m.apply(this, arguments) || this
            }
            return W(p, m),
                p.prototype.render = function(k) {
                    var w = g.form_blocks.getTimePicker.call(this, k);
                    let x = "gantt_section_time";
                    k.name !== "time" && (x += " gantt_section_" + k.name);
                    var $ = "<div style='padding-top:0px;font-size:inherit;text-align:center;' class='" + x + "'>";
                    return $ += w,
                        k.single_date ? (w = g.form_blocks.getTimePicker.call(this, k, !0),
                            $ += "<span></span>") : $ += "<span class='gantt_section_time_spacer'> &nbsp;&ndash;&nbsp; </span>",
                    ($ += w) + "</div>"
                }
                ,
                p.prototype.set_value = function(k, w, x, $) {
                    var S = $
                        , T = k.getElementsByTagName("select")
                        , E = $._time_format_order;
                    if (S.auto_end_date)
                        for (var C = function() {
                            I = new Date(T[E[2]].value,T[E[1]].value,T[E[0]].value,0,0),
                                M = g.calculateEndDate({
                                    start_date: I,
                                    duration: 1,
                                    task: x
                                }),
                                g.form_blocks._fill_lightbox_select(T, E.size, M, E, S)
                        }, D = 0; D < 4; D++)
                            T[D].onchange = C;
                    var A = g._resolve_default_mapping($);
                    typeof A == "string" && (A = {
                        start_date: A
                    });
                    var I = x[A.start_date] || new Date
                        , M = x[A.end_date] || g.calculateEndDate({
                        start_date: I,
                        duration: 1,
                        task: x
                    });
                    g.form_blocks._fill_lightbox_select(T, 0, I, E, S),
                        g.form_blocks._fill_lightbox_select(T, E.size, M, E, S)
                }
                ,
                p.prototype.get_value = function(k, w, x) {
                    var $, S = k.getElementsByTagName("select"), T = x._time_format_order;
                    return $ = g.form_blocks.getTimePickerValue(S, x),
                        typeof g._resolve_default_mapping(x) == "string" ? $ : {
                            start_date: $,
                            end_date: function(E, C, D) {
                                var A = g.form_blocks.getTimePickerValue(E, x, C.size);
                                return A <= D && (x.autofix_end !== !1 || x.single_date) ? g.date.add(D, g._get_timepicker_step(), "minute") : A
                            }(S, T, $)
                        }
                }
                ,
                p.prototype.focus = function(k) {
                    g._focus(k.getElementsByTagName("select")[0])
                }
                ,
                p
        }(t)
            , a = Ze(t)
            , r = function(g) {
            var m = pt();
            function p() {
                return m.apply(this, arguments) || this
            }
            return W(p, m),
                p.prototype.render = function(k) {
                    const w = k.height ? `height:${k.height}px;` : "";
                    let x = `<div class='gantt_cal_ltext gantt_cal_lcheckbox gantt_section_${k.name}' ${w ? `style='${w}'` : ""}>`;
                    if (k.options && k.options.length)
                        for (var $ = 0; $ < k.options.length; $++)
                            x += "<label><input type='checkbox' value='" + k.options[$].key + "' name='" + k.name + "'>" + k.options[$].label + "</label>";
                    else
                        k.single_value = !0,
                            x += "<label><input type='checkbox' name='" + k.name + "'></label>";
                    return x += "</div>",
                        x
                }
                ,
                p.prototype.set_value = function(k, w, x, $) {
                    var S = Array.prototype.slice.call(k.querySelectorAll("input[type=checkbox]"));
                    !k._dhx_onchange && $.onchange && (k.onchange = $.onchange,
                        k._dhx_onchange = !0),
                        $.single_value ? S[0].checked = !!w : st(S, function(T) {
                            T.checked = !!w && w.indexOf(T.value) >= 0
                        })
                }
                ,
                p.prototype.get_value = function(k, w, x) {
                    return x.single_value ? k.querySelector("input[type=checkbox]").checked : function($, S) {
                        if ($.map)
                            return $.map(S);
                        for (var T = $.slice(), E = [], C = 0; C < T.length; C++)
                            E.push(S(T[C], C));
                        return E
                    }(Array.prototype.slice.call(k.querySelectorAll("input[type=checkbox]:checked")), function($) {
                        return $.value
                    })
                }
                ,
                p.prototype.focus = function(k) {
                    g._focus(k.querySelector("input[type=checkbox]"))
                }
                ,
                p
        }(t)
            , s = function(g) {
            const m = pt();
            function p() {
                return m.apply(this, arguments) || this
            }
            return W(p, m),
                p.prototype.render = function(k) {
                    const w = k.height ? `${k.height}px` : "";
                    let x = `<div class='gantt_cal_ltext gantt_cal_lradio gantt_section_${k.name}' ${w ? `style='height:${w};'` : ""}>`;
                    if (k.options && k.options.length)
                        for (var $ = 0; $ < k.options.length; $++)
                            x += "<label><input type='radio' value='" + k.options[$].key + "' name='" + k.name + "'>" + k.options[$].label + "</label>";
                    return x += "</div>",
                        x
                }
                ,
                p.prototype.set_value = function(k, w, x, $) {
                    var S;
                    $.options && $.options.length && (S = k.querySelector("input[type=radio][value='" + w + "']") || k.querySelector("input[type=radio][value='" + $.default_value + "']")) && (!k._dhx_onchange && $.onchange && (k.onchange = $.onchange,
                        k._dhx_onchange = !0),
                        S.checked = !0)
                }
                ,
                p.prototype.get_value = function(k, w) {
                    var x = k.querySelector("input[type=radio]:checked");
                    return x ? x.value : ""
                }
                ,
                p.prototype.focus = function(k) {
                    g._focus(k.querySelector("input[type=radio]"))
                }
                ,
                p
        }(t)
            , o = function(g) {
            var m = pt();
            function p() {
                return m.apply(this, arguments) || this
            }
            function k($) {
                return $.formatter || new oe
            }
            function w($, S) {
                var T = $.getElementsByTagName("select")
                    , E = S._time_format_order
                    , C = 0
                    , D = 0;
                if (g.defined(E[3])) {
                    var A = T[E[3]]
                        , I = parseInt(A.value, 10);
                    isNaN(I) && A.hasAttribute("data-value") && (I = parseInt(A.getAttribute("data-value"), 10)),
                        C = Math.floor(I / 60),
                        D = I % 60
                }
                return new Date(T[E[2]].value,T[E[1]].value,T[E[0]].value,C,D)
            }
            function x($, S) {
                var T = $.getElementsByTagName("input")[1];
                return (T = k(S).parse(T.value)) && !window.isNaN(T) || (T = 1),
                T < 0 && (T *= -1),
                    T
            }
            return W(p, m),
                p.prototype.render = function($) {
                    var S = "<div class='gantt_time_selects'>" + g.form_blocks.getTimePicker.call(this, $) + "</div>"
                        , T = " " + g.locale.labels[g.config.duration_unit + "s"] + " "
                        , E = $.single_date ? " style='display:none'" : ""
                        , C = $.readonly ? " disabled='disabled'" : ""
                        , D = g._waiAria.lightboxDurationInputAttrString($)
                        , A = "gantt_duration_value";
                    $.formatter && (T = "",
                        A += " gantt_duration_value_formatted");
                    var I = "<div class='gantt_duration' " + E + "><div class='gantt_duration_inputs'><input type='button' class='gantt_duration_dec' value='−'" + C + "><input type='text' value='5days' class='" + A + "'" + C + " " + D + "><input type='button' class='gantt_duration_inc' value='+'" + C + "></div><div class='gantt_duration_end_date'>" + T + "<span></span></div></div></div>";
                    let M = "gantt_section_time gantt_section_duration";
                    return $.name !== "time" && (M += " gantt_section_" + $.name),
                    "<div style='padding-top:0px;font-size:inherit;' class='" + M + "'>" + S + " " + I + "</div>"
                }
                ,
                p.prototype.set_value = function($, S, T, E) {
                    var C, D, A, I, M = $.getElementsByTagName("select"), L = $.getElementsByTagName("input"), N = L[1], P = [L[0], L[2]], R = $.getElementsByTagName("span")[0], B = E._time_format_order;
                    function H() {
                        var G = w.call(g, $, E)
                            , j = x.call(g, $, E)
                            , _t = g.calculateEndDate({
                            start_date: G,
                            duration: j,
                            task: T
                        })
                            , yt = g.templates.task_end_date || g.templates.task_date;
                        R.innerHTML = yt(_t)
                    }
                    function F(G) {
                        var j = N.value;
                        j = k(E).parse(j),
                        window.isNaN(j) && (j = 0),
                        (j += G) < 1 && (j = 1),
                            N.value = k(E).format(j),
                            H()
                    }
                    P[0].onclick = g.bind(function() {
                        F(-1 * g.config.duration_step)
                    }, this),
                        P[1].onclick = g.bind(function() {
                            F(1 * g.config.duration_step)
                        }, this),
                        M[0].onchange = H,
                        M[1].onchange = H,
                        M[2].onchange = H,
                    M[3] && (M[3].onchange = H),
                        N.onkeydown = g.bind(function(G) {
                            var j;
                            return (j = (G = G || window.event).charCode || G.keyCode || G.which) == g.constants.KEY_CODES.DOWN ? (F(-1 * g.config.duration_step),
                                !1) : j == g.constants.KEY_CODES.UP ? (F(1 * g.config.duration_step),
                                !1) : void window.setTimeout(H, 1)
                        }, this),
                        N.onchange = g.bind(H, this),
                    typeof (C = g._resolve_default_mapping(E)) == "string" && (C = {
                        start_date: C
                    }),
                        D = T[C.start_date] || new Date,
                        A = T[C.end_date] || g.calculateEndDate({
                            start_date: D,
                            duration: 1,
                            task: T
                        }),
                        I = Math.round(T[C.duration]) || g.calculateDuration({
                            start_date: D,
                            end_date: A,
                            task: T
                        }),
                        I = k(E).format(I),
                        g.form_blocks._fill_lightbox_select(M, 0, D, B, E),
                        N.value = I,
                        H()
                }
                ,
                p.prototype.get_value = function($, S, T) {
                    var E = w($, T)
                        , C = x($, T)
                        , D = g.calculateEndDate({
                        start_date: E,
                        duration: C,
                        task: S
                    });
                    return typeof g._resolve_default_mapping(T) == "string" ? E : {
                        start_date: E,
                        end_date: D,
                        duration: C
                    }
                }
                ,
                p.prototype.focus = function($) {
                    g._focus($.getElementsByTagName("select")[0])
                }
                ,
                p
        }(t)
            , l = Hr(t)
            , d = Or(t)
            , c = function(g) {
            var m = pt();
            function p() {
                return m.apply(this, arguments) || this
            }
            function k(x) {
                return !x || x === g.config.constraint_types.ASAP || x === g.config.constraint_types.ALAP
            }
            function w(x, $) {
                for (var S = k($), T = 0; T < x.length; T++)
                    x[T].disabled = S
            }
            return W(p, m),
                p.prototype.render = function(x) {
                    const $ = x.height ? `height:${x.height}px;` : "";
                    let S = `<div class='gantt_cal_ltext gantt_section_${x.name}' ${$ ? `style='${$}'` : ""}>`;
                    var T = [];
                    for (var E in g.config.constraint_types)
                        T.push({
                            key: g.config.constraint_types[E],
                            label: g.locale.labels[g.config.constraint_types[E]]
                        });
                    return x.options = x.options || T,
                        S += "<span data-constraint-type-select>" + se.getHtmlSelect(x.options, [{
                            key: "data-type",
                            value: "constraint-type"
                        }]) + "</span>",
                        S += "<label data-constraint-time-select>" + (g.locale.labels.constraint_date || "Constraint date") + ": " + g.form_blocks.getTimePicker.call(this, x) + "</label>",
                        S += "</div>",
                        S
                }
                ,
                p.prototype.set_value = function(x, $, S, T) {
                    var E = x.querySelector("[data-constraint-type-select] select")
                        , C = x.querySelectorAll("[data-constraint-time-select] select")
                        , D = T._time_format_order
                        , A = g._resolve_default_mapping(T);
                    E._eventsInitialized || (E.addEventListener("change", function(L) {
                        w(C, L.target.value)
                    }),
                        E._eventsInitialized = !0);
                    var I = S[A.constraint_date] || new Date;
                    g.form_blocks._fill_lightbox_select(C, 0, I, D, T);
                    var M = S[A.constraint_type] || g.getConstraintType(S);
                    E.value = M,
                        w(C, M)
                }
                ,
                p.prototype.get_value = function(x, $, S) {
                    var T = x.querySelector("[data-constraint-type-select] select")
                        , E = x.querySelectorAll("[data-constraint-time-select] select")
                        , C = T.value
                        , D = null;
                    return k(C) || (D = g.form_blocks.getTimePickerValue(E, S)),
                        {
                            constraint_type: C,
                            constraint_date: D
                        }
                }
                ,
                p.prototype.focus = function(x) {
                    g._focus(x.querySelector("select"))
                }
                ,
                p
        }(t)
            , u = function(g) {
            const m = Ze(g);
            function p() {
                return m.apply(this, arguments) || this
            }
            return W(p, m),
                p.prototype.render = function(k) {
                    var w = g.config.types
                        , x = g.locale.labels
                        , $ = []
                        , S = k.filter || function(C, D) {
                            return !w.placeholder || D !== w.placeholder
                        }
                    ;
                    for (var T in w)
                        !S(T, w[T]) == 0 && $.push({
                            key: w[T],
                            label: x["type_" + T]
                        });
                    k.options = $;
                    var E = k.onchange;
                    return k.onchange = function() {
                        g._lightbox_current_type = this.value,
                            g.changeLightboxType(this.value),
                        typeof E == "function" && E.apply(this, arguments)
                    }
                        ,
                        m.prototype.render.apply(this, arguments)
                }
                ,
                p
        }(t)
            , h = function(g) {
            var m = pt();
            function p() {
                return m.apply(this, arguments) || this
            }
            function k(S) {
                return S.formatter || new oe
            }
            function w(S, T, E, C) {
                const D = "<div class='gantt_time_selects'>" + g.form_blocks.getTimePicker.call(g, C) + "</div>";
                let A = " " + g.locale.labels[g.config.duration_unit + "s"] + " ";
                const I = C.single_date ? " style='display:none'" : ""
                    , M = C.readonly ? " disabled='disabled'" : ""
                    , L = g._waiAria.lightboxDurationInputAttrString(C)
                    , N = g.locale.labels.baselines_remove_button;
                let P = "gantt_duration_value";
                C.formatter && (A = "",
                    P += " gantt_duration_value_formatted");
                const R = "<div class='gantt_duration' " + I + "><div class='gantt_duration_inputs'><input type='button' class='gantt_duration_dec' value='−'" + M + "><input type='text' value='5days' class='" + P + "'" + M + " " + L + "><input type='button' class='gantt_duration_inc' value='+'" + M + "></div><div class='gantt_duration_end_date'>" + A + "<span></span></div></div></div>"
                    , B = `<div><div class='baseline_delete_button gantt_custom_button'>${N}</div></div>`
                    , H = document.createElement("div");
                H.className = "gantt_section_time gantt_section_duration",
                    H.setAttribute("data-baseline-id", T.id),
                    H.innerHTML = D + R + B + "<br>",
                    S.appendChild(H);
                var F, G, j, _t = H.getElementsByTagName("select"), yt = H.getElementsByTagName("input"), q = yt[1], At = [yt[0], yt[2]], Yt = H.getElementsByTagName("span")[0], Mt = C._time_format_order;
                function wt() {
                    var bt = x.call(g, H, C)
                        , Z = $.call(g, H, C)
                        , Fr = g.calculateEndDate({
                        start_date: bt,
                        duration: Z,
                        task: E
                    })
                        , Wr = g.templates.task_end_date || g.templates.task_date;
                    Yt.innerHTML = Wr(Fr)
                }
                function ge(bt) {
                    var Z = q.value;
                    Z = k(C).parse(Z),
                    window.isNaN(Z) && (Z = 0),
                    (Z += bt) < 1 && (Z = 1),
                        q.value = k(C).format(Z),
                        wt()
                }
                H.querySelector(".baseline_delete_button").onclick = function(bt) {
                    const Z = H.parentNode;
                    H.innerHTML = "",
                        H.remove(),
                    Z.innerHTML === "" && (Z.innerHTML = g.locale.labels.baselines_section_placeholder)
                }
                    ,
                    At[0].onclick = g.bind(function() {
                        ge(-1 * g.config.duration_step)
                    }, g),
                    At[1].onclick = g.bind(function() {
                        ge(1 * g.config.duration_step)
                    }, g),
                    _t[0].onchange = wt,
                    _t[1].onchange = wt,
                    _t[2].onchange = wt,
                _t[3] && (_t[3].onchange = wt),
                    q.onkeydown = g.bind(function(bt) {
                        var Z;
                        return (Z = (bt = bt || window.event).charCode || bt.keyCode || bt.which) == g.constants.KEY_CODES.DOWN ? (ge(-1 * g.config.duration_step),
                            !1) : Z == g.constants.KEY_CODES.UP ? (ge(1 * g.config.duration_step),
                            !1) : void window.setTimeout(wt, 1)
                    }, g),
                    q.onchange = g.bind(wt, g),
                    g._resolve_default_mapping(C),
                    F = T.start_date || new Date,
                    G = T.end_date || g.calculateEndDate({
                        start_date: F,
                        duration: 1,
                        task: E
                    }),
                    j = g.calculateDuration({
                        start_date: F,
                        end_date: G,
                        task: E
                    }),
                    j = k(C).format(j),
                    g.form_blocks._fill_lightbox_select(_t, 0, F, Mt, C),
                    q.value = j,
                    wt()
            }
            function x(S, T) {
                var E = S.getElementsByTagName("select")
                    , C = T._time_format_order
                    , D = 0
                    , A = 0;
                if (g.defined(C[3])) {
                    var I = E[C[3]]
                        , M = parseInt(I.value, 10);
                    isNaN(M) && I.hasAttribute("data-value") && (M = parseInt(I.getAttribute("data-value"), 10)),
                        D = Math.floor(M / 60),
                        A = M % 60
                }
                return new Date(E[C[2]].value,E[C[1]].value,E[C[0]].value,D,A)
            }
            function $(S, T) {
                var E = S.getElementsByTagName("input")[1];
                return (E = k(T).parse(E.value)) && !window.isNaN(E) || (E = 1),
                E < 0 && (E *= -1),
                    E
            }
            return W(p, m),
                p.prototype.render = function(S) {
                    return `<div style='height: ${S.height || 100}px; padding-top:0px; font-size:inherit;' class='gantt_section_baselines'></div>`
                }
                ,
                p.prototype.set_value = function(S, T, E, C) {
                    E.baselines ? (S.innerHTML = "",
                        E.baselines.forEach(D => {
                                w(S, D, E, C)
                            }
                        )) : S.innerHTML = g.locale.labels.baselines_section_placeholder
                }
                ,
                p.prototype.get_value = function(S, T, E) {
                    const C = [];
                    return S.querySelectorAll("[data-baseline-id]").forEach(D => {
                            const A = D.dataset.baselineId;
                            let I, M = g.getDatastore("baselines").getItem(A);
                            I = M ? g.copy(M) : {
                                id: g.uid(),
                                task_id: T.id,
                                text: "Baseline 1"
                            },
                                I.start_date = x(D, E),
                                I.duration = $(D, E),
                                I.end_date = g.calculateEndDate({
                                    start_date: I.start_date,
                                    duration: I.duration,
                                    task: T
                                }),
                                C.push(I)
                        }
                    ),
                        C
                }
                ,
                p.prototype.button_click = function(S, T, E, C) {
                    if (g.callEvent("onSectionButton", [g._lightbox_id, E]) !== !1 && (T.closest(".gantt_custom_button.gantt_remove_baselines") && (C.innerHTML = g.locale.labels.baselines_section_placeholder),
                        T.closest(".gantt_custom_button.gantt_add_baselines"))) {
                        C.innerHTML == g.locale.labels.baselines_section_placeholder && (C.innerHTML = "");
                        const D = g.getTask(g._lightbox_id);
                        w(C, {
                            id: g.uid(),
                            task_id: D.id,
                            start_date: D.start_date,
                            end_date: D.end_date
                        }, D, g._get_typed_lightbox_config()[S])
                    }
                }
                ,
                p.prototype.focus = function(S) {
                    g._focus(S.getElementsByTagName("select")[0])
                }
                ,
                p
        }(t);
        t._lightbox_methods = {},
            t._lightbox_template = "<div class='gantt_cal_ltitle'><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='gantt_title'></span></div><div class='gantt_cal_larea'></div>",
            t._lightbox_template = `<div class='gantt_cal_ltitle'><div class="dhx_cal_ltitle_descr"><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='dhx_title'></span>
</div>
<div class="gantt_cal_ltitle_controls">
	<a class="gantt_cal_ltitle_close_btn dhx_gantt_icon dhx_gantt_icon_close"></a>

</div></div><div class='gantt_cal_larea'></div>`,
            t._lightbox_root = t.$root,
            t.$services.getService("state").registerProvider("lightbox", function() {
                return {
                    lightbox: t._lightbox_id
                }
            }),
            t.showLightbox = function(g) {
                var m = this.getTask(g);
                if (this.callEvent("onBeforeLightbox", [g])) {
                    var p = this.getLightbox(this.getTaskType(m.type));
                    this.showCover(p),
                        this._fill_lightbox(g, p),
                        this._setLbPosition(p),
                        this._waiAria.lightboxVisibleAttr(p),
                        this.callEvent("onLightbox", [g])
                } else
                    t.isTaskExists(g) && t.getTask(g).$new && this.$data.tasksStore._updateOrder()
            }
            ,
            t._get_timepicker_step = function() {
                if (this.config.round_dnd_dates) {
                    var g;
                    if (function(p) {
                        var k = p.$ui.getView("timeline");
                        return !(!k || !k.isVisible())
                    }(this)) {
                        var m = t.getScale();
                        g = Jt(m.unit) * m.step / 60
                    }
                    return (!g || g >= 1440) && (g = this.config.time_step),
                        g
                }
                return this.config.time_step
            }
            ,
            t.getLabel = function(g, m) {
                for (var p = this._get_typed_lightbox_config(), k = 0; k < p.length; k++)
                    if (p[k].map_to == g) {
                        for (var w = p[k].options, x = 0; x < w.length; x++)
                            if (w[x].key == m)
                                return w[x].label
                    }
                return ""
            }
            ,
            t.updateCollection = function(g, m) {
                m = m.slice(0);
                var p = t.serverList(g);
                if (!p)
                    return !1;
                p.splice(0, p.length),
                    p.push.apply(p, m || []),
                    t.resetLightbox()
            }
            ,
            t.getLightboxType = function() {
                return this.getTaskType(this._lightbox_type)
            }
            ,
            t.getLightbox = function(g) {
                var m, p, k, w, x, $ = "";
                if (t.config.csp === !0 || t.env.isSalesforce ? t._lightbox_root = t.$root : t._lightbox_root = document.body,
                g === void 0 && (g = this.getLightboxType()),
                !this._lightbox || this.getLightboxType() != this.getTaskType(g)) {
                    this._lightbox_type = this.getTaskType(g),
                        m = document.createElement("div"),
                        $ = "gantt_cal_light",
                        p = this._is_lightbox_timepicker(),
                    t.config.wide_form && ($ += " gantt_cal_light_wide"),
                    p && ($ += " gantt_cal_light_full"),
                        m.className = $,
                        m.style.visibility = "hidden",
                        k = this._lightbox_template,
                        k += "<div class='gantt_cal_lcontrols'>",
                        k += y(this.config.buttons_left),
                        k += "<div class='gantt_cal_lcontrols_push_right'></div>",
                        k += y(this.config.buttons_right),
                        k += "</div>",
                        m.innerHTML = k,
                        t._waiAria.lightboxAttr(m),
                    t.config.drag_lightbox && (m.firstChild.onmousedown = t._ready_to_dnd,
                        m.firstChild.ontouchstart = function(T) {
                            t._ready_to_dnd(T.touches[0])
                        }
                        ,
                        m.firstChild.onselectstart = function() {
                            return !1
                        }
                        ,
                        m.firstChild.style.cursor = "pointer",
                        t._init_dnd_events()),
                    this._lightbox && this.resetLightbox(),
                        _(),
                        this._cover.insertBefore(m, this._cover.firstChild),
                        this._lightbox = m,
                        w = this._get_typed_lightbox_config(g),
                        k = this._render_sections(w);
                    var S = (x = m.querySelector("div.gantt_cal_larea")).style.overflow;
                    x.style.overflow = "hidden",
                        x.innerHTML = k,
                        function(T) {
                            var E, C, D, A, I, M;
                            for (M = 0; M < T.length; M++)
                                E = T[M],
                                    D = t._lightbox_root.querySelector("#" + E.id),
                                E.id && D && (C = D.querySelector("label"),
                                (A = D.nextSibling) && (I = A.querySelector("input, select, textarea")) && (I.id = I.id || "input_" + t.uid(),
                                    E.inputId = I.id,
                                    C.setAttribute("for", E.inputId)))
                        }(w),
                        x.style.overflow = S,
                        this._init_lightbox_events(this),
                        m.style.display = "none",
                        m.style.visibility = "visible"
                }
                return this._lightbox
            }
            ,
            t._render_sections = function(g) {
                for (var m = "", p = 0; p < g.length; p++) {
                    var k = this.form_blocks[g[p].type];
                    if (k) {
                        g[p].id = "area_" + this.uid();
                        var w = g[p].hidden ? " style='display:none'" : ""
                            , x = "";
                        g[p].button && (x = "<div class='gantt_custom_button' data-index='" + p + "'><div class='gantt_custom_button_" + g[p].button + "'></div><div class='gantt_custom_button_label'>" + this.locale.labels["button_" + g[p].button] + "</div></div>"),
                        g[p].type == "baselines" && (x = "<div class='gantt_custom_button gantt_remove_baselines' data-index='" + p + "'><div class='gantt_custom_button_delete_baselines'></div><div class='gantt_custom_button_label'>" + this.locale.labels.baselines_remove_all_button + "</div></div><div class='gantt_custom_button gantt_add_baselines' data-index='" + p + "'><div class='gantt_custom_button_add_baseline'></div><div class='gantt_custom_button_label'>" + this.locale.labels.baselines_add_button + "</div></div>"),
                        this.config.wide_form && (m += "<div class='gantt_wrap_section' " + w + ">"),
                            m += "<div id='" + g[p].id + "' class='gantt_cal_lsection'><label>" + x + (g[p].label || this.locale.labels["section_" + g[p].name] || g[p].name) + "</label></div>" + k.render.call(this, g[p]),
                            m += "</div>"
                    }
                }
                return m
            }
            ,
            t._center_lightbox = function(g) {
                t._setLbPosition(g)
            }
            ,
            t._setLbPosition = function(g) {
                if (!g)
                    return;
                const m = t._lightbox_root || t.$root;
                g.style.top = Math.max(m.offsetHeight / 2 - g.offsetHeight / 2, 0) + "px",
                    g.style.left = Math.max(m.offsetWidth / 2 - g.offsetWidth / 2, 0) + "px"
            }
            ,
            t.showCover = function(g) {
                g && (g.style.display = "block",
                    this._setLbPosition(g)),
                    _(),
                    this._cover.style.display = ""
            }
        ;
        const _ = function() {
            t._cover || (t._cover = document.createElement("div"),
                t._cover.className = "gantt_cal_cover",
                t._cover.style.display = "none",
                t.event(t._cover, "mousemove", t._move_while_dnd),
                t.event(t._cover, "mouseup", t._finish_dnd),
                (t._lightbox_root || t.$root).appendChild(t._cover))
        };
        function f(g) {
            for (var m in this.config.types)
                if (this.config.types[m] == g)
                    return m;
            return "task"
        }
        function y(g, m) {
            var p, k, w = "";
            for (k = 0; k < g.length; k++)
                p = t.config._migrate_buttons[g[k]] ? t.config._migrate_buttons[g[k]] : g[k],
                    w += "<div " + t._waiAria.lightboxButtonAttrString(p) + " class='gantt_btn_set gantt_left_btn_set " + p + "_set'><div dhx_button='1' data-dhx-button='1' class='" + p + "'></div><div>" + t.locale.labels[p] + "</div></div>";
            return w
        }
        function v(g) {
            var m, p;
            return g.time_format ? g.time_format : (p = ["%d", "%m", "%Y"],
            Jt((m = t.getScale()) ? m.unit : t.config.duration_unit) < Jt("day") && p.push("%H:%i"),
                p)
        }
        function b(g, m, p) {
            var k, w, x, $, S, T, E = "";
            switch (p.timeFormat[m]) {
                case "%Y":
                    for (g._time_format_order[2] = m,
                             g._time_format_order.size++,
                         g.year_range && (isNaN(g.year_range) ? g.year_range.push && (x = g.year_range[0],
                             $ = g.year_range[1]) : k = g.year_range),
                             k = k || 10,
                             w = w || Math.floor(k / 2),
                             x = x || p.date.getFullYear() - w,
                             $ = $ || t.getState().max_date.getFullYear() + w,
                             S = x; S <= $; S++)
                        E += "<option value='" + S + "'>" + S + "</option>";
                    break;
                case "%m":
                    for (g._time_format_order[1] = m,
                             g._time_format_order.size++,
                             S = 0; S < 12; S++)
                        E += "<option value='" + S + "'>" + t.locale.date.month_full[S] + "</option>";
                    break;
                case "%d":
                    for (g._time_format_order[0] = m,
                             g._time_format_order.size++,
                             S = 1; S < 32; S++)
                        E += "<option value='" + S + "'>" + S + "</option>";
                    break;
                case "%H:%i":
                    for (g._time_format_order[3] = m,
                             g._time_format_order.size++,
                             S = p.first,
                             T = p.date.getDate(),
                             g._time_values = []; S < p.last; )
                        E += "<option value='" + S + "'>" + t.templates.time_picker(p.date) + "</option>",
                            g._time_values.push(S),
                            p.date.setTime(p.date.valueOf() + 60 * t._get_timepicker_step() * 1e3),
                            S = 24 * (p.date.getDate() != T ? 1 : 0) * 60 + 60 * p.date.getHours() + p.date.getMinutes()
            }
            return E
        }
        t._init_lightbox_events = function() {
            t.lightbox_events = {},
                t.lightbox_events.gantt_save_btn = function() {
                    t._save_lightbox()
                }
                ,
                t.lightbox_events.gantt_delete_btn = function() {
                    t._lightbox_current_type = null,
                    t.callEvent("onLightboxDelete", [t._lightbox_id]) && (t.isTaskExists(t._lightbox_id) ? t.$click.buttons.delete(t._lightbox_id) : t.hideLightbox())
                }
                ,
                t.lightbox_events.gantt_cancel_btn = function() {
                    t._cancel_lightbox()
                }
                ,
                t.lightbox_events.default = function(g, m) {
                    if (m.getAttribute("data-dhx-button"))
                        t.callEvent("onLightboxButton", [m.className, m, g]);
                    else {
                        var p, k, w = it(m);
                        if (w.indexOf("gantt_custom_button") != -1)
                            if (w.indexOf("gantt_custom_button_") != -1)
                                for (p = m.parentNode.getAttribute("data-index"),
                                         k = m; k && it(k).indexOf("gantt_cal_lsection") == -1; )
                                    k = k.parentNode;
                            else
                                p = m.getAttribute("data-index"),
                                    k = m.closest(".gantt_cal_lsection"),
                                    m = m.firstChild;
                        var x = t._get_typed_lightbox_config();
                        p && (p *= 1,
                            t.form_blocks[x[1 * p].type].button_click(p, m, k, k.nextSibling))
                    }
                }
                ,
                this.event(t.getLightbox(), "click", function(g) {
                    g.target.closest(".gantt_cal_ltitle_close_btn") && t._cancel_lightbox();
                    var m = Et(g)
                        , p = it(m);
                    return p || (p = it(m = m.previousSibling)),
                    m && p && p.indexOf("gantt_btn_set") === 0 && (p = it(m = m.firstChild)),
                    !(!m || !p) && (t.defined(t.lightbox_events[m.className]) ? t.lightbox_events[m.className] : t.lightbox_events.default)(g, m)
                }),
                t.getLightbox().onkeydown = function(g) {
                    var m = g || window.event
                        , p = g.target || g.srcElement
                        , k = it(p).indexOf("gantt_btn_set") > -1;
                    switch ((g || m).keyCode) {
                        case t.constants.KEY_CODES.SPACE:
                            if ((g || m).shiftKey)
                                return;
                            k && p.click && p.click();
                            break;
                        case t.keys.edit_save:
                            if ((g || m).shiftKey)
                                return;
                            k && p.click ? p.click() : t._save_lightbox();
                            break;
                        case t.keys.edit_cancel:
                            t._cancel_lightbox()
                    }
                }
        }
            ,
            t._cancel_lightbox = function() {
                var g = this.getLightboxValues();
                t._lightbox_current_type = null,
                    this.callEvent("onLightboxCancel", [this._lightbox_id, g.$new]),
                t.isTaskExists(g.id) && g.$new && (this.silent(function() {
                    t.$data.tasksStore.removeItem(g.id),
                        t._update_flags(g.id, null)
                }),
                    this.refreshData()),
                    this.hideLightbox()
            }
            ,
            t._save_lightbox = function() {
                var g = this.getLightboxValues();
                t._lightbox_current_type = null,
                this.callEvent("onLightboxSave", [this._lightbox_id, g, !!g.$new]) && (t.$data.tasksStore._skipTaskRecalculation = "lightbox",
                    g.$new ? (delete g.$new,
                        this.addTask(g, g.parent, this.getTaskIndex(g.id))) : this.isTaskExists(g.id) && (this.mixin(this.getTask(g.id), g, !0),
                        this.refreshTask(g.id),
                        this.updateTask(g.id)),
                    t.$data.tasksStore._skipTaskRecalculation = !1,
                    this.refreshData(),
                    this.hideLightbox())
            }
            ,
            t._resolve_default_mapping = function(g) {
                var m = g.map_to;
                return {
                    time: !0,
                    time_optional: !0,
                    duration: !0,
                    duration_optional: !0
                }[g.type] ? g.map_to == "auto" ? m = {
                    start_date: "start_date",
                    end_date: "end_date",
                    duration: "duration"
                } : typeof g.map_to == "string" && (m = {
                    start_date: g.map_to
                }) : g.type === "constraint" && (g.map_to && typeof g.map_to != "string" || (m = {
                    constraint_type: "constraint_type",
                    constraint_date: "constraint_date"
                })),
                    m
            }
            ,
            t.getLightboxValues = function() {
                let g = {};
                t.isTaskExists(this._lightbox_id) && (g = this.mixin({}, this.getTask(this._lightbox_id)));
                const m = [...this._get_typed_lightbox_config()].sort( (p, k) => p.name === "time" ? 1 : k.name === "time" ? -1 : 0);
                for (let p = 0; p < m.length; p++) {
                    let k = t._lightbox_root.querySelector("#" + m[p].id);
                    k = k && k.nextSibling;
                    let w = this.form_blocks[m[p].type];
                    if (!w)
                        continue;
                    let x = w.get_value.call(this, k, g, m[p])
                        , $ = t._resolve_default_mapping(m[p]);
                    if (typeof $ == "string" && $ != "auto")
                        g[$] = x;
                    else if (typeof $ == "object")
                        for (let S in $)
                            $[S] && (g[$[S]] = x[S])
                }
                return t._lightbox_current_type && (g.type = t._lightbox_current_type),
                    g
            }
            ,
            t.hideLightbox = function() {
                var g = this.getLightbox();
                g && (g.style.display = "none"),
                    this._waiAria.lightboxHiddenAttr(g),
                    this._lightbox_id = null,
                    this.hideCover(g),
                    this.resetLightbox(),
                    this.callEvent("onAfterLightbox", [])
            }
            ,
            t.hideCover = function(g) {
                g && (g.style.display = "none"),
                this._cover && this._cover.parentNode.removeChild(this._cover),
                    this._cover = null
            }
            ,
            t.resetLightbox = function() {
                t._lightbox && !t._custom_lightbox && t._lightbox.remove(),
                    t._lightbox = null
            }
            ,
            t._set_lightbox_values = function(g, m) {
                var p = g
                    , k = m.getElementsByTagName("span")
                    , w = [];
                t.templates.lightbox_header ? (w.push(""),
                    w.push(t.templates.lightbox_header(p.start_date, p.end_date, p)),
                    k[1].innerHTML = "",
                    k[2].innerHTML = t.templates.lightbox_header(p.start_date, p.end_date, p)) : (w.push(this.templates.task_time(p.start_date, p.end_date, p)),
                    w.push(String(this.templates.task_text(p.start_date, p.end_date, p) || "").substr(0, 70)),
                    k[1].innerHTML = this.templates.task_time(p.start_date, p.end_date, p),
                    k[2].innerHTML = String(this.templates.task_text(p.start_date, p.end_date, p) || "").substr(0, 70)),
                    k[1].innerHTML = w[0],
                    k[2].innerHTML = w[1],
                    t._waiAria.lightboxHeader(m, w.join(" "));
                for (var x = this._get_typed_lightbox_config(this.getLightboxType()), $ = 0; $ < x.length; $++) {
                    var S = x[$];
                    if (this.form_blocks[S.type]) {
                        var T = t._lightbox_root.querySelector("#" + S.id).nextSibling
                            , E = this.form_blocks[S.type]
                            , C = t._resolve_default_mapping(x[$])
                            , D = this.defined(p[C]) ? p[C] : S.default_value;
                        E.set_value.call(t, T, D, p, S),
                        S.focus && E.focus.call(t, T)
                    }
                }
                t.isTaskExists(g.id) && (t._lightbox_id = g.id)
            }
            ,
            t._fill_lightbox = function(g, m) {
                var p = this.getTask(g);
                this._set_lightbox_values(p, m)
            }
            ,
            t.getLightboxSection = function(g) {
                for (var m = this._get_typed_lightbox_config(), p = 0; p < m.length && m[p].name != g; p++)
                    ;
                var k = m[p];
                if (!k)
                    return null;
                this._lightbox || this.getLightbox();
                var w = t._lightbox_root.querySelector("#" + k.id)
                    , x = w.nextSibling
                    , $ = {
                    section: k,
                    header: w,
                    node: x,
                    getValue: function(T) {
                        return t.form_blocks[k.type].get_value.call(t, x, T || {}, k)
                    },
                    setValue: function(T, E) {
                        return t.form_blocks[k.type].set_value.call(t, x, T, E || {}, k)
                    }
                }
                    , S = this._lightbox_methods["get_" + k.type + "_control"];
                return S ? S($) : $
            }
            ,
            t._lightbox_methods.get_template_control = function(g) {
                return g.control = g.node,
                    g
            }
            ,
            t._lightbox_methods.get_select_control = function(g) {
                return g.control = g.node.getElementsByTagName("select")[0],
                    g
            }
            ,
            t._lightbox_methods.get_textarea_control = function(g) {
                return g.control = g.node.getElementsByTagName("textarea")[0],
                    g
            }
            ,
            t._lightbox_methods.get_time_control = function(g) {
                return g.control = g.node.getElementsByTagName("select"),
                    g
            }
            ,
            t._init_dnd_events = function() {
                var g = t._lightbox_root;
                this.event(g, "mousemove", t._move_while_dnd),
                    this.event(g, "mouseup", t._finish_dnd),
                    this.event(g, "touchmove", function(m) {
                        t._move_while_dnd(m.touches[0])
                    }),
                    this.event(g, "touchend", function(m) {
                        t._finish_dnd(m.touches[0])
                    })
            }
            ,
            t._move_while_dnd = function(g) {
                if (t._dnd_start_lb) {
                    document.gantt_unselectable || (t._lightbox_root.className += " gantt_unselectable",
                        document.gantt_unselectable = !0);
                    var m = t.getLightbox()
                        , p = [g.pageX, g.pageY];
                    m.style.top = t._lb_start[1] + p[1] - t._dnd_start_lb[1] + "px",
                        m.style.left = t._lb_start[0] + p[0] - t._dnd_start_lb[0] + "px"
                }
            }
            ,
            t._ready_to_dnd = function(g) {
                var m = t.getLightbox();
                t._lb_start = [m.offsetLeft, m.offsetTop],
                    t._dnd_start_lb = [g.pageX, g.pageY]
            }
            ,
            t._finish_dnd = function() {
                t._lb_start && (t._lb_start = t._dnd_start_lb = !1,
                    t._lightbox_root.className = t._lightbox_root.className.replace(" gantt_unselectable", ""),
                    document.gantt_unselectable = !1)
            }
            ,
            t._focus = function(g, m) {
                if (g && g.focus && !t.config.touch)
                    try {
                        m && g.select && g.select(),
                            g.focus()
                    } catch {}
            }
            ,
            t.form_blocks = {
                getTimePicker: function(g, m) {
                    var p, k, w, x = "", $ = this.config, S = {
                        first: 0,
                        last: 1440,
                        date: this.date.date_part(new Date(t._min_date.valueOf())),
                        timeFormat: v(g)
                    };
                    for (g._time_format_order = {
                        size: 0
                    },
                         t.config.limit_time_select && (S.first = 60 * $.first_hour,
                             S.last = 60 * $.last_hour + 1,
                             S.date.setHours($.first_hour)),
                             p = 0; p < S.timeFormat.length; p++)
                        p > 0 && (x += " "),
                        (k = b(g, p, S)) && (w = t._waiAria.lightboxSelectAttrString(S.timeFormat[p]),
                            x += "<select " + (g.readonly ? "disabled='disabled'" : "") + (m ? " style='display:none' " : "") + w + ">" + k + "</select>");
                    return x
                },
                getTimePickerValue: function(g, m, p) {
                    var k, w = m._time_format_order, x = 0, $ = 0, S = p || 0;
                    return t.defined(w[3]) && (k = parseInt(g[w[3] + S].value, 10),
                        x = Math.floor(k / 60),
                        $ = k % 60),
                        new Date(g[w[2] + S].value,g[w[1] + S].value,g[w[0] + S].value,x,$)
                },
                _fill_lightbox_select: function(g, m, p, k) {
                    if (g[m + k[0]].value = p.getDate(),
                        g[m + k[1]].value = p.getMonth(),
                        g[m + k[2]].value = p.getFullYear(),
                        t.defined(k[3])) {
                        var w = 60 * p.getHours() + p.getMinutes();
                        w = Math.round(w / t._get_timepicker_step()) * t._get_timepicker_step();
                        var x = g[m + k[3]];
                        x.value = w,
                            x.setAttribute("data-value", w)
                    }
                },
                template: new n,
                textarea: new e,
                select: new a,
                time: new i,
                duration: new o,
                parent: new l,
                radio: new s,
                checkbox: new r,
                resources: new d,
                constraint: new c,
                baselines: new h,
                typeselect: new u
            },
            t._is_lightbox_timepicker = function() {
                for (var g = this._get_typed_lightbox_config(), m = 0; m < g.length; m++)
                    if (g[m].name == "time" && g[m].type == "time")
                        return !0;
                return !1
            }
            ,
            t._delete_task_confirm = function({task: g, message: m, title: p, callback: k, ok: w}) {
                t._simple_confirm(m, p, k, w)
            }
            ,
            t._delete_link_confirm = function({link: g, message: m, title: p, callback: k, ok: w}) {
                t._simple_confirm(m, p, k, w)
            }
            ,
            t._simple_confirm = function(g, m, p, k) {
                if (!g)
                    return p();
                var w = {
                    text: g
                };
                m && (w.title = m),
                k && (w.ok = k),
                p && (w.callback = function(x) {
                        x && p()
                    }
                ),
                    t.confirm(w)
            }
            ,
            t._get_typed_lightbox_config = function(g) {
                g === void 0 && (g = this.getLightboxType());
                var m = f.call(this, g);
                return t.config.lightbox[m + "_sections"] ? t.config.lightbox[m + "_sections"] : t.config.lightbox.sections
            }
            ,
            t._silent_redraw_lightbox = function(g) {
                var m = this.getLightboxType();
                if (this.getState().lightbox) {
                    var p = this.getState().lightbox
                        , k = this.getLightboxValues()
                        , w = this.copy(this.getTask(p));
                    this.resetLightbox();
                    var x = this.mixin(w, k, !0)
                        , $ = this.getLightbox(g || void 0);
                    this._set_lightbox_values(x, $),
                        this.showCover($)
                } else
                    this.resetLightbox(),
                        this.getLightbox(g || void 0);
                this.callEvent("onLightboxChange", [m, this.getLightboxType()])
            }
    }
    function zr(t) {
        if (!kt.isNode) {
            t.utils = {
                arrayFind: fe,
                dom: gn
            };
            var n = Se();
            t.event = n.attach,
                t.eventRemove = n.detach,
                t._eventRemoveAll = n.detachAll,
                t._createDomEventScope = n.extend,
                O(t, Oa(t));
            var e = Mr.init(t);
            t.$ui = e.factory,
                t.$ui.layers = e.render,
                t.$mouseEvents = e.mouseEvents,
                t.$services.setService("mouseEvents", function() {
                    return t.$mouseEvents
                }),
                t.mixin(t, e.layersApi),
                t.$services.setService("layers", function() {
                    return e.layersService
                }),
                t.mixin(t, function() {
                    function i(u) {
                        return u.$ui.getView("timeline")
                    }
                    function a(u) {
                        return u.$ui.getView("grid")
                    }
                    function r(u) {
                        var h = i(u);
                        if (h && !h.$config.hidden)
                            return h;
                        var _ = a(u);
                        return _ && !_.$config.hidden ? _ : null
                    }
                    function s(u) {
                        var h = null
                            , _ = !1;
                        return [".gantt_drag_marker.gantt_grid_resize_area", ".gantt_drag_marker .gantt_row.gantt_row_task", ".gantt_drag_marker.gantt_grid_dnd_marker"].forEach(function(f) {
                            _ = _ || !!document.querySelector(f)
                        }),
                            (h = _ ? a(u) : r(u)) ? l(u, h, "scrollY") : null
                    }
                    function o(u) {
                        var h = r(u);
                        return h && h.id != "grid" ? l(u, h, "scrollX") : null
                    }
                    function l(u, h, _) {
                        var f = h.$config[_];
                        return u.$ui.getView(f)
                    }
                    var d = "DEFAULT_VALUE";
                    function c(u, h, _, f) {
                        var y = u(this);
                        return y && y.isVisible() ? y[h].apply(y, _) : f ? f() : d
                    }
                    return {
                        getColumnIndex: function(u) {
                            var h = c.call(this, a, "getColumnIndex", [u]);
                            return h === d ? 0 : h
                        },
                        dateFromPos: function(u) {
                            var h = c.call(this, i, "dateFromPos", Array.prototype.slice.call(arguments));
                            return h === d ? this.getState().min_date : h
                        },
                        posFromDate: function(u) {
                            var h = c.call(this, i, "posFromDate", [u]);
                            return h === d ? 0 : h
                        },
                        getRowTop: function(u) {
                            var h = this
                                , _ = c.call(h, i, "getRowTop", [u], function() {
                                return c.call(h, a, "getRowTop", [u])
                            });
                            return _ === d ? 0 : _
                        },
                        getTaskTop: function(u) {
                            var h = this
                                , _ = c.call(h, i, "getItemTop", [u], function() {
                                return c.call(h, a, "getItemTop", [u])
                            });
                            return _ === d ? 0 : _
                        },
                        getTaskPosition: function(u, h, _) {
                            var f = c.call(this, i, "getItemPosition", [u, h, _]);
                            return f === d ? {
                                left: 0,
                                top: this.getTaskTop(u.id),
                                height: this.getTaskBarHeight(u.id),
                                width: 0
                            } : f
                        },
                        getTaskBarHeight: function(u, h) {
                            var _ = this
                                , f = c.call(_, i, "getBarHeight", [u, h], function() {
                                return c.call(_, a, "getItemHeight", [u])
                            });
                            return f === d ? 0 : f
                        },
                        getTaskHeight: function(u) {
                            var h = this
                                , _ = c.call(h, i, "getItemHeight", [u], function() {
                                return c.call(h, a, "getItemHeight", [u])
                            });
                            return _ === d ? 0 : _
                        },
                        columnIndexByDate: function(u) {
                            var h = c.call(this, i, "columnIndexByDate", [u]);
                            return h === d ? 0 : h
                        },
                        roundTaskDates: function() {
                            c.call(this, i, "roundTaskDates", [])
                        },
                        getScale: function() {
                            var u = c.call(this, i, "getScale", []);
                            return u === d ? null : u
                        },
                        getTaskNode: function(u) {
                            var h = i(this);
                            if (h && h.isVisible()) {
                                var _ = h._taskRenderer.rendered[u];
                                if (!_) {
                                    var f = h.$config.item_attribute;
                                    _ = h.$task_bars.querySelector("[" + f + "='" + u + "']")
                                }
                                return _ || null
                            }
                            return null
                        },
                        getLinkNode: function(u) {
                            var h = i(this);
                            return h.isVisible() ? h._linkRenderer.rendered[u] : null
                        },
                        scrollTo: function(u, h) {
                            var _ = s(this)
                                , f = o(this)
                                , y = {
                                position: 0
                            }
                                , v = {
                                position: 0
                            };
                            _ && (v = _.getScrollState()),
                            f && (y = f.getScrollState());
                            var b = f && 1 * u == u
                                , g = _ && 1 * h == h;
                            if (b && g)
                                for (var m = _._getLinkedViews(), p = f._getLinkedViews(), k = [], w = 0; w < m.length; w++)
                                    for (var x = 0; x < p.length; x++)
                                        m[w].$config.id && p[x].$config.id && m[w].$config.id === p[x].$config.id && k.push(m[w].$config.id);
                            b && (k && k.forEach((function(T) {
                                    this.$ui.getView(T).$config.$skipSmartRenderOnScroll = !0
                                }
                            ).bind(this)),
                                f.scroll(u),
                            k && k.forEach((function(T) {
                                    this.$ui.getView(T).$config.$skipSmartRenderOnScroll = !1
                                }
                            ).bind(this))),
                            g && _.scroll(h);
                            var $ = {
                                position: 0
                            }
                                , S = {
                                position: 0
                            };
                            _ && ($ = _.getScrollState()),
                            f && (S = f.getScrollState()),
                                this.callEvent("onGanttScroll", [y.position, v.position, S.position, $.position])
                        },
                        showDate: function(u) {
                            var h = this.posFromDate(u)
                                , _ = Math.max(h - this.config.task_scroll_offset, 0);
                            this.scrollTo(_)
                        },
                        showTask: function(u) {
                            var h = this.getTaskPosition(this.getTask(u))
                                , _ = h.left;
                            this.config.rtl && (_ = h.left + h.width);
                            var f, y = Math.max(_ - this.config.task_scroll_offset, 0), v = this._scroll_state().y;
                            f = v ? h.top - (v - this.getTaskBarHeight(u)) / 2 : h.top,
                                this.scrollTo(y, f);
                            var b = a(this)
                                , g = i(this);
                            b && g && b.$config.scrollY != g.$config.scrollY && l(this, b, "scrollY").scrollTo(null, f)
                        },
                        _scroll_state: function() {
                            var u = {
                                x: !1,
                                y: !1,
                                x_pos: 0,
                                y_pos: 0,
                                scroll_size: this.config.scroll_size + 1,
                                x_inner: 0,
                                y_inner: 0
                            }
                                , h = s(this)
                                , _ = o(this);
                            if (_) {
                                var f = _.getScrollState();
                                f.visible && (u.x = f.size,
                                    u.x_inner = f.scrollSize),
                                    u.x_pos = f.position || 0
                            }
                            if (h) {
                                var y = h.getScrollState();
                                y.visible && (u.y = y.size,
                                    u.y_inner = y.scrollSize),
                                    u.y_pos = y.position || 0
                            }
                            return u
                        },
                        getScrollState: function() {
                            var u = this._scroll_state();
                            return {
                                x: u.x_pos,
                                y: u.y_pos,
                                inner_width: u.x,
                                inner_height: u.y,
                                width: u.x_inner,
                                height: u.y_inner
                            }
                        },
                        getLayoutView: function(u) {
                            return this.$ui.getView(u)
                        },
                        scrollLayoutCell: function(u, h, _) {
                            const f = this.$ui.getView(u);
                            if (!f)
                                return !1;
                            if (h !== null) {
                                const y = this.$ui.getView(f.$config.scrollX);
                                y && y.scrollTo(h, null)
                            }
                            if (_ !== null) {
                                const y = this.$ui.getView(f.$config.scrollY);
                                y && y.scrollTo(null, _)
                            }
                        }
                    }
                }()),
                function(i) {
                    i.resetSkin || (i.resetSkin = function() {
                        this.skin = "",
                            Je(!0, this)
                    }
                        ,
                        i.skins = {},
                        i.attachEvent("onGanttLayoutReady", function() {
                            Je(!1, this),
                                r()
                        })),
                        i._addThemeClass = function() {
                            document.documentElement.setAttribute("data-gantt-theme", i.skin)
                        }
                        ,
                        i.setSkin = function(s) {
                            const o = this.skin !== s;
                            this.skin = s,
                                i._addThemeClass(),
                                r(),
                            i.$root && (Je(!o, i),
                                this.render())
                        }
                    ;
                    let a = null;
                    function r() {
                        const s = i.$root;
                        a && clearInterval(a),
                        s && (a = setInterval( () => {
                                const o = getComputedStyle(s).getPropertyValue("--dhx-gantt-theme");
                                o && o !== i.skin && i.setSkin(o)
                            }
                            , 100))
                    }
                    i.attachEvent("onDestroy", function() {
                        clearInterval(a)
                    })
                }(t),
                function(i) {
                    i.skins.skyblue = {
                        config: {
                            grid_width: 370,
                            row_height: 27,
                            bar_height_padding: 4,
                            scale_height: 27,
                            link_line_width: 1,
                            link_arrow_size: 8,
                            link_radius: 2,
                            lightbox_additional_height: 75
                        },
                        _second_column_width: 95,
                        _third_column_width: 80
                    }
                }(t),
                function(i) {
                    i.skins.dark = {
                        config: {
                            grid_width: 390,
                            row_height: 36,
                            scale_height: 36,
                            link_line_width: 2,
                            link_arrow_size: 12,
                            bar_height_padding: 9,
                            lightbox_additional_height: 75
                        },
                        _second_column_width: 100,
                        _third_column_width: 70
                    }
                }(t),
                function(i) {
                    i.skins.meadow = {
                        config: {
                            grid_width: 380,
                            row_height: 27,
                            scale_height: 30,
                            link_line_width: 2,
                            link_arrow_size: 10,
                            bar_height_padding: 4,
                            lightbox_additional_height: 72
                        },
                        _second_column_width: 95,
                        _third_column_width: 80
                    }
                }(t),
                function(i) {
                    i.skins.terrace = {
                        config: {
                            grid_width: 390,
                            row_height: 36,
                            scale_height: 36,
                            link_line_width: 2,
                            link_arrow_size: 12,
                            bar_height_padding: 9,
                            lightbox_additional_height: 75
                        },
                        _second_column_width: 100,
                        _third_column_width: 70
                    }
                }(t),
                function(i) {
                    i.skins.broadway = {
                        config: {
                            grid_width: 390,
                            row_height: 35,
                            scale_height: 35,
                            link_line_width: 1,
                            link_arrow_size: 9,
                            bar_height_padding: 4,
                            lightbox_additional_height: 86
                        },
                        _second_column_width: 100,
                        _third_column_width: 80,
                        _lightbox_template: "<div class='gantt_cal_ltitle'><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='gantt_title'></span><div class='gantt_cancel_btn'></div></div><div class='gantt_cal_larea'></div>",
                        _config_buttons_left: {},
                        _config_buttons_right: {
                            gantt_delete_btn: "icon_delete",
                            gantt_save_btn: "icon_save"
                        }
                    }
                }(t),
                function(i) {
                    i.skins.material = {
                        config: {
                            grid_width: 411,
                            row_height: 34,
                            scale_height: 36,
                            link_line_width: 2,
                            link_arrow_size: 12,
                            bar_height_padding: 9,
                            lightbox_additional_height: 80
                        },
                        _second_column_width: 110,
                        _third_column_width: 75,
                        _redefine_lightbox_buttons: {
                            buttons_left: ["dhx_delete_btn"],
                            buttons_right: ["dhx_cancel_btn", "dhx_save_btn"]
                        }
                    },
                        i.attachEvent("onAfterTaskDrag", function(a) {
                            var r = i.getTaskNode(a);
                            r && (r.className += " gantt_drag_animation",
                                setTimeout(function() {
                                    var s = r.className.indexOf(" gantt_drag_animation");
                                    s > -1 && (r.className = r.className.slice(0, s))
                                }, 200))
                        })
                }(t),
                function(i) {
                    i.skins.contrast_black = {
                        config: {
                            grid_width: 390,
                            row_height: 35,
                            scale_height: 35,
                            link_line_width: 2,
                            link_arrow_size: 12,
                            lightbox_additional_height: 75
                        },
                        _second_column_width: 100,
                        _third_column_width: 80
                    }
                }(t),
                function(i) {
                    i.skins.contrast_white = {
                        config: {
                            grid_width: 390,
                            row_height: 35,
                            scale_height: 35,
                            link_line_width: 2,
                            link_arrow_size: 12,
                            lightbox_additional_height: 75
                        },
                        _second_column_width: 100,
                        _third_column_width: 80
                    }
                }(t),
                function(i) {
                    i.ext || (i.ext = {});
                    for (var a = [Ir, null, null], r = 0; r < a.length; r++)
                        a[r] && a[r](i);
                    i.ext.zoom = new Pr(i)
                }(t),
                Rr(t),
                Br(t),
                function(i) {
                    i._extend_to_optional = function(a) {
                        var r = a
                            , s = {
                            render: r.render,
                            focus: r.focus,
                            set_value: function(o, l, d, c) {
                                var u = i._resolve_default_mapping(c);
                                if (!d[u.start_date] || u.start_date == "start_date" && this._isAllowedUnscheduledTask(d)) {
                                    s.disable(o, c);
                                    var h = {};
                                    for (var _ in u)
                                        h[u[_]] = d[_];
                                    return r.set_value.call(i, o, l, h, c)
                                }
                                return s.enable(o, c),
                                    r.set_value.call(i, o, l, d, c)
                            },
                            get_value: function(o, l, d) {
                                return d.disabled ? {
                                    start_date: null
                                } : r.get_value.call(i, o, l, d)
                            },
                            update_block: function(o, l) {
                                if (i.callEvent("onSectionToggle", [i._lightbox_id, l]),
                                    o.style.display = l.disabled ? "none" : "",
                                    l.button) {
                                    var d = o.previousSibling.querySelector(".gantt_custom_button_label")
                                        , c = i.locale.labels
                                        , u = l.disabled ? c[l.name + "_enable_button"] : c[l.name + "_disable_button"];
                                    d.innerHTML = u
                                }
                            },
                            disable: function(o, l) {
                                l.disabled = !0,
                                    s.update_block(o, l)
                            },
                            enable: function(o, l) {
                                l.disabled = !1,
                                    s.update_block(o, l)
                            },
                            button_click: function(o, l, d, c) {
                                if (i.callEvent("onSectionButton", [i._lightbox_id, d]) !== !1) {
                                    var u = i._get_typed_lightbox_config()[o];
                                    u.disabled ? s.enable(c, u) : s.disable(c, u)
                                }
                            }
                        };
                        return s
                    }
                        ,
                        i.form_blocks.duration_optional = i._extend_to_optional(i.form_blocks.duration),
                        i.form_blocks.time_optional = i._extend_to_optional(i.form_blocks.time)
                }(t),
                function(i) {
                    var a = new RegExp(`<(?:.|
)*?>`,"gm")
                        , r = new RegExp(" +","gm");
                    function s(c) {
                        return (c + "").replace(a, " ").replace(r, " ")
                    }
                    var o = new RegExp("'","gm");
                    function l(c) {
                        return (c + "").replace(o, "&#39;")
                    }
                    for (var d in i._waiAria = {
                        getAttributeString: function(c) {
                            var u = [" "];
                            for (var h in c) {
                                var _ = l(s(c[h]));
                                u.push(h + "='" + _ + "'")
                            }
                            return u.push(" "),
                                u.join(" ")
                        },
                        getTimelineCellAttr: function(c) {
                            return i._waiAria.getAttributeString({
                                "aria-label": c
                            })
                        },
                        _taskCommonAttr: function(c, u) {
                            c.start_date && c.end_date && (u.setAttribute("aria-label", s(i.templates.tooltip_text(c.start_date, c.end_date, c))),
                            c.$dataprocessor_class && u.setAttribute("aria-busy", !0))
                        },
                        setTaskBarAttr: function(c, u) {
                            this._taskCommonAttr(c, u),
                                u.setAttribute("role", "img"),
                            !i.isReadonly(c) && i.config.drag_move && (c.id != i.getState("tasksDnd").drag_id ? u.setAttribute("aria-grabbed", !1) : u.setAttribute("aria-grabbed", !0))
                        },
                        taskRowAttr: function(c, u) {
                            this._taskCommonAttr(c, u),
                            !i.isReadonly(c) && i.config.order_branch && u.setAttribute("aria-grabbed", !1),
                                u.setAttribute("role", "row"),
                                u.setAttribute("aria-selected", i.isSelectedTask(c.id) ? "true" : "false"),
                                u.setAttribute("aria-level", c.$level + 1 || 1),
                            i.hasChild(c.id) && u.setAttribute("aria-expanded", c.$open ? "true" : "false")
                        },
                        linkAttr: function(c, u) {
                            var h = i.config.links
                                , _ = c.type == h.finish_to_start || c.type == h.start_to_start
                                , f = c.type == h.start_to_start || c.type == h.start_to_finish
                                , y = i.locale.labels.link + " " + i.templates.drag_link(c.source, f, c.target, _);
                            u.setAttribute("role", "img"),
                                u.setAttribute("aria-label", s(y))
                        },
                        gridSeparatorAttr: function(c) {
                            c.setAttribute("role", "columnheader")
                        },
                        rowResizerAttr: function(c) {
                            c.setAttribute("role", "row")
                        },
                        lightboxHiddenAttr: function(c) {
                            c.setAttribute("aria-hidden", "true")
                        },
                        lightboxVisibleAttr: function(c) {
                            c.setAttribute("aria-hidden", "false")
                        },
                        lightboxAttr: function(c) {
                            c.setAttribute("role", "dialog"),
                                c.setAttribute("aria-hidden", "true"),
                                c.firstChild.setAttribute("role", "heading"),
                                c.firstChild.setAttribute("aria-level", "1")
                        },
                        lightboxButtonAttrString: function(c) {
                            return this.getAttributeString({
                                role: "button",
                                "aria-label": i.locale.labels[c],
                                tabindex: "0"
                            })
                        },
                        lightboxHeader: function(c, u) {
                            c.setAttribute("aria-label", u)
                        },
                        lightboxSelectAttrString: function(c) {
                            var u = "";
                            switch (c) {
                                case "%Y":
                                    u = i.locale.labels.years;
                                    break;
                                case "%m":
                                    u = i.locale.labels.months;
                                    break;
                                case "%d":
                                    u = i.locale.labels.days;
                                    break;
                                case "%H:%i":
                                    u = i.locale.labels.hours + i.locale.labels.minutes
                            }
                            return i._waiAria.getAttributeString({
                                "aria-label": u
                            })
                        },
                        lightboxDurationInputAttrString: function(c) {
                            return this.getAttributeString({
                                "aria-label": i.locale.labels.column_duration,
                                "aria-valuemin": "0",
                                role: "spinbutton"
                            })
                        },
                        inlineEditorAttr: function(c) {
                            c.setAttribute("role", "row")
                        },
                        gridAttrString: function() {
                            return [" role='treegrid'", i.config.multiselect ? "aria-multiselectable='true'" : "aria-multiselectable='false'", " "].join(" ")
                        },
                        gridScaleRowAttrString: function() {
                            return "role='row'"
                        },
                        gridScaleCellAttrString: function(c, u) {
                            var h = "";
                            if (c.name == "add")
                                h = this.getAttributeString({
                                    role: "columnheader",
                                    "aria-label": i.locale.labels.new_task
                                });
                            else {
                                var _ = {
                                    role: "columnheader",
                                    "aria-label": i.config.external_render && i.config.external_render.isElement(u) ? "" : u
                                };
                                i._sort && i._sort.name == c.name && (i._sort.direction == "asc" ? _["aria-sort"] = "ascending" : _["aria-sort"] = "descending"),
                                    h = this.getAttributeString(_)
                            }
                            return h
                        },
                        gridDataAttrString: function() {
                            return "role='rowgroup'"
                        },
                        reorderMarkerAttr: function(c) {
                            c.setAttribute("role", "grid"),
                                c.firstChild.removeAttribute("aria-level"),
                                c.firstChild.setAttribute("aria-grabbed", "true")
                        },
                        gridCellAttrString: function(c, u, h) {
                            var _ = {
                                role: "gridcell",
                                "aria-label": u
                            };
                            return c.editor && !i.isReadonly(h) || (_["aria-readonly"] = !0),
                                this.getAttributeString(_)
                        },
                        gridAddButtonAttrString: function(c) {
                            return this.getAttributeString({
                                role: "button",
                                "aria-label": i.locale.labels.new_task
                            })
                        },
                        messageButtonAttrString: function(c) {
                            return "tabindex='0' role='button' aria-label='" + c + "'"
                        },
                        messageInfoAttr: function(c) {
                            c.setAttribute("role", "alert")
                        },
                        messageModalAttr: function(c, u) {
                            c.setAttribute("role", "dialog"),
                            u && c.setAttribute("aria-labelledby", u)
                        },
                        quickInfoAttr: function(c) {
                            c.setAttribute("role", "dialog")
                        },
                        quickInfoHeaderAttrString: function() {
                            return " role='heading' aria-level='1' "
                        },
                        quickInfoHeader: function(c, u) {
                            c.setAttribute("aria-label", u)
                        },
                        quickInfoButtonAttrString: function(c) {
                            return i._waiAria.getAttributeString({
                                role: "button",
                                "aria-label": c,
                                tabindex: "0"
                            })
                        },
                        tooltipAttr: function(c) {
                            c.setAttribute("role", "tooltip")
                        },
                        tooltipVisibleAttr: function(c) {
                            c.setAttribute("aria-hidden", "false")
                        },
                        tooltipHiddenAttr: function(c) {
                            c.setAttribute("aria-hidden", "true")
                        }
                    },
                        i._waiAria)
                        i._waiAria[d] = function(c) {
                            return function() {
                                return i.config.wai_aria_attributes ? c.apply(this, arguments) : ""
                            }
                        }(i._waiAria[d])
                }(t),
                t.locate = function(i) {
                    var a = Et(i);
                    if (dt(a, ".gantt_task_row"))
                        return null;
                    var r = arguments[1] || this.config.task_attribute
                        , s = Q(a, r);
                    return s ? s.getAttribute(r) : null
                }
                ,
                t._locate_css = function(i, a, r) {
                    return mt(i, a, r)
                }
                ,
                t._locateHTML = function(i, a) {
                    return Q(i, a || this.config.task_attribute)
                }
        }
        t.attachEvent("onParse", function() {
            K(t) || t.attachEvent("onGanttRender", function() {
                if (t.config.initial_scroll) {
                    var i = t.getTaskByIndex(0)
                        , a = i ? i.id : t.config.root_id;
                    t.isTaskExists(a) && t.$task && t.utils.dom.isChildOf(t.$task, t.$container) && t.showTask(a)
                }
            }, {
                once: !0
            })
        }),
            t.attachEvent("onBeforeGanttReady", function() {
                this.config.scroll_size || (this.config.scroll_size = on() || 15),
                K(t) || (this._eventRemoveAll(),
                    this.$mouseEvents.reset(),
                    this.resetLightbox())
            }),
            t.attachEvent("onGanttReady", function() {
                !K(t) && t.config.rtl && t.$layout.getCellsByType("viewCell").forEach(function(i) {
                    var a = i.$config.scrollX;
                    if (a) {
                        var r = t.$ui.getView(a);
                        r && r.scrollTo(r.$config.scrollSize, 0)
                    }
                })
            }),
            t.attachEvent("onGanttReady", function() {
                if (!K(t)) {
                    var i = t.plugins()
                        , a = {
                        auto_scheduling: t.autoSchedule,
                        click_drag: t.ext.clickDrag,
                        critical_path: t.isCriticalTask,
                        drag_timeline: t.ext.dragTimeline,
                        export_api: t.exportToPDF,
                        fullscreen: t.ext.fullscreen,
                        grouping: t.groupBy,
                        keyboard_navigation: t.ext.keyboardNavigation,
                        marker: t.addMarker,
                        multiselect: t.eachSelectedTask,
                        overlay: t.ext.overlay,
                        quick_info: t.templates.quick_info_content,
                        tooltip: t.ext.tooltips,
                        undo: t.undo
                    };
                    for (let r in a)
                        a[r] && !i[r] && console.warn(`You connected the '${r}' extension via an obsolete file. 
To fix it, you need to remove the obsolete file and connect the extension via the plugins method: https://docs.dhtmlx.com/gantt/api__gantt_plugins.html`)
                }
            })
    }
    function jr(t) {
        var n = {};
        t.$data.tasksStore.attachEvent("onClearAll", function() {
            n = {}
        });
        var e = Te.prototype.hasChild;
        t.$data.tasksStore.hasChild = function(i) {
            return t.config.branch_loading ? !!e.call(this, i) || !!this.exists(i) && this.getItem(i)[t.config.branch_loading_property] : e.call(this, i)
        }
            ,
            t.attachEvent("onTaskOpened", function(i) {
                if (t.config.branch_loading && t._load_url && function(l) {
                    return !(!t.config.branch_loading || !t._load_url || n[l] || t.getChildren(l).length || !t.hasChild(l))
                }(i)) {
                    var a = t._load_url
                        , r = (a = a.replace(/(\?|&)?parent_id=.+&?/, "")).indexOf("?") >= 0 ? "&" : "?"
                        , s = t.getScrollState().y || 0
                        , o = {
                        taskId: i,
                        url: a + r + "parent_id=" + encodeURIComponent(i)
                    };
                    if (t.callEvent("onBeforeBranchLoading", [o]) === !1)
                        return;
                    t.load(o.url, this._load_type, function() {
                        s && t.scrollTo(null, s),
                            t.callEvent("onAfterBranchLoading", [o])
                    }),
                        n[i] = !0
                }
            })
    }
    const le = new class {
        constructor(t, n) {
            this.plugin = e => {
                this._ganttPlugin.push(e),
                J.gantt !== void 0 && J.gantt.getTask && e(J.gantt)
            }
                ,
                this.getGanttInstance = e => {
                    const i = this._factoryMethod(this._bundledExtensions);
                    for (let a = 0; a < this._ganttPlugin.length; a++)
                        this._ganttPlugin[a](i);
                    return i._internal_id = this._seed++,
                    e && this._initFromConfig(i, e),
                        i
                }
                ,
                this._initFromConfig = (e, i) => {
                    if (i.plugins)
                        for (const a in i.plugins)
                            this._extensionsManager.getExtension(a) && e.plugins({
                                [a]: !0
                            });
                    if (i.config && e.mixin(e.config, i.config, !0),
                    i.templates && e.attachEvent("onTemplatesReady", function() {
                        e.mixin(e.templates, i.templates, !0)
                    }, {
                        once: !0
                    }),
                        i.events)
                        for (const a in i.events)
                            e.attachEvent(a, i.events[a]);
                    i.locale && e.i18n.setLocale(i.locale),
                    Array.isArray(i.calendars) && i.calendars.forEach(function(a) {
                        e.addCalendar(a)
                    }),
                        i.container ? e.init(i.container) : e.init(),
                    i.data && (typeof i.data == "string" ? e.load(i.data) : e.parse(i.data))
                }
                ,
                this._seed = 0,
                this._ganttPlugin = [],
                this._factoryMethod = t,
                this._bundledExtensions = n,
                this._extensionsManager = new bn(n)
        }
    }
    (function(t) {
            var n = Ha(t);
            return n.env.isNode || (zr(n),
                function(e) {
                    e.load = function(i, a, r) {
                        this._load_url = i,
                            this.assert(arguments.length, "Invalid load arguments");
                        var s = "json"
                            , o = null;
                        return arguments.length >= 3 ? (s = a,
                            o = r) : typeof arguments[1] == "string" ? s = arguments[1] : typeof arguments[1] == "function" && (o = arguments[1]),
                            this._load_type = s,
                            this.callEvent("onLoadStart", [i, s]),
                            this.ajax.get(i, e.bind(function(l) {
                                this.on_load(l, s),
                                    this.callEvent("onLoadEnd", [i, s]),
                                typeof o == "function" && o.call(this)
                            }, this))
                    }
                }(n),
                jr(n)),
                n
        }
        ,bi)
        , Qe = le.getGanttInstance();
    J.gantt = Qe,
        J.Gantt = le,
        St.Gantt = le,
        St.default = Qe,
        St.gantt = Qe,
        Object.defineProperties(St, {
            __esModule: {
                value: !0
            },
            [Symbol.toStringTag]: {
                value: "Module"
            }
        })
});
